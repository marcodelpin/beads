//go:build cgo

package fix

import (
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"testing"
	"time"

	"github.com/steveyegge/beads/internal/configfile"
	"github.com/steveyegge/beads/internal/storage/dolt"
	"github.com/steveyegge/beads/internal/types"
)

// fixTestServerPort returns the Dolt server port for fix tests.
// Returns 0 when BEADS_DOLT_PORT is unset so callers fail safely
// instead of accidentally connecting to a production server on 3307.
func fixTestServerPort() int {
	if p := os.Getenv("BEADS_DOLT_PORT"); p != "" {
		if port, _ := strconv.Atoi(p); port > 0 {
			return port
		}
	}
	return 0
}

// newFixTestStore creates a DoltStore for fix package tests with proper
// .beads directory structure so openAnyDB can connect for end-to-end testing.
func newFixTestStore(t *testing.T, dir string, prefix string) *dolt.DoltStore {
	t.Helper()
	ctx := context.Background()

	// Determine server port
	port := fixTestServerPort()

	// Generate unique database name for test isolation
	h := sha256.Sum256([]byte(t.Name() + fmt.Sprintf("%d", time.Now().UnixNano())))
	dbName := "fixtest_" + hex.EncodeToString(h[:6])

	// Create .beads directory
	beadsDir := filepath.Join(dir, ".beads")
	if err := os.MkdirAll(beadsDir, 0755); err != nil {
		t.Fatalf("Failed to create .beads: %v", err)
	}

	// Write metadata.json so openAnyDB can connect to the same database
	cfg := &configfile.Config{
		Database:       "dolt",
		DoltMode:       configfile.DoltModeServer,
		DoltServerHost: "127.0.0.1",
		DoltServerPort: port,
		DoltDatabase:   dbName,
	}
	if err := cfg.Save(beadsDir); err != nil {
		t.Fatalf("Failed to write metadata.json: %v", err)
	}

	// Create store connected to the same database
	dbPath := filepath.Join(beadsDir, "beads.db")
	store, err := dolt.New(ctx, &dolt.Config{
		Path:       dbPath,
		ServerHost: "127.0.0.1",
		ServerPort: port,
		Database:   dbName,
	})
	if err != nil {
		t.Skipf("skipping: Dolt not available: %v", err)
	}

	if err := store.SetConfig(ctx, "issue_prefix", prefix); err != nil {
		store.Close()
		t.Fatalf("Failed to set issue_prefix: %v", err)
	}

	t.Cleanup(func() {
		store.Close()
		dropFixTestDatabase(dbName, port)
	})
	return store
}

// dropFixTestDatabase drops a test database (best-effort cleanup).
func dropFixTestDatabase(dbName string, port int) {
	dsn := fmt.Sprintf("root@tcp(127.0.0.1:%d)/?parseTime=true&timeout=5s", port)
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return
	}
	defer db.Close()
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	//nolint:gosec // G201: dbName is generated by test (fixtest_ + random hex)
	_, _ = db.ExecContext(ctx, fmt.Sprintf("DROP DATABASE IF EXISTS `%s`", dbName))
}

// TestFixFunctions_RequireBeadsDir verifies all fix functions properly validate
// that a .beads directory exists before attempting fixes.
func TestFixFunctions_RequireBeadsDir(t *testing.T) {
	funcs := []struct {
		name string
		fn   func(string) error
	}{
		{"GitHooks", GitHooks},
		{"DatabaseVersion", DatabaseVersion},
		{"SchemaCompatibility", SchemaCompatibility},
		{"ChildParentDependencies", func(dir string) error { return ChildParentDependencies(dir, false) }},
		{"OrphanedDependencies", func(dir string) error { return OrphanedDependencies(dir, false) }},
	}

	for _, tc := range funcs {
		t.Run(tc.name, func(t *testing.T) {
			// Use a temp directory without .beads
			dir := t.TempDir()
			err := tc.fn(dir)
			if err == nil {
				t.Errorf("%s should return error for missing .beads directory", tc.name)
			}
		})
	}
}

func TestChildParentDependencies_NoBadDeps(t *testing.T) {
	dir := t.TempDir()
	store := newFixTestStore(t, dir, "bd")
	ctx := context.Background()

	// Create issues
	for _, id := range []string{"bd-abc", "bd-abc.1", "bd-xyz"} {
		issue := &types.Issue{
			ID:        id,
			Title:     "Issue " + id,
			Status:    types.StatusOpen,
			IssueType: types.TypeTask,
			CreatedAt: time.Now(),
		}
		if err := store.CreateIssue(ctx, issue, "test"); err != nil {
			t.Fatal(err)
		}
	}

	// Add a non-child→parent dependency (bd-abc.1 blocks bd-xyz)
	dep := &types.Dependency{
		IssueID:     "bd-abc.1",
		DependsOnID: "bd-xyz",
		Type:        types.DepBlocks,
		CreatedAt:   time.Now(),
		CreatedBy:   "test",
	}
	if err := store.AddDependency(ctx, dep, "test"); err != nil {
		t.Fatal(err)
	}

	// Run fix - should find no bad deps
	err := ChildParentDependencies(dir, false)
	if err != nil {
		t.Errorf("ChildParentDependencies failed: %v", err)
	}

	// Verify the good dependency still exists
	db := store.UnderlyingDB()
	var count int
	if err := db.QueryRow("SELECT COUNT(*) FROM dependencies").Scan(&count); err != nil {
		t.Fatal(err)
	}
	if count != 1 {
		t.Errorf("Expected 1 dependency, got %d", count)
	}
}

func TestChildParentDependencies_FixesBadDeps(t *testing.T) {
	dir := t.TempDir()
	store := newFixTestStore(t, dir, "bd")
	ctx := context.Background()

	// Create issues
	for _, id := range []string{"bd-abc", "bd-abc.1", "bd-abc.1.2"} {
		issue := &types.Issue{
			ID:        id,
			Title:     "Issue " + id,
			Status:    types.StatusOpen,
			IssueType: types.TypeTask,
			CreatedAt: time.Now(),
		}
		if err := store.CreateIssue(ctx, issue, "test"); err != nil {
			t.Fatal(err)
		}
	}

	// Add child→parent blocking dependencies (anti-pattern)
	for _, d := range []struct{ from, to string }{
		{"bd-abc.1", "bd-abc"},
		{"bd-abc.1.2", "bd-abc"},
		{"bd-abc.1.2", "bd-abc.1"},
	} {
		dep := &types.Dependency{
			IssueID:     d.from,
			DependsOnID: d.to,
			Type:        types.DepBlocks,
			CreatedAt:   time.Now(),
			CreatedBy:   "test",
		}
		if err := store.AddDependency(ctx, dep, "test"); err != nil {
			t.Fatal(err)
		}
	}

	// Run fix
	err := ChildParentDependencies(dir, false)
	if err != nil {
		t.Errorf("ChildParentDependencies failed: %v", err)
	}

	// Verify all bad dependencies were removed
	db := store.UnderlyingDB()
	var count int
	if err := db.QueryRow("SELECT COUNT(*) FROM dependencies").Scan(&count); err != nil {
		t.Fatal(err)
	}
	if count != 0 {
		t.Errorf("Expected 0 dependencies after fix, got %d", count)
	}
}

// TestChildParentDependencies_PreservesParentChildType verifies that legitimate
// parent-child type dependencies are NOT removed (only blocking types are removed).
func TestChildParentDependencies_PreservesParentChildType(t *testing.T) {
	dir := t.TempDir()
	store := newFixTestStore(t, dir, "bd")
	ctx := context.Background()

	// Create issues
	for _, id := range []string{"bd-abc", "bd-abc.1", "bd-abc.2"} {
		issue := &types.Issue{
			ID:        id,
			Title:     "Issue " + id,
			Status:    types.StatusOpen,
			IssueType: types.TypeTask,
			CreatedAt: time.Now(),
		}
		if err := store.CreateIssue(ctx, issue, "test"); err != nil {
			t.Fatal(err)
		}
	}

	// Add legitimate parent-child deps
	for _, child := range []string{"bd-abc.1", "bd-abc.2"} {
		dep := &types.Dependency{
			IssueID:     child,
			DependsOnID: "bd-abc",
			Type:        types.DepParentChild,
			CreatedAt:   time.Now(),
			CreatedBy:   "test",
		}
		if err := store.AddDependency(ctx, dep, "test"); err != nil {
			t.Fatal(err)
		}
	}

	// Add one child→parent blocking dep (anti-pattern to be removed).
	// Note: AddDependency uses ON DUPLICATE KEY UPDATE, so this REPLACES the
	// parent-child dep for bd-abc.1→bd-abc with a blocks dep (same key pair).
	blockDep := &types.Dependency{
		IssueID:     "bd-abc.1",
		DependsOnID: "bd-abc",
		Type:        types.DepBlocks,
		CreatedAt:   time.Now(),
		CreatedBy:   "test",
	}
	if err := store.AddDependency(ctx, blockDep, "test"); err != nil {
		t.Fatal(err)
	}

	// Run fix
	err := ChildParentDependencies(dir, false)
	if err != nil {
		t.Fatalf("ChildParentDependencies failed: %v", err)
	}

	// Verify only 'blocks' type was removed, 'parent-child' preserved.
	// Only bd-abc.2→bd-abc parent-child survives because bd-abc.1→bd-abc
	// was overwritten by the blocks dep (ON DUPLICATE KEY UPDATE), then removed by fix.
	db := store.UnderlyingDB()

	var blocksCount int
	if err := db.QueryRow("SELECT COUNT(*) FROM dependencies WHERE type = 'blocks'").Scan(&blocksCount); err != nil {
		t.Fatal(err)
	}
	if blocksCount != 0 {
		t.Errorf("Expected 0 'blocks' dependencies after fix, got %d", blocksCount)
	}

	var parentChildCount int
	if err := db.QueryRow("SELECT COUNT(*) FROM dependencies WHERE type = 'parent-child'").Scan(&parentChildCount); err != nil {
		t.Fatal(err)
	}
	if parentChildCount != 1 {
		t.Errorf("Expected 1 'parent-child' dependency preserved, got %d", parentChildCount)
	}
}
