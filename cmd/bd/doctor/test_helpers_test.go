//go:build cgo

package doctor

import (
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"testing"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/steveyegge/beads/internal/storage/dolt"
	"github.com/steveyegge/beads/internal/types"
)

// doctorTestServerPort returns the Dolt server port for doctor tests.
func doctorTestServerPort() int {
	if p := os.Getenv("BEADS_DOLT_PORT"); p != "" {
		if port, _ := strconv.Atoi(p); port > 0 {
			return port
		}
	}
	return 3307 // default dolt sql-server port
}

// newTestDoltStore creates a DoltStore for testing in the doctor package.
// Each test gets an isolated database to prevent cross-test pollution.
func newTestDoltStore(t *testing.T, prefix string) *dolt.DoltStore {
	t.Helper()
	ctx := context.Background()

	port := doctorTestServerPort()

	// Generate unique database name for test isolation
	h := sha256.Sum256([]byte(t.Name() + fmt.Sprintf("%d", time.Now().UnixNano())))
	dbName := "doctest_" + hex.EncodeToString(h[:6])

	store, err := dolt.New(ctx, &dolt.Config{
		Path:       filepath.Join(t.TempDir(), "test.db"),
		ServerHost: "127.0.0.1",
		ServerPort: port,
		Database:   dbName,
	})
	if err != nil {
		t.Skipf("skipping: Dolt not available: %v", err)
	}
	if err := store.SetConfig(ctx, "issue_prefix", prefix); err != nil {
		store.Close()
		t.Fatalf("Failed to set issue_prefix: %v", err)
	}
	// Configure Gas Town custom types for compatibility
	if err := store.SetConfig(ctx, "types.custom", "molecule,gate,convoy,merge-request,slot,agent,role,rig,event,message"); err != nil {
		store.Close()
		t.Fatalf("Failed to set types.custom: %v", err)
	}
	t.Cleanup(func() {
		store.Close()
		dropDoctorTestDatabase(dbName, port)
	})
	return store
}

// dropDoctorTestDatabase drops a test database (best-effort cleanup).
func dropDoctorTestDatabase(dbName string, port int) {
	dsn := fmt.Sprintf("root@tcp(127.0.0.1:%d)/?parseTime=true&timeout=5s", port)
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return
	}
	defer db.Close()
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	//nolint:gosec // G201: dbName is generated by test (doctest_ + random hex)
	_, _ = db.ExecContext(ctx, fmt.Sprintf("DROP DATABASE IF EXISTS `%s`", dbName))
}

// newTestIssue creates a minimal test issue with the given ID.
func newTestIssue(id string) *types.Issue {
	return &types.Issue{
		ID:        id,
		Title:     "Test issue " + id,
		Status:    types.StatusOpen,
		Priority:  2,
		IssueType: types.TypeTask,
		CreatedAt: time.Now(),
	}
}

// insertIssueDirectly inserts an issue with a pre-set ID into the dolt store.
// This simulates cross-rig contamination where foreign-prefix issues end up in the store.
func insertIssueDirectly(t *testing.T, store *dolt.DoltStore, id string) {
	t.Helper()
	ctx := context.Background()
	issue := newTestIssue(id)
	if err := store.CreateIssue(ctx, issue, "test"); err != nil {
		t.Fatalf("failed to insert issue %s: %v", id, err)
	}
}

// ptrTime returns a pointer to a time.Time value.
func ptrTime(t time.Time) *time.Time {
	return &t
}
