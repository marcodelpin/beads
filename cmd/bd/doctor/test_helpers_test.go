//go:build cgo

package doctor

import (
	"context"
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"testing"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/steveyegge/beads/internal/storage/dolt"
	"github.com/steveyegge/beads/internal/testutil"
	"github.com/steveyegge/beads/internal/types"
)

// doctorTestServerPort returns the Dolt server port for doctor tests.
// Returns 0 when BEADS_DOLT_PORT is unset so callers fail safely
// instead of accidentally connecting to a production server on 3307.
func doctorTestServerPort() int {
	if p := os.Getenv("BEADS_DOLT_PORT"); p != "" {
		if port, _ := strconv.Atoi(p); port > 0 {
			return port
		}
	}
	return 0
}

// newTestDoltStore creates a DoltStore for testing in the doctor package.
// Each test gets an isolated branch on the shared database for fast isolation.
func newTestDoltStore(t *testing.T, prefix string) *dolt.DoltStore {
	t.Helper()
	ctx := context.Background()

	if testServer.IsCrashed() {
		t.Skipf("Dolt test server crashed: %v", testServer.CrashError())
	}

	port := doctorTestServerPort()
	if port == 0 {
		t.Skip("Dolt test server not available, skipping")
	}

	// Open store with MaxOpenConns=1 (required for DOLT_CHECKOUT session affinity)
	store, err := dolt.New(ctx, &dolt.Config{
		Path:         filepath.Join(t.TempDir(), "test.db"),
		ServerHost:   "127.0.0.1",
		ServerPort:   port,
		Database:     testSharedDB,
		MaxOpenConns: 1,
	})
	if err != nil {
		t.Skipf("skipping: Dolt not available: %v", err)
	}

	// Create isolated branch for this test on the store's own connection
	_, branchCleanup := testutil.StartTestBranch(t, store.DB(), testSharedDB)

	// Create ignored tables on this branch
	if err := dolt.CreateIgnoredTables(store.DB()); err != nil {
		branchCleanup()
		store.Close()
		t.Fatalf("CreateIgnoredTables: %v", err)
	}

	// Set prefix for this test (overrides the shared schema's default)
	if err := store.SetConfig(ctx, "issue_prefix", prefix); err != nil {
		branchCleanup()
		store.Close()
		t.Fatalf("Failed to set issue_prefix: %v", err)
	}

	t.Cleanup(func() {
		branchCleanup()
		store.Close()
	})
	return store
}

// dropDoctorTestDatabase drops a test database (best-effort cleanup).
func dropDoctorTestDatabase(dbName string, port int) {
	dsn := fmt.Sprintf("root@tcp(127.0.0.1:%d)/?parseTime=true&timeout=5s", port)
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return
	}
	defer db.Close()
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	//nolint:gosec // G201: dbName is generated by test (doctest_ + random hex)
	_, _ = db.ExecContext(ctx, fmt.Sprintf("DROP DATABASE IF EXISTS `%s`", dbName))
}

// newTestIssue creates a minimal test issue with the given ID.
func newTestIssue(id string) *types.Issue {
	return &types.Issue{
		ID:        id,
		Title:     "Test issue " + id,
		Status:    types.StatusOpen,
		Priority:  2,
		IssueType: types.TypeTask,
		CreatedAt: time.Now(),
	}
}

// insertIssueDirectly inserts an issue with a pre-set ID into the dolt store.
// This simulates cross-rig contamination where foreign-prefix issues end up in the store.
func insertIssueDirectly(t *testing.T, store *dolt.DoltStore, id string) {
	t.Helper()
	ctx := context.Background()
	issue := newTestIssue(id)
	if err := store.CreateIssue(ctx, issue, "test"); err != nil {
		t.Fatalf("failed to insert issue %s: %v", id, err)
	}
}

// ptrTime returns a pointer to a time.Time value.
func ptrTime(t time.Time) *time.Time {
	return &t
}
