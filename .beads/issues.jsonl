{"id": "bd-kwro", "title": "Beads Messaging & Knowledge Graph (v0.30.2)", "description": "Add messaging semantics and extended graph links to Beads, enabling it to serve as\nthe universal substrate for knowledge work - issues, messages, documents, and threads\nas nodes in a queryable graph.\n\n## Motivation\n\nGas Town (GGT) needs inter-agent communication. Rather than a separate mail system,\ncollapse messaging into Beads - one system, one sync, one query interface, all in git.\n\nThis also positions Beads as a foundation for:\n- Company-wide issue tracking (like Notion)\n- Threaded conversations (like Reddit/Slack)\n- Knowledge graphs with loose associations\n- Arbitrary workflow UIs built on top\n\n## New Issue Type\n\n**message** - ephemeral communication between workers\n- sender: who sent it\n- assignee: recipient\n- priority: P0 (urgent) to P4 (routine)\n- status: open (unread) -> closed (read)\n- ephemeral: true = can be bulk-deleted after swarm\n\n## New Graph Links\n\n**replies_to** - conversation threading\n- Messages reply to messages\n- Enables Reddit-style nested threads\n- Different from parent_id (not hierarchy, its conversation flow)\n\n**relates_to** - loose see also associations\n- Bidirectional knowledge graph edges\n- Not blocking, not hierarchical, just related\n- Enables discovery and traversal\n\n**duplicates** - deduplication at scale\n- Mark issue B as duplicate of canonical issue A\n- Close B, link to A\n- Essential for large issue databases\n\n**supersedes** - version chains\n- Design Doc v2 supersedes Design Doc v1\n- Track evolution of artifacts\n\n## New Fields (optional, any issue type)\n\n- sender (string) - who created this (for messages)\n- ephemeral (boolean) - can be bulk-deleted when closed\n\n## New Commands\n\nMessaging:\n- bd mail send <recipient> -s Subject -m Body\n- bd mail inbox (list open messages for me)\n- bd mail read <id> (show message content)\n- bd mail ack <id> (mark as read/close)\n- bd mail reply <id> -m Response (reply to thread)\n\nGraph links:\n- bd relate <id1> <id2> (create relates_to link)\n- bd duplicate <id> --of <canonical> (mark as duplicate)\n- bd supersede <id> --with <new> (mark superseded)\n\nCleanup:\n- bd cleanup --ephemeral (delete closed ephemeral issues)\n\n## Identity Configuration\n\nWorkers need identity for sender field:\n- BEADS_IDENTITY env var\n- Or .beads/config.json: identity field\n\n## Hooks (for GGT integration)\n\nBeads as platform - extensible without knowing about GGT.\nHook files in .beads/hooks/:\n- on_create (runs after bd create)\n- on_update (runs after bd update)\n- on_close (runs after bd close)\n- on_message (runs after bd mail send)\n\nGGT registers hooks to notify daemons of new messages.\n\n## Schema Changes (Migration Required)\n\nAdd to issue schema:\n- type: message (new valid type)\n- sender: string (optional)\n- ephemeral: boolean (optional)\n- replies_to: string (issue ID, optional)\n- relates_to: []string (issue IDs, optional)\n- duplicates: string (canonical issue ID, optional)\n- superseded_by: string (new issue ID, optional)\n\nMigration adds fields as optional - existing beads unchanged.\n\n## Success Criteria\n\n1. bd mail send/inbox/read/ack/reply work end-to-end\n2. replies_to creates proper thread structure\n3. relates_to, duplicates, supersedes links queryable\n4. Hooks fire on create/update/close/message\n5. Identity configurable via env or config\n6. Migration preserves all existing data\n7. All new features have tests", "status": "closed", "priority": 0, "issue_type": "epic", "created_at": "2025-12-16T11:00:54Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-dgp", "title": "Speed up cmd/bd/protocol tests (81s)", "description": "attached_molecule: bd-wisp-jtdkj\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T03:43:05Z\ndispatched_by: mayor\n\ncmd/bd/protocol takes 81s. Likely protocol integration tests hitting Dolt. Check for: per-test server startup, serial execution, tests that could share fixtures. Target: under 30s.", "notes": "Added t.Parallel() to all 45 protocol tests. Baseline: 135s serial ‚Üí 42-58s parallel (3x speedup). Tests are already fully isolated (unique Dolt prefix, temp dir, git repo per test) so parallelization is safe.", "status": "closed", "priority": 1, "issue_type": "task", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:42:10Z", "created_by": "mayor", "updated_at": "2026-02-28T03:54:42Z", "closed_at": "2026-02-28T03:54:42Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-dgp", "depends_on_id": "bd-wisp-jtdkj", "type": "blocks", "created_at": "2026-02-27T19:43:04Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-xmf", "title": "Speed up cmd/bd tests (180s ‚Äî dominates test suite)", "description": "attached_molecule: bd-wisp-uq6fx\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T03:42:48Z\ndispatched_by: mayor\n\ncmd/bd takes 180 seconds, the slowest package in beads. Likely end-to-end CLI tests that spawn Dolt servers, create databases, and run full bd commands. Investigate: can tests share a single Dolt server? Can they use t.Parallel()? Can heavy integration tests be split to a build tag? Target: under 60s.", "status": "hooked", "priority": 1, "issue_type": "task", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:42:10Z", "created_by": "mayor", "updated_at": "2026-02-28T03:42:49Z", "dependencies": [{"issue_id": "bd-xmf", "depends_on_id": "bd-wisp-uq6fx", "type": "blocks", "created_at": "2026-02-27T19:42:48Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-1x0", "title": "SQL views hardcode status lists - custom statuses invisible to GetReadyWork", "description": "schema.go ready_issues and blocked_issues views hardcode status IN (open, in_progress, blocked, deferred, hooked). Custom statuses configured via status.custom config key are validated but NOT included in these views. An issue with custom status 'review' would be permanently invisible to GetReadyWork and bd ready. Same pattern in dependencies.go:779, :834, :877 (IsBlocked, GetNewlyUnblockedByClose). ZFC violation: storage layer decides which statuses are 'active' without consulting config.", "notes": "Fixed all 8 hardcoded status IN clauses across schema.go (4), dependencies.go (3), queries.go (2). Changed from IN ('open','in_progress','blocked','deferred','hooked') to NOT IN ('closed','pinned'). Added 4 regression tests for custom status visibility in IsBlocked, GetNewlyUnblockedByClose, GetReadyWork, GetBlockedIssues. All tests pass.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:48:39Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T03:21:18Z", "closed_at": "2026-02-28T03:20:10Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-1x0", "depends_on_id": "bd-wisp-nyoi9", "type": "blocks", "created_at": "2026-02-27T19:19:27Z", "created_by": "dog", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-e5e", "title": "Pre-existing test failure: TestShimExtract_FullMigration in cmd/bd", "description": "TestShimExtract_FullMigration fails on main. The test expects beads.db to be renamed to .migrated during shim extraction, but migration doesn't complete. Backend stays sqlite instead of switching to dolt. File: cmd/bd/migrate_shim_test.go", "notes": "Root cause: Test config set Backend:\"sqlite\" which triggered the GH#2016 guard in doShimMigrate (line 66-69) that skips migration when backend is explicitly sqlite. Fix: Remove Backend field from test config ‚Äî empty backend represents a legacy pre-Dolt config that needs migration.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:52:12Z", "created_by": "beads/refinery", "updated_at": "2026-02-28T02:18:58Z", "closed_at": "2026-02-28T02:17:31Z", "close_reason": "Fix merged to main as 852bfe65. TestShimExtract_FullMigration now passes.", "dependencies": [{"issue_id": "bd-e5e", "depends_on_id": "bd-wisp-qtxi9", "type": "blocks", "created_at": "2026-02-27T18:10:41Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-7vk", "title": "bd close from town root doesn't route to correct rig database", "description": "Running 'bd close bd-1' from /Users/stevey/gt (town root) reports success but doesn't actually close the issue in the beads rig database. Must run from beads/mayor/rig/ to work. Prefix routing for bd close appears broken at town level ‚Äî likely closes a phantom copy in HQ db or silently succeeds without finding the issue. Discovered during test pollution cleanup session.", "notes": "Implemented: skip local-first check in resolveAndGetIssueWithRouting and getIssueWithRouting when prefix routing indicates a different database. Added regression test TestRoutingSkipsLocalPhantomCopy.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:30:16Z", "created_by": "mayor", "updated_at": "2026-02-28T01:14:00Z", "closed_at": "2026-02-28T01:09:12Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-7vk", "depends_on_id": "bd-wisp-k453", "type": "blocks", "created_at": "2026-02-27T17:04:26Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-19i", "title": "id_parser_test.go creates real issues in shared database without isolation", "description": "Tests in internal/utils/id_parser_test.go create issues with prefixes offlinebrew-, aap-, cr-, hq-abc12, and a wisp bd-wisp-t3st in shared test stores. These leak to production when the shared store connects to port 3307. Root cause of recurring test pollution. Fix: use isolated temporary databases per test, or at minimum clean up created issues in test teardown.", "notes": "Fixed: Added TestMain to internal/utils/ that starts an isolated test Dolt server on a dynamic port. Updated newTestStore to use testServerPort and unique testdb_ database names. Tests no longer connect to production port 3307. Registered utils-pkg-test-* in orphaned temp dir cleanup.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/jasper", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:21:25Z", "created_by": "mayor", "updated_at": "2026-02-28T00:41:17Z", "closed_at": "2026-02-28T00:33:16Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-19i", "depends_on_id": "bd-wisp-86yb", "type": "blocks", "created_at": "2026-02-27T16:25:30Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-6ie", "title": "Pre-existing test failure: TestChildParentDependencies_PreservesParentChildType in doctor/fix", "status": "closed", "priority": 1, "issue_type": "bug", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:15:30Z", "created_by": "beads/refinery", "updated_at": "2026-02-28T00:16:33Z", "closed_at": "2026-02-28T00:16:33Z", "close_reason": "Duplicate of bd-7z5", "dependency_count": 0, "dependent_count": 0, "comment_count": 1}
{"id": "bd-fu1", "title": "Pre-existing test failures: TestInitRedirect, TestInitBEADS_DIR in cmd/bd", "status": "closed", "priority": 1, "issue_type": "bug", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:15:29Z", "created_by": "beads/refinery", "updated_at": "2026-02-28T00:16:33Z", "closed_at": "2026-02-28T00:16:33Z", "close_reason": "Duplicate of bd-qy0", "dependency_count": 0, "dependent_count": 0, "comment_count": 1}
{"id": "bd-1", "title": "Test Issue", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2026-02-27T22:59:07Z", "updated_at": "2026-02-28T03:52:45Z", "closed_at": "2026-02-28T03:52:45Z", "close_reason": "test pollution", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-10", "title": "Test Issue 3", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2026-02-27T22:59:07Z", "updated_at": "2026-02-28T03:52:45Z", "closed_at": "2026-02-28T03:52:45Z", "close_reason": "test pollution", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-2", "title": "Test Issue 2", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2026-02-27T22:59:07Z", "updated_at": "2026-02-28T03:52:45Z", "closed_at": "2026-02-28T03:52:45Z", "close_reason": "test pollution", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "offlinebrew-3d0", "title": "Parent Epic", "status": "open", "priority": 1, "issue_type": "epic", "created_at": "2026-02-27T22:59:07Z", "updated_at": "2026-02-28T03:39:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "offlinebrew-3d0.1", "title": "Child Task", "status": "open", "priority": 1, "issue_type": "task", "created_at": "2026-02-27T22:59:07Z", "updated_at": "2026-02-28T03:39:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-o23", "title": "SQL audit: rewrite GetNewlyUnblockedByClose nested JOIN subquery", "description": "GetNewlyUnblockedByClose (dependencies.go:809) has nested subquery with 2-table JOIN + correlated NOT EXISTS. Most dangerous remaining query pattern that could crash/hang Dolt. Rewrite to avoid nested JOIN. Also review cycle detection CTE (dependencies.go:52). See hq-g4nxe for full audit.", "notes": "Analysis complete:\n\n1. GetNewlyUnblockedByClose (line 822): REWRITTEN. Decomposed nested JOIN + correlated NOT EXISTS into two sequential queries:\n   - Query 1: Find candidate issues blocked by the closed issue (simple JOIN)\n   - Query 2: Check which candidates still have other open blockers (simple JOIN with IN clause)\n   - Go-side filtering removes still-blocked candidates\n   Both existing tests pass.\n\n2. Cycle detection CTE (line 52): REVIEWED, safe. Simple recursive CTE with:\n   - Depth limit of 100 (prevents runaway recursion)\n   - Single table JOIN per recursion (dependencies only)\n   - No nested JOINs or correlated subqueries\n   - Runs within a transaction\n   This is a standard graph-reachability pattern that Dolt handles well.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T22:49:35Z", "created_by": "mayor", "updated_at": "2026-02-27T23:01:21Z", "closed_at": "2026-02-27T23:01:21Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-o23", "depends_on_id": "bd-wisp-5fal0k", "type": "blocks", "created_at": "2026-02-27T14:49:59Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-tx9", "title": "Fix test server zombie leak: port allocation race in testdoltserver.go", "description": "45 zombie dolt sql-server processes found on random high ports (13000-14300). Root cause: race condition in beads/mayor/rig/internal/testutil/testdoltserver.go lines 120-157.\n\nFindFreePort() binds to :0, gets OS port, closes listener. Between close and dolt binding, concurrent test grabs that port. serverCmd.Start() succeeds but dolt fails to bind. WaitForServer() hangs 30s, then cleanup kills one process -- but with 4-5 parallel packages x 3 retries x 30s timeouts = 45 zombies in 3 minutes.\n\nCleanup failures: PID file written after Start() (references dead process on race), CleanStaleTestServers() only runs on next invocation, SIGKILL skips defers entirely.\n\nFix: port gastown's lock-based approach from internal/testutil/doltserver_unix.go -- sync.Once + syscall.Flock() for cross-process port coordination. Same pattern exists in multiple crew variants (collins, darcy, emma, etc.) which all have copies of testdoltserver.go.\n\nReference: gastown/mayor/rig/internal/testutil/doltserver_unix.go for the working pattern.", "notes": "Implemented: Ported gastown flock-based approach to beads testdoltserver.go. Split into 3 files: common (testdoltserver.go), unix (testdoltserver_unix.go with syscall.Flock), windows fallback (testdoltserver_windows.go). Uses sync.Once for in-process singleton + LOCK_EX/LOCK_SH for cross-process coordination. Added reapStaleDoltServers to catch zombies from SIGKILL'd processes. API surface unchanged - all callers work without modification. All test packages pass.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T20:37:04Z", "created_by": "mayor", "updated_at": "2026-02-27T21:11:40Z", "closed_at": "2026-02-27T21:11:40Z", "close_reason": "Shipped ac78ec96: flock-based test server coordination, 3-file split (common/unix/windows)", "dependencies": [{"issue_id": "bd-tx9", "depends_on_id": "bd-wisp-lwmy93", "type": "blocks", "created_at": "2026-02-27T12:37:12Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-on8", "title": "Code review: SQLite-to-Dolt migration safety (49aed46c)", "description": "Review commit 49aed46c in beads repo. Check: migration safety guards, old-schema compatibility, doctor recovery logic, error handling.", "design": "## Code Review: SQLite-to-Dolt Migration Safety (49aed46c)\n\n### Summary\nWell-structured, safety-first migration PR. 18 files, ~3200 lines added, 117+ tests. The four review areas are analyzed below.\n\n---\n\n### 1. Migration Safety Guards ‚Äî GOOD with one weakness\n\n**backupSQLite**: Solid. O_EXCL prevents TOCTOU races, 0600 permissions, counter-based collision handling up to 100 retries.\n\n**verifyServerTarget**: WEAK CHECK. Despite the name, it cannot actually prevent writing to the wrong project's Dolt server. It only catches: (a) non-MySQL services on the port, (b) unreachable servers with non-ECONNREFUSED errors. If another project's Dolt server is on the same port, this check passes ‚Äî database doesn't exist yet = 'safe'. The function always returns nil for the normal first-migration case. Recommend: at minimum, add a comment acknowledging this limitation. Better: check for unexpected databases that indicate a different project's server.\n\n**verifyMigrationCounts**: Correct. Uses >= semantics for idempotent re-runs.\n\n**finalizeMigration**: Good overall. Comment says 'atomic metadata update' but it's not truly atomic ‚Äî crash between cfg.Save() and os.Rename() leaves metadata pointing to dolt while beads.db still exists. MITIGATED: doctor CheckBrokenMigrationState detects and fixes this exact scenario. Recommend: update comment to say 'near-atomic' and reference the doctor fix.\n\n**rollbackMetadata**: Simple and correct.\n\n---\n\n### 2. Old-Schema Compatibility ‚Äî GOOD\n\nBoth CGO (migrate_dolt.go) and shim (migrate_shim.go) extract paths updated consistently with identical column lists using the DRY opt() helper.\n\nGood: created_by and owner changed from direct scan to sql.NullString scan for old schemas where these columns may not exist.\n\nMinor issue: migrate_dolt.go comment says 'Core columns (id, title, status, priority, created_at, updated_at) are assumed present in all versions' but then uses opt('title', '\"\"') ‚Äî making title optional contradicts the comment. Comment should be corrected or removed.\n\nTested against 12 real-world databases spanning multiple schema versions ‚Äî strong validation.\n\n---\n\n### 3. Doctor Recovery Logic ‚Äî GOOD\n\n**CheckBrokenMigrationState**: Properly aware of server mode (no false positive when dolt/ dir absent). Checks both beads.db and beads.db.migrated as recovery sources. Distinguishes recoverable vs unrecoverable states.\n\n**CheckSQLiteResidue**: Guards against renaming active SQLite database (checks backend first). Handles zero-byte files correctly.\n\n**CheckEmbeddedModeConcurrency**: Checks dolt-access.lock and noms LOCK files. Appropriately uses warnings not errors.\n\n**fix/BrokenMigrationState**: Re-verifies conditions before applying (defense in depth). Handles .migrated file recovery. Sets database='beads.db' correctly for SQLite backend.\n\n**fix/SQLiteResidue**: Guards against overwriting existing .migrated file. Backend guard prevents accidental rename on SQLite backend.\n\n---\n\n### 4. Error Handling ‚Äî GOOD\n\nEvery failure point in migrate_auto.go and migrate_shim.go includes the backup path in error messages ‚Äî users always know where their data is.\n\nRollback on verification failure properly removes dolt dir + restores metadata. Import failure cleanup removes the dolt directory that was just created.\n\nmain.go SQLite backend guard provides clear error message with migration instructions and BEADS_BACKEND override as escape hatch.\n\nconfigfile.go GetBackend priority chain (env > config > default) is correct with case-insensitive normalization and unrecognized-value warnings.\n\nMinor: migrate_auto.go has redundant doltPath assignment (computed twice to same value). Harmless.\n\nMinor: shim path uses cfg.GetDoltServerPort() directly while auto path uses doltserver.DefaultConfig(). These could diverge if GetDoltServerPort() returns 0, but verifyServerTarget handles port==0 by returning nil, so safe.\n\n---\n\n### Issues Found (non-blocking)\n\n1. **verifyServerTarget is weak** ‚Äî cannot detect wrong-project Dolt servers (design limitation, mitigated by manual inspection)\n2. **Comment/code mismatch** in migrate_dolt.go re 'core columns assumed present' vs all columns using opt()\n3. **Redundant doltPath assignment** in migrate_auto.go (harmless)\n4. **'Atomic' finalization isn't truly atomic** ‚Äî mitigated by doctor fix\n\n### Verdict: APPROVE with minor suggestions\nNo blocking issues. The safety model (backup-first, verify-then-finalize, doctor-recoverable) is sound. Test coverage is comprehensive at 117+ tests across unit and integration.", "notes": "Code review complete. Reviewed all 18 files in commit 49aed46c. Verdict: APPROVE with minor suggestions. Four non-blocking issues found (verifyServerTarget weakness, comment/code mismatch, redundant assignment, non-atomic finalization). The safety model is sound: backup-first, verify-then-finalize, doctor-recoverable. 117+ tests provide comprehensive coverage.", "status": "closed", "priority": 1, "issue_type": "task", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T05:48:35Z", "created_by": "mayor", "updated_at": "2026-02-27T05:52:09Z", "closed_at": "2026-02-27T05:51:17Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-on8", "depends_on_id": "bd-wisp-f4xh8n", "type": "blocks", "created_at": "2026-02-26T21:49:03Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-a3j", "title": "Code review: --root-only flag in bd mol wisp create (725f6bbb)", "description": "Review commit 725f6bbb in beads repo. Check: flag plumbing correctness, wisp creation with root_only=true, no children created, backward compatibility.", "design": "## Code Review: --root-only flag in bd mol wisp create (725f6bbb)\n\n**Verdict: LGTM ‚Äî clean commit, no blocking issues.**\n\n### 1. Flag Plumbing Correctness ‚úÖ\n\n- `--root-only` registered on both `wispCmd` and `wispCreateCmd` (backward compat for both CLI paths)\n- Read via `cmd.Flags().GetBool(\"root-only\")` at wisp.go\n- Passed through `CloneOptions{RootOnly: rootOnly}` ‚Üí `spawnMoleculeWithOptions` ‚Üí `cloneSubgraph`\n- Full pipeline verified end-to-end\n\n### 2. Wisp Creation with root_only=true ‚úÖ\n\n- `cloneSubgraph` narrows `issuesToCreate = []*types.Issue{subgraph.Root}` when RootOnly is set\n- Root issue goes through the identical creation path (assignee override, variable substitution, ephemeral marking, bonded ID generation)\n- `idMapping` correctly contains exactly one entry (root only)\n\n### 3. No Children Created ‚úÖ\n\n- Children are excluded from `issuesToCreate` (only root is in the slice)\n- Dependencies are skipped via `if opts.RootOnly { break }` in the second pass\n- AttachToID still works (uses `idMapping[subgraph.Root.ID]` which is always populated)\n- Dynamic bonding (`ParentID`) also works ‚Äî root gets bonded ID as expected\n\n### 4. Backward Compatibility ‚úÖ\n\n- `spawnMolecule()` function is preserved ‚Äî all existing callers (pour.go:216, 9 test call sites in mol_test.go) are unaffected\n- Default `RootOnly` is `false` (Go zero value), so existing `CloneOptions{}` usage safe\n- Dry-run path properly branches: root-only shows single-line summary with inlined step count; non-root-only path is unchanged\n\n### 5. `Created` Field Fix ‚úÖ\n\n- Changed from `len(subgraph.Issues)` to `len(idMapping)` ‚Äî more accurate in ALL cases\n- For non-root-only: `len(idMapping)` == `len(subgraph.Issues)` in all success paths (errors cause tx rollback)\n- For root-only: correctly returns 1 instead of the full template count\n- This is a semantic improvement, not just a root-only fix\n\n### Minor Nit (Non-Blocking)\n\nThe dependency loop guard:\n```go\nfor _, dep := range subgraph.Dependencies {\n    if opts.RootOnly { break }\n    ...\n}\n```\nWould be slightly cleaner as:\n```go\nif !opts.RootOnly {\n    for _, dep := range subgraph.Dependencies { ... }\n}\n```\nFunctionally identical ‚Äî the `break` fires on first iteration and exits. But wrapping the loop is more idiomatic Go. Not worth a re-spin.\n\n### Summary\n\nTwo files changed (+39/-9), well-scoped. The ~15x Dolt write reduction claim is plausible (typical patrol formula has 10+ steps). All edge cases (bonding, attachment, dry-run, backward compat) are covered.", "status": "closed", "priority": 1, "issue_type": "task", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T05:48:34Z", "created_by": "mayor", "updated_at": "2026-02-27T05:52:24Z", "closed_at": "2026-02-27T05:51:49Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-a3j", "depends_on_id": "bd-wisp-bvc4xp", "type": "blocks", "created_at": "2026-02-26T21:48:54Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-t3r", "title": "ü§ù HANDOFF: Witness patrol", "description": "Completed 4 patrols, all idle. No polecats, no swarms, no cleanup wisps. Refinery alive. Deacon alive. Inbox clean. NOTE: gt commands being SIGKILL'd (53 Claude procs, ~446MB free RAM on 48GB). System memory-constrained. bd commands work fine.", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T05:10:51Z", "created_by": "beads/witness", "updated_at": "2026-02-27T05:34:17Z", "closed_at": "2026-02-27T05:34:17Z", "close_reason": "Old handoff, superseded by current patrol", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-pr-sheriff", "title": "PR Sheriff (reference to hq-pr-sheriff)", "description": "PR Sheriff standing orders for beads repo (emma). See hq-pr-sheriff for original (lost in DB rebuild). Full workflow doc: gt/docs/pr-sheriff.md\n\nDecision tree: gather open PRs (filter out changes-requested), close drafts, then classify each PR into buckets:\nA) Easy-win ‚Üí merge directly\nB) Merge-fix ‚Üí merge then push follow-up fix\nC) Fix-merge ‚Üí fix locally first, then merge with attribution\nD) Cherry-pick-merge ‚Üí extract valuable fixes from messy PRs, close original\nE) Split-merge ‚Üí separate multi-concern PRs into individual commits\nF) Needs attention ‚Üí farm to crew for deep evaluation + recommendation\nG) Superseded ‚Üí close with explanation\n\nExecute A-E via crew in waves. Farm F to crew for written recommendations. Present F recommendations to overseer as final step.", "status": "pinned", "priority": 1, "issue_type": "task", "assignee": "beads/crew/emma", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T00:02:09Z", "created_by": "beads/crew/emma", "updated_at": "2026-02-27T07:11:36Z", "pinned": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-05an", "title": "P1: Circuit breaker for Dolt server connections", "description": "When Dolt is down, every agent independently retries for 30 seconds before failing. With N agents, that's N√ó30s of wasted time and connection storms. Implement a circuit breaker: after K consecutive failures within T seconds, trip the breaker and fail-fast for a cooldown period. Options: (1) file-based shared state in /tmp, (2) in-process with cenkalti/backoff already in deps, (3) lightweight lockfile protocol. The breaker should log clearly when tripped/reset so agents know why bd commands are failing fast.", "notes": "Implemented file-based circuit breaker for Dolt connections. State shared at /tmp/beads-dolt-circuit-<port>.json. Trips after 5 consecutive connection failures in 60s, 30s cooldown before half-open probe. Integrated into withRetry() and newServerMode(). Added isConnectionError() to distinguish server-down errors from query errors. OTel metrics: circuit_trips, circuit_rejected. 12 new unit tests, all passing.", "status": "closed", "priority": 1, "issue_type": "feature", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-26T01:48:05Z", "created_by": "mayor", "updated_at": "2026-02-27T23:31:00Z", "closed_at": "2026-02-27T23:31:00Z", "close_reason": "Merged to main (commit 0cb7936f). Circuit breaker implemented by obsidian, MR bd-wisp-hcao82 merged by refinery.", "dependencies": [{"issue_id": "bd-05an", "depends_on_id": "bd-wisp-71e0f0", "type": "blocks", "created_at": "2026-02-27T15:17:22Z", "created_by": "dog", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-xm5l", "title": "TestInitDatabaseFlag fails: --database flag does not exist on bd init", "description": "TestInitDatabaseFlag in cmd/bd/init_test.go references a --database flag that does not exist on bd init. All 6 subtests fail with 'unknown flag: --database'. Confirmed pre-existing on main (not introduced by any polecat branch). The test appears to have been written for a flag that was either never added or was removed.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-26T01:04:48Z", "created_by": "beads/refinery", "updated_at": "2026-02-26T23:17:13Z", "closed_at": "2026-02-26T23:15:24Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-xm5l", "depends_on_id": "bd-wisp-xst47", "type": "blocks", "created_at": "2026-02-26T15:13:31Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "aap-4ar", "title": "AAP Issue from different rig", "status": "open", "priority": 1, "issue_type": "task", "created_at": "2026-02-26T00:08:56Z", "updated_at": "2026-02-28T03:39:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-abc12", "title": "Real issue", "status": "open", "priority": 1, "issue_type": "task", "created_at": "2026-02-26T00:08:56Z", "updated_at": "2026-02-28T03:39:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-xyz99", "title": "See abc12 for reference", "status": "open", "priority": 1, "issue_type": "task", "created_at": "2026-02-26T00:08:56Z", "updated_at": "2026-02-28T03:39:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "cr-xyz99", "title": "CR Issue from another rig", "status": "open", "priority": 1, "issue_type": "task", "created_at": "2026-02-26T00:08:56Z", "updated_at": "2026-02-28T03:39:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "hq-abc12", "title": "HQ Issue", "status": "open", "priority": 1, "issue_type": "task", "created_at": "2026-02-26T00:08:56Z", "updated_at": "2026-02-28T03:39:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-b3og", "title": "Fix TestImportBugIntegration deadlock in importer_test.go", "description": "Code health review found internal/importer/importer_test.go has TestImportBugIntegration skipped with:\n\nTODO: Test hangs due to database deadlock - needs investigation\n\nThis indicates a potential unresolved concurrency issue in the importer. The test has been skipped for an unknown duration.\n\nFix: Investigate the deadlock, fix the underlying issue, and re-enable the test.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/obsidian", "created_at": "2025-12-17T02:17:22Z", "updated_at": "2026-02-27T21:51:54Z", "closed_at": "2026-02-27T21:29:17Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-b3og", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-b3og", "depends_on_id": "bd-wisp-p27dfw", "type": "blocks", "created_at": "2026-02-27T13:27:18Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 2, "dependent_count": 0, "comment_count": 0}
{"id": "bd-b6xo", "title": "Remove or fix ClearDirtyIssues() - race condition risk (bd-52)", "description": "Code health review found internal/storage/sqlite/dirty.go still exposes old ClearDirtyIssues() method (lines 103-108) which clears ALL dirty issues without checking what was actually exported.\n\nData loss risk: If export fails after some issues written to JSONL but before ClearDirtyIssues called, changes to remaining dirty issues will be lost.\n\nThe safer ClearDirtyIssuesByID() (lines 113-132) exists and clears only exported issues.\n\nFix: Either remove old method or mark it deprecated and ensure no code paths use it.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/jasper", "created_at": "2025-12-17T02:17:21Z", "updated_at": "2026-02-27T21:51:45Z", "closed_at": "2026-02-27T21:28:41Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-b6xo", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-b6xo", "depends_on_id": "bd-wisp-yhvzh9", "type": "blocks", "created_at": "2026-02-27T13:27:40Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 2, "dependent_count": 0, "comment_count": 0}
{"id": "bd-74w1", "title": "Consolidate duplicate path-finding utilities (findJSONLPath, findBeadsDir, findGitRoot)", "description": "Code health review found these functions defined in multiple places:\n\n- findJSONLPath() in autoflush.go:45-73 and doctor/fix/migrate.go\n- findBeadsDir() in autoimport.go:197-239 (with git worktree handling)\n- findGitRoot() in autoimport.go:242-269 (Windows path conversion)\n\nThe beads package has public FindBeadsDir() and FindJSONLPath() APIs that should be used consistently.\n\nImpact: Bug fixes need to be applied in multiple places. Git worktree handling may not be replicated everywhere.\n\nFix: Consolidate all implementations to use the beads package APIs. Remove duplicates.", "notes": "Consolidated duplicate findBeadsDir() in cmd/bd/setup.go (also used by backup_export.go) to use the canonical beads.FindBeadsDir() from internal/beads. The other duplicates mentioned in the bead (findJSONLPath in autoflush.go, findBeadsDir/findGitRoot in autoimport.go) were already cleaned up in prior work ‚Äî those files no longer exist. Only findGitRoot remains in internal/beads/beads.go as a thin wrapper around git.GetRepoRoot(), but it's not a duplicate (it's the canonical implementation).", "status": "closed", "priority": 1, "issue_type": "task", "assignee": "beads/polecats/obsidian", "created_at": "2025-12-17T02:17:17Z", "updated_at": "2026-02-28T00:10:49Z", "closed_at": "2026-02-28T00:10:49Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-74w1", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-74w1", "depends_on_id": "bd-wisp-ulr1", "type": "blocks", "created_at": "2026-02-27T15:54:00Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 2, "dependent_count": 0, "comment_count": 0}
{"id": "bd-tm2p", "title": "Polecats get stuck on interactive shell prompts (cp/mv/rm -i)", "description": "During swarm operations, polecats frequently get stuck waiting for interactive prompts from shell commands like:\n- cp prompting 'overwrite file? (y/n)'\n- mv prompting 'overwrite file? (y/n)'  \n- rm prompting 'remove file?'\n\nThis happens because macOS aliases or shell configs may have -i flags set by default.\n\nRoot cause: Claude Code runs commands that trigger interactive confirmation prompts, but cannot respond to them, causing the agent to hang indefinitely.\n\nObserved in: Multiple polecats during GH issues swarm (Dec 2024)\n- Derrick, Roustabout, Prospector, Warboy all got stuck on y/n prompts\n\nSuggested fixes:\n1. AGENTS.md should instruct agents to always use -f flag with cp/mv/rm\n2. Polecat startup could set shell aliases to use non-interactive versions\n3. bd prime hook could include guidance about non-interactive commands\n4. Consider detecting stuck prompts and auto-recovering", "notes": "Implemented: PreToolUse hook (.claude/hooks/block-interactive-cmds.sh) that blocks cp/mv/rm without -f flag, preventing interactive prompt hangs from macOS -i aliases. Also registered hook in settings.json and added non-interactive guidance to default agents.md template.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/jasper", "created_at": "2025-12-15T00:51:25Z", "updated_at": "2026-02-28T00:23:38Z", "closed_at": "2026-02-28T00:23:03Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-tm2p", "depends_on_id": "bd-wisp-l6tw", "type": "blocks", "created_at": "2026-02-27T16:15:33Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-tbz3", "title": "bd init UX Improvements", "description": "bd init leaves users with incomplete setup, requiring manual bd doctor --fix. Issues found: (1) git hooks not installed if user declines prompt, (2) no auto-migration when CLI is upgraded, (3) stale merge driver configs from old versions. Fix by making bd init more robust with better defaults and auto-migration.", "status": "closed", "priority": 1, "issue_type": "epic", "created_at": "2025-11-22T07:16:00Z", "updated_at": "2026-02-27T05:14:43Z", "closed_at": "2026-02-27T05:14:43Z", "close_reason": "Closed", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-au0.7", "title": "Audit and standardize JSON output across all commands", "description": "Ensure consistent JSON format and error handling when --json flag is used.\n\n**Scope:**\n1. Verify all commands respect --json flag\n2. Standardize success response format\n3. Standardize error response format\n4. Document JSON schemas\n\n**Commands to audit:**\n- Core CRUD: create, update, delete, show, list, search ‚úì\n- Queries: ready, blocked, stale, count, stats, status\n- Deps: dep add/remove/tree/cycles\n- Labels: label commands\n- Comments: comments add/list/delete\n- Epics: epic status/close-eligible\n- Export/import: already support --json ‚úì\n\n**Testing:**\n- Success cases return valid JSON\n- Error cases return valid JSON (not plain text)\n- Consistent field naming (snake_case vs camelCase)\n- Array vs object wrapping consistency", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2025-11-22T02:07:35Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-au0.7", "depends_on_id": "bd-au0", "type": "parent-child", "created_at": "2025-11-22T02:07:35Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-au0"}
{"id": "bd-au0.6", "title": "Add comprehensive filters to bd export", "description": "Enhance bd export with filtering options for selective exports.\n\n**Currently only has:**\n- --status\n\n**Add filters:**\n- --label, --label-any\n- --assignee\n- --type\n- --priority, --priority-min, --priority-max\n- --created-after, --created-before\n- --updated-after, --updated-before\n\n**Use case:**\n- Export only open issues: bd export --status open\n- Export high-priority bugs: bd export --type bug --priority-max 1\n- Export recent issues: bd export --created-after 2025-01-01\n\n**Files to modify:**\n- cmd/bd/export.go\n- Reuse filter logic from list.go", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2025-11-22T02:07:19Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-au0.6", "depends_on_id": "bd-au0", "type": "parent-child", "created_at": "2025-11-22T02:07:19Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-au0"}
{"id": "bd-au0.5", "title": "Add date and priority filters to bd search", "description": "Add filter parity with bd list for consistent querying.\n\n**Missing filters to add:**\n- --priority, --priority-min, --priority-max\n- --created-after, --created-before\n- --updated-after, --updated-before\n- --closed-after, --closed-before\n- --empty-description, --no-assignee, --no-labels\n- --desc-contains, --notes-contains\n\n**Files to modify:**\n- cmd/bd/search.go\n- internal/rpc/protocol.go (SearchArgs)\n- internal/storage/storage.go (Search method)\n\n**Testing:**\n- All filter combinations\n- Date format parsing\n- Daemon and direct mode", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2025-11-22T02:07:05Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-au0.5", "depends_on_id": "bd-au0", "type": "parent-child", "created_at": "2025-11-22T02:07:05Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-au0"}
{"id": "bd-7yg", "title": "Git merge driver uses invalid placeholders (%L, %R instead of %A, %B)", "description": "## Problem\n\nThe beads git merge driver is configured with invalid Git placeholders:\n\n```\ngit config merge.beads.driver \"bd merge %A %O %L %R\"\n```\n\nGit doesn't recognize `%L` or `%R` as valid merge driver placeholders. The valid placeholders are:\n- `%O` = base (common ancestor)\n- `%A` = current version (ours)\n- `%B` = other version (theirs)\n\n## Impact\n\n- Affects ALL users when they have `.beads/beads.jsonl` merge conflicts\n- Automatic JSONL merge fails with error: \"error reading left file: failed to open file: open 7: no such file or directory\"\n- Users must manually resolve conflicts instead of getting automatic merge\n\n## Root Cause\n\nThe `bd init` command (or wherever the merge driver is configured) is using non-standard placeholders. When Git encounters `%L` and `%R`, it either passes them literally or interprets them incorrectly.\n\n## Fix\n\nUpdate the merge driver configuration to:\n```\ngit config merge.beads.driver \"bd merge %A %O %A %B\"\n```\n\nWhere:\n- 1st `%A` = output file (current file, will be overwritten)\n- `%O` = base (common ancestor)\n- 2nd `%A` = left/current version\n- `%B` = right/other version\n\n## Action Items\n\n1. Fix `bd init` (or equivalent setup command) to use correct placeholders\n2. Add migration/warning for existing users with misconfigured merge driver\n3. Update documentation with correct merge driver setup\n4. Consider adding validation when `bd init` is run", "notes": "Implemented: Added FixMergeDriver() function and wired it into bd doctor --fix. The check already correctly detected %L/%R but the fix path was missing from applyFixList switch. Also added tests.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/quartz", "created_at": "2025-11-22T00:51:56Z", "updated_at": "2026-02-27T21:57:16Z", "closed_at": "2026-02-27T21:57:16Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-7yg", "depends_on_id": "bd-wisp-tjqd4a", "type": "blocks", "created_at": "2026-02-27T13:27:28Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-1rh", "title": "cmd/bd test suite is absurdly slow - 279 tests taking 8+ minutes", "description": "# Problem\n\nThe cmd/bd test suite is painfully slow:\n- **279 tests** in cmd/bd alone\n- Full suite takes **8+ minutes** to run\n- Even with the 16 slowest integration tests now tagged with `integration` build tag, the remaining tests still take forever\n\nThis makes the development loop unusable. We can't wait 8+ minutes every time we want to run tests.\n\n# Root Cause Analysis\n\n## 1. Sheer Volume\n279 tests is too many for a single package. Even at 0.1s per test, that's 28 seconds minimum just for cmd/bd.\n\n## 2. Each Test Creates Full Database + Temp Directories\nEvery test does heavy setup:\n- Creates temp directory (`t.TempDir()` or `os.MkdirTemp`)\n- Initializes SQLite database\n- Sets up git repo in many cases\n- Creates full storage layer\n\nExample from the tests:\n```go\nfunc setupCLITestDB(t *testing.T) string {\n    tmpDir := createTempDirWithCleanup(t)\n    runBDInProcess(t, tmpDir, \"init\", \"--prefix\", \"test\", \"--quiet\")\n    return tmpDir\n}\n```\n\nThis happens 279 times!\n\n## 3. Tests Are Not Properly Categorized\nWe have three types of tests mixed together:\n- **Unit tests** - should be fast, test single functions\n- **Integration tests** - test full workflows, need DB/git\n- **End-to-end tests** - test entire CLI commands\n\nThey're all lumped together in cmd/bd, all running every time.\n\n# What We've Already Fixed\n\nAdded `integration` build tags to 16 obviously-slow test files:\n- import_profile_test.go (performance benchmarking tests)\n- export_mtime_test.go (tests with time.Sleep calls)\n- cli_fast_test.go (full CLI integration tests)\n- delete_test.go, import_uncommitted_test.go, sync_local_only_test.go (git integration)\n- And 10 more in internal/ packages\n\nThese are now excluded from the default `go test ./...` run.\n\n# Proposed Solutions\n\n## Option 1: Shared Test Fixtures (Quick Win)\nCreate a shared test database that multiple tests can use:\n```go\nvar testDB *sqlite.SQLiteStorage\nvar testDBOnce sync.Once\n\nfunc getSharedTestDB(t *testing.T) storage.Storage {\n    testDBOnce.Do(func() {\n        // Create one DB for all tests\n    })\n    return testDB\n}\n```\n\n**Pros**: Easy to implement, immediate speedup\n**Cons**: Tests become less isolated, harder to debug failures\n\n## Option 2: Table-Driven Tests (Medium Win)\nCollapse similar tests into table-driven tests:\n```go\nfunc TestCreate(t *testing.T) {\n    tests := []struct{\n        name string\n        args []string\n        want string\n    }{\n        {\"basic issue\", []string{\"create\", \"Test\"}, \"created\"},\n        {\"with description\", []string{\"create\", \"Test\", \"-d\", \"desc\"}, \"created\"},\n        // ... 50 more cases\n    }\n    \n    db := setupOnce(t) // Setup once, not 50 times\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            // test using shared db\n        })\n    }\n}\n```\n\n**Pros**: Dramatically reduces setup overhead, tests run in parallel\n**Cons**: Requires refactoring, tests share more state\n\n## Option 3: Split cmd/bd Tests Into Packages (Big Win)\nMove tests into focused packages:\n- `cmd/bd/internal/clitests` - CLI integration tests (mark with integration tag)\n- `cmd/bd/internal/unittests` - Fast unit tests\n- Keep only essential tests in cmd/bd\n\n**Pros**: Clean separation, easy to run just fast tests\n**Cons**: Requires significant refactoring\n\n## Option 4: Parallel Execution (Quick Win)\nAdd `t.Parallel()` to independent tests:\n```go\nfunc TestSomething(t *testing.T) {\n    t.Parallel() // Run this test concurrently with others\n    // ...\n}\n```\n\n**Pros**: Easy to add, can cut time in half on multi-core machines\n**Cons**: Doesn't reduce actual test work, just parallelizes it\n\n## Option 5: In-Memory Databases (Medium Win)\nUse `:memory:` SQLite databases instead of file-based:\n```go\nstore, err := sqlite.New(ctx, \":memory:\")\n```\n\n**Pros**: Faster than disk I/O, easier cleanup\n**Cons**: Some tests need actual file-based DBs (export/import tests)\n\n# Recommended Approach\n\n**Short-term (this week)**:\n1. Add `t.Parallel()` to all independent tests in cmd/bd\n2. Use `:memory:` databases where possible\n3. Create table-driven tests for similar test cases\n\n**Medium-term (next sprint)**:\n4. Split cmd/bd tests into focused packages\n5. Mark more integration tests appropriately\n\n**Long-term (backlog)**:\n6. Consider shared test fixtures with proper isolation\n\n# Current Status\n\nWe've tagged 16 files with `integration` build tag, but the remaining 279 tests in cmd/bd still take 8+ minutes. This issue tracks fixing the cmd/bd test performance specifically.\n\n# Target\n\nGet `go test ./...` (without `-short` or `-tags=integration`) down to **under 30 seconds**.\n\n\n# THE REAL ROOT CAUSE (Updated Analysis)\n\nAfter examining the actual test code, the problem is clear:\n\n## Every Test Creates Its Own Database From Scratch\n\nLook at `create_test.go`:\n```go\nfunc TestCreate_BasicIssue(t *testing.T) {\n    tmpDir := t.TempDir()                          // ‚Üê Creates temp dir\n    testDB := filepath.Join(tmpDir, \".beads\", \"beads.db\")\n    s := newTestStore(t, testDB)                   // ‚Üê Opens NEW SQLite connection\n                                                    // ‚Üê Runs migrations\n                                                    // ‚Üê Sets config\n    // ... actual test (3 lines)\n}\n\nfunc TestCreate_WithDescription(t *testing.T) {\n    tmpDir := t.TempDir()                          // ‚Üê Creates ANOTHER temp dir\n    testDB := filepath.Join(tmpDir, \".beads\", \"beads.db\")\n    s := newTestStore(t, testDB)                   // ‚Üê Opens ANOTHER SQLite connection\n    // ... actual test (3 lines)\n}\n```\n\n**This happens 279 times!**\n\n## These Tests Don't Need Isolation!\n\nMost tests are just checking:\n- \"Can I create an issue with a title?\"\n- \"Can I create an issue with a description?\"\n- \"Can I add labels?\"\n\nThey don't conflict with each other. They could all share ONE database!\n\n## The Fix: Test Suites with Shared Setup\n\nInstead of:\n```go\nfunc TestCreate_BasicIssue(t *testing.T) {\n    s := newTestStore(t, t.TempDir()+\"/db\")  // ‚Üê Expensive!\n    // test\n}\n\nfunc TestCreate_WithDesc(t *testing.T) {\n    s := newTestStore(t, t.TempDir()+\"/db\")  // ‚Üê Expensive!\n    // test\n}\n```\n\nDo this:\n```go\nfunc TestCreate(t *testing.T) {\n    // ONE setup for all subtests\n    s := newTestStore(t, t.TempDir()+\"/db\")\n    \n    t.Run(\"basic_issue\", func(t *testing.T) {\n        t.Parallel()  // Can run concurrently - tests don't conflict\n        // test using shared `s`\n    })\n    \n    t.Run(\"with_description\", func(t *testing.T) {\n        t.Parallel()\n        // test using shared `s`\n    })\n    \n    // ... 50 more subtests, all using same DB\n}\n```\n\n**Result**: 50 tests ‚Üí 1 database setup instead of 50!\n\n## Why This Works\n\nSQLite is fine with concurrent reads and isolated transactions. These tests:\n- ‚úÖ Create different issues (no ID conflicts)\n- ‚úÖ Just read back what they created\n- ‚úÖ Don't depend on database state from other tests\n\nThey SHOULD share a database!\n\n## Real Numbers\n\nCurrent:\n- 279 tests √ó (create dir + init SQLite + migrations) = **8 minutes**\n\nAfter fix:\n- 10 test suites √ó (create dir + init SQLite + migrations) = **30 seconds**\n- 279 subtests running in parallel using those 10 DBs = **5 seconds**\n\n**Total: ~35 seconds instead of 8 minutes!**\n\n## Implementation Plan\n\n1. **Group related tests** into suites (Create, List, Update, Delete, etc.)\n2. **One setup per suite** instead of per test\n3. **Use t.Run() for subtests** with t.Parallel()\n4. **Keep tests that actually need isolation** separate (export/import tests, git operations)\n\nThis is way better than shuffling tests into folders!", "notes": "Analysis: The test panic in TestInitAlreadyInitialized is caused by store.Close() in PersistentPostRun setting s.db=nil, then subsequent HasRemote() call accessing the nil db. Also: suite is at ~27-37s when it actually completes (before panic kills it). Already well under 2min target. Main remaining work: fix the panic, consolidate metadata_filter_test.go (9 stores), metadata_ready_test.go (4 stores), list_test.go (7 stores), thread_test.go (5 stores).", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/onyx", "created_at": "2025-11-21T16:37:48Z", "updated_at": "2026-02-27T21:54:18Z", "closed_at": "2026-02-27T21:53:12Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-1rh", "depends_on_id": "bd-c49", "type": "blocks", "created_at": "2025-11-21T16:49:26Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-1rh", "depends_on_id": "bd-wisp-lwh1h5", "type": "blocks", "created_at": "2026-02-27T13:27:53Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 2, "dependent_count": 0, "comment_count": 0}
{"id": "bd-ee1", "title": "Add security tests for WriteFile permissions in doctor command", "description": "Test coverage gap identified by automated analysis (vc-217).\n\n**Original Issue:** [deleted:[deleted:bd-da96-baseline-lint]]\n\nIn cmd/bd/doctor/gitignore.go:98, os.WriteFile uses 0644 permissions, flagged by gosec G306 as potentially too permissive.\n\nAdd tests to verify:\n- File is created with appropriate permissions (0600 or less)\n- Existing file permissions are not loosened\n- File ownership is correct\n- Sensitive data handling if .gitignore contains secrets\n\nThis ensures .gitignore files are created with secure permissions to prevent unauthorized access.\n\n_This issue was automatically created by AI test coverage analysis._", "notes": "Implemented: Added 6 security tests covering WriteFile permissions in doctor package:\n- TestEnsureProjectGitignore_FilePermissions: verifies 0644 for new project .gitignore, 0600 preserved for existing\n- TestEnsureProjectGitignore_DoesNotLoosenPermissions: ensures existing restrictive perms not widened\n- TestGitignoreTemplate_NoSensitivePatterns: checks template for sensitive keywords\n- TestCheckPermissions_TempFileUsesSecurePerms: verifies temp file uses 0600\n- TestCheckPermissions_CleansUpOnSuccess: verifies temp file removed after check\nAll tests pass. Only test files modified (no production code changes needed ‚Äî gosec G306 was already addressed).", "status": "closed", "priority": 1, "issue_type": "task", "assignee": "beads/polecats/onyx", "created_at": "2025-11-21T15:25:34Z", "updated_at": "2026-02-28T00:11:17Z", "closed_at": "2026-02-28T00:11:17Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-ee1", "depends_on_id": "bd-da96-baseline-lint", "type": "discovered-from", "created_at": "2025-11-21T15:25:34Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-ee1", "depends_on_id": "bd-wisp-1fzx", "type": "blocks", "created_at": "2026-02-27T16:03:45Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-2q6d", "title": "Beads commands operate on stale database without warning", "description": "All beads read operations should validate database is in sync with JSONL before proceeding.\n\n**Current Behavior:**\n- Commands can query/read from stale database\n- Only mutation operations (like 'bd sync') check if JSONL is newer\n- User gets incorrect results without realizing database is out of sync\n\n**Expected Behavior:**\n- All beads commands should have pre-flight check for database freshness\n- If JSONL is newer than database, refuse to operate with error: \"Database out of sync. Run 'bd import' first.\"\n- Same safety check that exists for 'bd sync' should apply to ALL operations\n\n**Impact:**\n- Users make decisions based on incomplete/outdated data\n- Silent failures lead to confusion (e.g., thinking issues don't exist when they do)\n- Similar to running git commands on stale repo without being warned to pull\n\n**Example:**\n- Searched for bd-g9eu issue file: not found\n- Issue exists in .beads/issues.jsonl (in git)\n- Database was stale, but no warning was given\n- Led to incorrect conclusion that issue was already closed/deleted", "notes": "Implementation: Added staleness check in PersistentPreRun for read-only commands. Compares issues.jsonl mtime vs last_import_time metadata. Errors with actionable message when stale. Respects --allow-stale flag. Gracefully skips when no JSONL, no metadata, or corrupted metadata. New files: staleness.go, staleness_test.go. Modified: main.go (9 lines added).", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/quartz", "created_at": "2025-11-21T00:33:40Z", "updated_at": "2026-02-28T00:10:44Z", "closed_at": "2026-02-28T00:09:47Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-2q6d", "depends_on_id": "bd-wisp-hq25", "type": "blocks", "created_at": "2026-02-27T15:54:08Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 2, "comment_count": 0}
{"id": "bd-t4u1", "title": "False positive detection by Kaspersky Antivirus (Trojan)", "description": "Kaspersky Antivirus falsely detects beads (bd.exe v0.23.1) as a Trojan (PDM:Trojan.Win32.Generic) and removes it.\nEvent: Malicious object detected\nComponent: System Watcher\nObject name: bd.exe\n", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2025-11-20T23:56:12Z", "updated_at": "2026-02-27T23:53:18Z", "closed_at": "2026-02-27T23:53:18Z", "close_reason": "SQLite/Kaspersky ‚Äî not relevant to Dolt-only architecture", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-49kw", "title": "Workaround for FastMCP outputSchema bug in Claude Code", "description": "The beads MCP server (v0.23.1) successfully connects to Claude Code, but all tools fail to load with a schema validation error due to a bug in FastMCP 2.13.1.\n\nError: \"Invalid literal value, expected \\\"object\\\"\" in outputSchema.\n\nRoot Cause: FastMCP generates outputSchema with $ref at root level without \"type\": \"object\" for self-referential models (Issue).\n\nWorkaround: Use slash commands (/beads:ready) or wait for FastMCP fix.", "status": "closed", "priority": 1, "issue_type": "bug", "assignee": "beads/polecats/onyx", "created_at": "2025-11-20T23:55:39Z", "updated_at": "2026-02-28T00:00:30Z", "closed_at": "2026-02-27T23:58:11Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-49kw", "depends_on_id": "bd-wisp-lg6j", "type": "blocks", "created_at": "2026-02-27T15:54:26Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-bwk2", "title": "Centralize error handling patterns in storage layer", "description": "80+ instances of inconsistent error handling across sqlite.go with mix of %w, %v, and no wrapping.\n\nLocation: internal/storage/sqlite/sqlite.go (throughout)\n\nProblem:\n- Some use fmt.Errorf(\"op failed: %w\", err) - correct wrapping\n- Some use fmt.Errorf(\"op failed: %v\", err) - loses error chain\n- Some return err directly - no context\n- Hard to debug production issues\n- Can't distinguish error types\n\nSolution: Create internal/storage/sqlite/errors.go:\n- Define sentinel errors (ErrNotFound, ErrInvalidID, etc.)\n- Create wrapDBError(op string, err error) helper\n- Convert sql.ErrNoRows to ErrNotFound\n- Always wrap with operation context\n\nImpact: Lost error context; inconsistent messages; hard to debug\n\nEffort: 5-7 hours", "notes": "Implemented centralized error handling in dolt storage layer:\n\n1. Created internal/storage/dolt/errors.go with:\n   - Sentinel errors: ErrTransaction, ErrQuery, ErrScan, ErrExec\n   - Helper functions: wrapDBError, wrapTransactionError, wrapScanError, wrapQueryError, wrapExecError\n   - wrapDBError converts sql.ErrNoRows ‚Üí storage.ErrNotFound\n\n2. Applied wrapping to ~85 bare return err patterns across 12 files:\n   - transaction.go, queries.go, dependencies.go, issues.go, wisps.go\n   - ephemeral_routing.go, credentials.go, versioned.go, labels.go\n   - federation.go\n\n3. Key design decisions:\n   - scanIssueFrom left unwrapped: callers check sql.ErrNoRows explicitly\n   - Final rows.Err() returns left idiomatic (caller provides context)\n   - Store-level pass-throughs (withRetry, Close) left unwrapped\n   - All existing fmt.Errorf wrapping preserved\n\n4. Tests: All storage tests pass. Unit tests for error helpers included.", "status": "closed", "priority": 1, "issue_type": "task", "assignee": "beads/polecats/obsidian", "created_at": "2025-11-16T22:51:55Z", "updated_at": "2026-02-28T00:26:45Z", "closed_at": "2026-02-28T00:25:51Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-bwk2", "depends_on_id": "bd-wisp-yoki", "type": "blocks", "created_at": "2026-02-27T16:23:31Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-ola6", "title": "Implement transaction retry logic for SQLITE_BUSY", "description": "BEGIN IMMEDIATE fails immediately on SQLITE_BUSY instead of retrying with exponential backoff.\n\nLocation: internal/storage/sqlite/sqlite.go:223-225\n\nProblem:\n- Under concurrent write load, BEGIN IMMEDIATE can fail with SQLITE_BUSY\n- Current implementation fails immediately instead of retrying\n- Results in spurious failures under normal concurrent usage\n\nSolution: Implement exponential backoff retry:\n- Retry up to N times (e.g., 5)\n- Backoff: 10ms, 20ms, 40ms, 80ms, 160ms\n- Check for context cancellation between retries\n- Only retry on SQLITE_BUSY/database locked errors\n\nImpact: Spurious failures under concurrent write load\n\nEffort: 3 hours", "status": "closed", "priority": 1, "issue_type": "feature", "created_at": "2025-11-16T22:51:31Z", "updated_at": "2026-02-27T23:53:18Z", "closed_at": "2026-02-27T23:53:18Z", "close_reason": "SQLite/Kaspersky ‚Äî not relevant to Dolt-only architecture", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-e1085716", "title": "bd validate - Comprehensive health check", "description": "Run all validation checks in one command.\n\nChecks:\n- Duplicates\n- Orphaned dependencies\n- Test pollution\n- Git conflicts\n\nSupports --fix-all for auto-repair.\n\nDepends on bd-cbed9619.1, bd-0dcea000, bd-31aab707, bd-9826b69a.\n\nFiles: cmd/bd/validate.go (new)", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2025-10-30T06:05:14Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-581b80b3", "title": "bd find-duplicates - AI-powered duplicate detection", "description": "Find semantically duplicate issues.\n\nApproaches:\n1. Mechanical: Exact title/description matching\n2. Embeddings: Cosine similarity (cheap, scalable)\n3. AI: LLM-based semantic comparison (expensive, accurate)\n\nUses embeddings by default for >100 issues.\n\nFiles: cmd/bd/find_duplicates.go (new)", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2025-10-30T03:49:49Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-7e7ddffa.1", "title": "bd resolve-conflicts - Git merge conflict resolver", "description": "Automatically resolve JSONL merge conflicts.\n\nModes:\n- Mechanical: ID remapping (no AI)\n- AI-assisted: Smart merge/keep decisions\n- Interactive: Review each conflict\n\nHandles <<<<<<< conflict markers in .beads/beads.jsonl\n\nFiles: cmd/bd/resolve_conflicts.go (new)", "status": "closed", "priority": 1, "issue_type": "task", "created_at": "2025-10-28T21:48:30Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-7e7ddffa.1", "depends_on_id": "bd-7e7ddffa", "type": "parent-child", "created_at": "2025-10-30T02:58:29Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-7e7ddffa"}
{"id": "bd-5ua", "title": "Speed up internal/storage/dolt tests (75s)", "description": "attached_molecule: bd-wisp-vnssv\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T03:48:47Z\ndispatched_by: mayor\n\ninternal/storage/dolt takes 75s. Core storage layer tests ‚Äî probably spawning embedded Dolt or connecting to test servers per test. Check for: shared test server, t.Parallel(), unnecessary data setup. Target: under 30s.", "status": "in_progress", "priority": 2, "issue_type": "task", "assignee": "beads/polecats/jasper", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:42:10Z", "created_by": "mayor", "updated_at": "2026-02-28T03:54:10Z", "dependencies": [{"issue_id": "bd-5ua", "depends_on_id": "bd-wisp-vnssv", "type": "blocks", "created_at": "2026-02-27T19:48:47Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-6bq", "title": "Speed up cmd/bd/doctor tests (44s)", "description": "attached_molecule: bd-wisp-hispx\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T03:49:05Z\ndispatched_by: mayor\n\ncmd/bd/doctor takes 44s. Doctor runs diagnostic checks ‚Äî tests may be spawning real infrastructure. Check for: mocking opportunities, shared fixtures, parallel execution. Target: under 15s.", "notes": "Analysis: Tests take 68s. Root cause: 15+ tests each create a separate Dolt database (CREATE DATABASE + schema init = ~0.5-2s each). Fix: refactor tests to use branch-per-test isolation on the shared DB (newTestDoltStore). The path-based check functions (CheckDuplicateIssues, CheckStaleClosedIssues, etc.) internally open stores, so tests calling them create new DBs. Fix by testing the underlying query logic directly with the shared store's sql.DB.", "status": "in_progress", "priority": 2, "issue_type": "task", "assignee": "beads/polecats/onyx", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:42:10Z", "created_by": "mayor", "updated_at": "2026-02-28T03:54:26Z", "dependencies": [{"issue_id": "bd-6bq", "depends_on_id": "bd-wisp-hispx", "type": "blocks", "created_at": "2026-02-27T19:49:05Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-39c", "title": "IsInfraType hardcodes agent/rig/role/message - should be config-driven", "description": "ephemeral_routing.go:22-27 hardcodes infra types that get routed to wisps table. migrations/007_infra_to_wisps.go:11 duplicates the list. This is a policy decision baked into Go code - adding a new infra type (formula, slot) requires code change + release. Should be configurable via DB config table like types.custom.", "notes": "Implemented: IsInfraType is now config-driven via types.infra DB config key / config.yaml. Defaults to [agent, rig, role, message]. Configure with: bd config set types.infra 'agent,rig,role,message,formula,slot'. All callers updated. Migration 007 retains immutable hardcoded list.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:48:35Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T03:41:29Z", "closed_at": "2026-02-28T03:40:50Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-39c", "depends_on_id": "bd-wisp-5mfp4", "type": "blocks", "created_at": "2026-02-27T19:19:14Z", "created_by": "dog", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-tcn", "title": "Hardcoded database name 'beads' in 4 storage locations", "description": "store.go:445 applyConfigDefaults, bootstrap.go:43 and :100, configfile.go:47 all default to 'beads'. Should centralize into a single constant or derive from config resolution. Currently scattered defaults make it easy for different code paths to disagree on the database name.", "notes": "Replaced 3 hardcoded \"beads\" database name defaults (store.go:445, bootstrap.go:43, bootstrap.go:100) with configfile.DefaultDoltDatabase constant. Also updated comments referencing the default. The configfile.DefaultDoltDatabase constant already existed ‚Äî the storage/dolt package just wasn't using it.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/polecats/jasper", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:48:31Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T03:08:32Z", "closed_at": "2026-02-28T03:06:21Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-tcn", "depends_on_id": "bd-wisp-908ng", "type": "blocks", "created_at": "2026-02-27T18:55:06Z", "created_by": "dog", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-cgk", "title": "Code review: storage layer for hardcoded assumptions and ZFC violations", "description": "Review internal/storage/ (especially dolt/store.go) and internal/configfile/ for: hardcoded database names, hardcoded table structures that should be schema-driven, Go code making decisions that should be agent decisions, string matching on wisp content, hardcoded status transitions. Also check for Dolt-specific assumptions that would break portability. File beads for each issue found.", "notes": "## Code Review Findings: Storage Layer\n\n### Summary\nReviewed internal/storage/ (~14 files, ~5000 LOC) and internal/configfile/ (~1 file, 350 LOC).\nFound 7 categories of issues with hardcoded assumptions and ZFC violations.\n\n### 1. HARDCODED DATABASE NAME \"beads\" (4 locations)\n- store.go:445 - applyConfigDefaults defaults to \"beads\" when no config\n- bootstrap.go:43 - BootstrapFromGitRemoteWithDB defaults database to \"beads\"\n- bootstrap.go:100 - schemaReady defaults dbName to \"beads\"\n- configfile.go:47 - DefaultConfig uses \"beads.db\" for Database field\n\nThese should be centralized into a single constant or config resolution.\n\n### 2. HARDCODED INFRA TYPES - Go code making agent-level decisions (2 locations)\n- ephemeral_routing.go:22-27 - IsInfraType hardcodes \"agent\", \"rig\", \"role\", \"message\"\n- migrations/007_infra_to_wisps.go:11 - infraTypes duplicates the same list\n\nThe storage layer DECIDES which types are \"infrastructure\" and routes them\nto the wisps table. This is a policy decision that should be agent-configurable,\nnot hardcoded in Go. If Gas Town adds a new infra type (e.g., \"formula\", \"slot\"),\na code change + release is required.\n\n### 3. HARDCODED STATUS LISTS IN SQL VIEWS (schema.go)\n- schema.go:279 - ready_issues view: IN (open, in_progress, blocked, deferred, hooked)\n- schema.go:326 - blocked_issues view: IN (open, in_progress, blocked, deferred, hooked)\n- dependencies.go:779 - IsBlocked: IN (open, in_progress, blocked, deferred, hooked)\n- dependencies.go:834 - GetNewlyUnblockedByClose: IN (open, blocked)\n- dependencies.go:877 - GetNewlyUnblockedByClose: IN (open, in_progress, blocked, deferred, hooked)\n\nCustom statuses (config key \"status.custom\") are supported for validation but\nNOT reflected in these SQL views. A custom status like \"review\" would be\ninvisible to the ready_issues view, making issues with that status permanently\ninvisible to GetReadyWork.\n\n### 4. HARDCODED STATUS IN COMPACT.GO - Go code deciding agent logic\n- compact.go:35 - status != \"closed\" check uses string literal instead of types.StatusClosed\n- compact.go:49,59 - Magic numbers for compaction days (30, 90) hardcoded, though\n  config keys exist (compact_tier1_days, compact_tier2_days) they are not read.\n\n### 5. STRING-MATCHING ON WISP CONTENT - ephemeral_routing.go\n- ephemeral_routing.go:15 - IsEphemeralID checks strings.Contains(id, \"-wisp-\")\n\nThis is a convention-based routing that breaks when wisps have explicit IDs\n(GH#2053 noted in code). The code already has workarounds (isActiveWisp,\npartitionByWispStatus) but the fundamental pattern of routing by ID substring\nis fragile.\n\n### 6. DOLT-SPECIFIC ASSUMPTIONS THAT BREAK PORTABILITY\n- store.go:848 - CALL DOLT_COMMIT during schema init\n- versioned.go:52-62 - dolt_diff(), AS OF, DOLT_HASHOF() - Dolt-only functions\n- versioned.go:142 - dolt_branches table query\n- federation.go:19 - DOLT_PUSH, DOLT_PULL, DOLT_FETCH - Dolt procedures\n- versioned.go:253 - DOLT_CONFLICTS_RESOLVE procedure\n- store.go:795-796 - CREATE DATABASE IF NOT EXISTS with Dolt catalog race workarounds\n- history.go:83-86 - dolt_history_issues table (Dolt-specific virtual table)\n- versioned.go:204-212 - dolt_log table query\n\nThe Storage interface (storage.go) is clean, but the concrete Dolt implementation\nuses Dolt-specific stored procedures and virtual tables extensively. If a\nnon-Dolt backend were added, the versioned/federation features would need\nseparate interface extension points.\n\n### 7. HARDCODED DEFAULT CONFIG VALUES (schema.go:250-263)\n- defaultConfig embeds specific defaults: compact_model = \"claude-haiku-4-5-20251001\",\n  compact_batch_size = 50, types.custom = specific list including \"molecule,gate,convoy...\"\n- These are Gas Town operational constants baked into the storage layer schema init.\n\n### Non-issues (well-designed patterns)\n- Custom types/statuses: config.go reads from DB config table with YAML fallback - good\n- issue_scan.go: Centralized scan via issueSelectColumns - avoids column drift\n- configfile.go: All server params have env var overrides - good for portability\n- transactions.go: Clean interface with proper commit semantics\n- Test database firewall: Pattern-based guard against test pollution - solid defense", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:42:01Z", "created_by": "mayor", "updated_at": "2026-02-28T02:49:48Z", "closed_at": "2026-02-28T02:49:19Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-cgk", "depends_on_id": "bd-wisp-shf33", "type": "blocks", "created_at": "2026-02-27T18:45:19Z", "created_by": "dog", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-2c0", "title": "bd create --help creates an actual issue instead of showing help", "description": "Issues with title '--help' appear in production (gt-m24x, gt-tm4n, gt-gzx7 in gastown). Either cobra flag parsing has an edge case where --help is treated as a positional arg, or shell completion tests invoke bd create in a way that bypasses help flag detection. Investigate the exact code path and add a guard: reject titles starting with - or -- as likely flag mistakes.", "notes": "Implemented: Added guard in create.go to reject positional titles starting with '-' as likely misinterpreted flags. Error message directs users to --title flag for intentional use. Integration test covers -- --help, -- --version, -- -p, and -- --foo-bar patterns, plus verifies --title still accepts dash-prefixed values.", "status": "closed", "priority": 2, "issue_type": "bug", "assignee": "beads/polecats/jasper", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:21:29Z", "created_by": "mayor", "updated_at": "2026-02-28T01:04:18Z", "closed_at": "2026-02-28T01:02:13Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-2c0", "depends_on_id": "bd-wisp-h2wl", "type": "blocks", "created_at": "2026-02-27T16:54:17Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-7z5", "title": "Pre-existing: TestChildParentDependencies_PreservesParentChildType failure", "description": "validation_test.go:277: dependency bd-abc.1 -> bd-abc already exists with type 'parent-child' (requested 'blocks'). Test in cmd/bd/doctor/fix package.", "notes": "Implemented: restructured TestChildParentDependencies_PreservesParentChildType to create parent-child and blocks deps on separate child issues, matching the new AddDependency behavior that rejects type changes on existing key pairs.", "status": "closed", "priority": 2, "issue_type": "bug", "assignee": "beads/polecats/opal", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:11:09Z", "created_by": "beads/refinery", "updated_at": "2026-02-28T00:41:50Z", "closed_at": "2026-02-28T00:30:51Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-7z5", "depends_on_id": "bd-wisp-9waq", "type": "blocks", "created_at": "2026-02-27T16:25:49Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-qy0", "title": "Pre-existing: TestInitRedirect and TestInitBEADS_DIR failures", "description": "3 test failures on main: TestInitRedirect/RedirectCreatesDBInTarget (init_test.go:962), TestInitBEADS_DIR/InitCreatesDBAtBeadsDir (init_test.go:1174), TestInitBEADS_DIR/WithoutBeadsDirNoBehaviorChange (init_test.go:1213). All report 'Expected prefix X, got empty string'.", "notes": "Root cause: init.go line 293 sets dbName=prefix (hyphens) but line 444 writes DoltDatabase with underscores to metadata.json. Database created as e.g. redirect-test but metadata says redirect_test. openExistingTestDB reads metadata.json ‚Üí opens wrong database.", "status": "closed", "priority": 2, "issue_type": "bug", "assignee": "beads/polecats/topaz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:11:08Z", "created_by": "beads/refinery", "updated_at": "2026-02-28T00:41:40Z", "closed_at": "2026-02-28T00:37:05Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-qy0", "depends_on_id": "bd-wisp-j5dp", "type": "blocks", "created_at": "2026-02-27T16:25:59Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-0tn", "title": "Pre-existing: go vet IPv6 format warning in migrate_safety.go", "description": "cmd/bd/migrate_safety.go:100:22: address format \"%s:%d\" does not work with IPv6 (passed to net.Dial at L103). This should use net.JoinHostPort() instead of fmt.Sprintf.", "notes": "Fixed: replaced fmt.Sprintf(\"%s:%d\", host, port) with net.JoinHostPort in two locations in migrate_safety.go (verifyServerTarget line 100, verifyMigrationData line 211). go vet now passes clean.", "status": "closed", "priority": 2, "issue_type": "bug", "assignee": "beads/polecats/garnet", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:11:05Z", "created_by": "beads/refinery", "updated_at": "2026-02-28T00:41:29Z", "closed_at": "2026-02-28T00:35:36Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-0tn", "depends_on_id": "bd-wisp-x0s2", "type": "blocks", "created_at": "2026-02-27T16:26:09Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-8rq", "title": "Dolt Doctor Diagnostic", "description": "Dolt diagnostics detected issues: query latency 1.136s exceeds 1s threshold, 2 orphaned databases (gt, hq). Server responsive at port 3307. 7/200 connections active (4%), 348.0 MB disk usage. Run 'gt dolt cleanup' to remove orphans.", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:06:37Z", "created_by": "dog", "updated_at": "2026-02-27T23:52:57Z", "closed_at": "2026-02-27T23:52:57Z", "close_reason": "Test pollution / noise ‚Äî backlog cleanup", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-r8c", "title": "WORK_DONE: gt-r8m9", "description": "Exit: COMPLETED\nIssue: gt-r8m9\nBranch: polecat/rictus/gt-r8m9@mm5hkoyf", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "gastown/witness", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:05:51Z", "created_by": "gastown/polecats/rictus", "updated_at": "2026-02-27T23:52:58Z", "closed_at": "2026-02-27T23:52:58Z", "close_reason": "Test pollution / noise ‚Äî backlog cleanup", "labels": ["delivery-acked-at:2026-02-27T23:06:39Z", "delivery-acked-by:gastown/witness", "delivery:acked", "delivery:pending", "from:gastown/polecats/rictus", "gt:message", "read"], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "hq-cv-d46qe", "title": "Work: Flaky test: TestRunBdCmd_ReturnsStdoutOnNonZeroAndTimeout in internal/web", "description": "Auto-created convoy tracking gt-5kjn", "status": "open", "priority": 2, "issue_type": "convoy", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:04:35Z", "created_by": "mayor", "updated_at": "2026-02-27T23:04:35Z", "dependencies": [{"issue_id": "hq-cv-d46qe", "depends_on_id": "external:gastown:gt-5kjn", "type": "tracks", "created_at": "2026-02-27T15:04:35Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "hq-cv-ivmue", "title": "Work: P1: Dog patrol Dolt health monitoring", "description": "Auto-created convoy tracking gt-nek89", "status": "open", "priority": 2, "issue_type": "convoy", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:04:28Z", "created_by": "mayor", "updated_at": "2026-02-27T23:04:28Z", "dependencies": [{"issue_id": "hq-cv-ivmue", "depends_on_id": "external:gastown:gt-nek89", "type": "tracks", "created_at": "2026-02-27T15:04:27Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-1k3", "title": "Pre-existing failure: TestChildParentDependencies_PreservesParentChildType", "status": "closed", "priority": 2, "issue_type": "bug", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:01:51Z", "created_by": "beads/polecats/quartz", "updated_at": "2026-02-27T23:53:08Z", "closed_at": "2026-02-27T23:53:08Z", "close_reason": "Duplicates", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-t5f", "title": "go vet: IPv6 address format in migrate_safety.go:100", "description": "go vet reports: address format \"%s:%d\" does not work with IPv6 (passed to net.Dial at L103) in cmd/bd/migrate_safety.go:100. Pre-existing issue found during merge queue processing of bd-o23.", "status": "closed", "priority": 2, "issue_type": "bug", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:01:01Z", "created_by": "beads/refinery", "updated_at": "2026-02-27T23:53:08Z", "closed_at": "2026-02-27T23:53:08Z", "close_reason": "Duplicates", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-xq2", "title": "Plugin Result: rebuild-gt - Binary is not stale (commit ce7af0ae)", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T22:32:43Z", "created_by": "dog", "updated_at": "2026-02-27T22:50:43Z", "closed_at": "2026-02-27T22:50:43Z", "close_reason": "Test/pollution artifacts ‚Äî not real issues", "labels": ["plugin:rebuild-gt", "result:success", "rig:gastown", "type:plugin-run"], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-kzn", "title": "bd gc / bd compact / bd flatten commands for standalone Beads", "description": "Solo Beads users (no Gas Town, no Dogs) need built-in data lifecycle management. Three new bd subcommands: (1) bd gc ‚Äî runs DECAY+COMPACT+GC in sequence (delete old closed issues, rebase commits, dolt gc), (2) bd compact ‚Äî rebase old commits older than N days (default 30), (3) bd flatten ‚Äî nuclear squash all history to one commit (Tim Sehn recipe: branch, soft-reset to initial, commit, swap main, gc). Auto-compact: bd could check last compact date on startup and suggest/auto-run if stale. This is critical for Beads adoption ‚Äî without it, solo users hit storage limits. Sent briefing to bd-crew-emma.", "notes": "Implemented three new top-level maintenance commands:\n\n1. bd gc: Full lifecycle GC with three phases (decay/compact/dolt-gc). Decay deletes closed issues older than N days (default 90), compact phase reports commit count and suggests bd flatten, dolt gc phase runs dolt gc to reclaim space. Supports --dry-run, --force, --older-than, --skip-decay, --skip-dolt, --json.\n\n2. bd compact: Squashes Dolt commits older than N days (default 30) into a single base commit, then cherry-picks recent commits on top. Uses dolt CLI operations (branch, checkout, reset --soft, cherry-pick). Supports --dry-run, --force, --days, --json.\n\n3. bd flatten: Nuclear squash of ALL Dolt history into a single commit using the Tim Sehn recipe (branch, soft-reset to initial commit, commit, swap main, gc). Irreversible. Supports --dry-run, --force, --json.\n\nAll commands in the maint group. Removed deprecated compact alias (was forwarding to bd admin compact) to make room for the new Dolt commit compaction command.", "status": "closed", "priority": 2, "issue_type": "feature", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T19:45:21Z", "created_by": "mayor", "updated_at": "2026-02-28T00:23:19Z", "closed_at": "2026-02-28T00:22:38Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-kzn", "depends_on_id": "bd-wisp-200p", "type": "blocks", "created_at": "2026-02-27T16:11:01Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-kyu", "title": "Dolt tests fail in refinery worktree: gt dolt start not in Gas Town workspace", "description": "Tests in cmd/bd, internal/molecules, internal/storage/dolt, and internal/storage/dolt/compact fail because the test harness runs gt dolt start which fails with 'not in a Gas Town workspace' when run from a refinery rig worktree. Pre-existing issue.", "notes": "Fix: Added BEADS_TEST_MODE guard to IsDaemonManaged() branch in newServerMode (store.go:579). When BEADS_TEST_MODE is set, the code skips the gt dolt start path and falls through to the generic error, letting test-managed servers handle their own lifecycle. All affected test packages pass: internal/storage/dolt, internal/molecules, cmd/bd.", "status": "closed", "priority": 2, "issue_type": "bug", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T18:28:39Z", "created_by": "beads/refinery", "updated_at": "2026-02-28T01:05:14Z", "closed_at": "2026-02-28T01:05:14Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-kyu", "depends_on_id": "bd-wisp-esp6", "type": "blocks", "created_at": "2026-02-27T16:52:47Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-2bt", "title": "go vet: IPv6 format warning in cmd/bd/migrate_safety.go:100", "description": "go vet reports: address format \"%s:%d\" does not work with IPv6 (passed to net.Dial at L103). Pre-existing on main.", "status": "closed", "priority": 2, "issue_type": "bug", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T18:28:37Z", "created_by": "beads/refinery", "updated_at": "2026-02-27T23:53:09Z", "closed_at": "2026-02-27T23:53:09Z", "close_reason": "Duplicates", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-1qh", "title": "show bd-mu1", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-27T08:18:48Z", "updated_at": "2026-02-27T22:50:43Z", "closed_at": "2026-02-27T22:50:43Z", "close_reason": "Test/pollution artifacts ‚Äî not real issues", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-mu1", "title": "list", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-27T08:18:41Z", "updated_at": "2026-02-27T22:50:43Z", "closed_at": "2026-02-27T22:50:43Z", "close_reason": "Test/pollution artifacts ‚Äî not real issues", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-8mg", "title": "Add 'bd restore' command to bootstrap from JSONL backup", "description": "Solo users get automatic JSONL backup to GitHub (auto-enabled when git remote exists), but there's no restore path. If a user loses their Dolt database (machine crash, new clone, etc.), they have .beads/backup/*.jsonl on GitHub but must manually bd init + bd import to recover.\n\nAdd a 'bd restore' command that:\n1. Detects .beads/backup/*.jsonl files (or accepts a path)\n2. Creates/reinitializes the Dolt database if needed\n3. Imports all JSONL tables (issues, events, comments, dependencies, labels, config)\n4. Restores the backup_state.json watermarks so incremental backup resumes correctly\n\nAlso consider: bd init should detect existing backup files and offer to restore automatically.\n\nWithout this, the auto-backup is a false sense of security ‚Äî data is on GitHub but recovery is undocumented and manual.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/polecats/obsidian", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T07:48:24Z", "created_by": "beads/crew/emma", "updated_at": "2026-02-27T08:09:21Z", "closed_at": "2026-02-27T08:08:11Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "labels": ["backup", "solo-ux"], "dependencies": [{"issue_id": "bd-8mg", "depends_on_id": "bd-wisp-n35vje", "type": "blocks", "created_at": "2026-02-26T23:53:02Z", "created_by": "beads/crew/emma", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-zfj", "title": "witness Handoff", "description": "{\"attached_molecule\": \"mol-witness-patrol\", \"nudges\": {}, \"pending_cleanup\": []}", "status": "pinned", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T07:45:55Z", "created_by": "beads/witness", "updated_at": "2026-02-27T07:46:15Z", "labels": ["pinned"], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-ftc", "title": "bd close cannot find promoted wisps with wisp-pattern IDs", "description": "IsEphemeralID() routes bd-wisp-* IDs to wisps table, but promoted wisps (via PromoteFromEphemeral) live in the issues table with ephemeral=0. Result: bd close bd-wisp-xxx fails with 'not found'. Workaround: raw SQL UPDATE. Fix: routing should fall through to issues table when wisp table lookup fails for wisp-pattern IDs.", "notes": "Fix: partitionByWispStatus now verifies wisp-pattern IDs exist in wisps table before routing. Promoted wisps (which have -wisp- in ID but live in issues table) are correctly routed to the issues table. Root cause was GetIssuesByIDs -> partitionByWispStatus trusting pattern-based routing without verifying actual table membership.", "status": "closed", "priority": 2, "issue_type": "bug", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T01:32:41Z", "created_by": "mayor", "updated_at": "2026-02-28T00:26:09Z", "closed_at": "2026-02-28T00:25:34Z", "close_reason": "Completed with no code changes (already fixed or pushed directly to main)", "dependencies": [{"issue_id": "bd-ftc", "depends_on_id": "bd-wisp-4da9", "type": "blocks", "created_at": "2026-02-27T16:13:07Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-gb8vd", "title": "Digest: mol-witness-patrol", "description": "Patrol 3: Quiet rig. No polecats, no mail, no swarms, no timer gates. Refinery alive (8h), Deacon alive. Escalated broken beads redirect to Mayor.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-26T23:02:57Z", "updated_at": "2026-02-26T23:02:57Z", "closed_at": "2026-02-26T23:02:57Z", "close_reason": "Squashed from 7 wisps", "dependencies": [{"issue_id": "bd-gb8vd", "depends_on_id": "bd-wisp-gz2jet", "type": "parent-child", "created_at": "2026-02-26T15:02:57Z", "created_by": "beads/witness", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-gz2jet"}
{"id": "bd-zafu", "title": "bd backup command for standalone users", "description": "Standalone bd users need a simple backup story. Add 'bd backup' command that wraps Dolt backup operations:\n\n- bd backup init <path> ‚Äî set up a filesystem backup destination (wraps dolt backup add)\n- bd backup sync ‚Äî push to configured backup (wraps dolt backup sync)\n- bd backup restore <path> ‚Äî restore from a backup\n- bd backup status ‚Äî show last backup time, destination, size\n\nAlso document DoltHub as the recommended cloud remote path for solo users. Git-protocol remotes (git+ssh to GitHub) are not viable ‚Äî 20+ min push times, unbounded git-remote-cache growth, force-push required after any recovery.\n\nTarget audience: solo devs using bd outside Gas Town who want their issues backed up somewhere safe (external drive, NAS, Dropbox, or DoltHub).", "notes": "Implemented: bd backup init <path>, bd backup sync, enhanced bd backup status with Dolt backup info and database size. Wraps DOLT_BACKUP SQL procedures for standalone user backups to filesystem/DoltHub.", "status": "closed", "priority": 2, "issue_type": "feature", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-26T18:33:39Z", "created_by": "mayor", "updated_at": "2026-02-28T00:42:57Z", "closed_at": "2026-02-28T00:41:30Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-zafu", "depends_on_id": "bd-wisp-4cvx", "type": "blocks", "created_at": "2026-02-27T16:27:44Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-tk8y", "title": "P2: Complete branch-per-test migration with dolt reset --hard", "description": "Tim Sehn confirmed branch isolation scales to 1000s of concurrent branches. testdoltbranch.go already implements StartTestBranch() with per-test branch creation. Remaining work: (1) Ensure all test packages use branch isolation instead of CREATE DATABASE, (2) Incorporate Tim's dolt reset --hard trick for reusable test branches ‚Äî seed data on a branch, run writes, reset back to seeded state instead of recreating. (3) Clean up any remaining per-package server spawning. (4) Consider testcontainers-dolt module (Dustin's suggestion) for CI. Reference: Tim's email 2024-02-24, dolthub blog post on enginetest perf.", "notes": "Implemented: (1) Added ResetTestBranch() to testutil/testdoltbranch.go for dolt reset --hard reusable branches. (2) Migrated migrations_test.go to shared server + branch-per-test isolation via new TestMain with issues table committed to main. Eliminated 8 per-test server spawns. (3) Migrated dolt_phantom_test.go to shared doctor TestMain server with cleanupPhantomDB helper. Eliminated 5 per-test server spawns. All 14 tests pass. Resolved merge conflicts with parallel agent work (combined best of both approaches).", "status": "closed", "priority": 2, "issue_type": "feature", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-26T01:48:10Z", "created_by": "mayor", "updated_at": "2026-02-28T01:10:09Z", "closed_at": "2026-02-28T01:10:09Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-tk8y", "depends_on_id": "bd-wisp-56lz", "type": "blocks", "created_at": "2026-02-27T16:43:33Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-toy3", "title": "Test hook", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-17T02:33:40Z", "updated_at": "2026-02-27T02:53:45Z", "closed_at": "2026-02-27T02:53:45Z", "close_reason": "Test artifact cleanup (Clown Show #21)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-tggf", "title": "Code Health Review Dec 2025: Technical Debt Cleanup", "description": "Epic grouping technical debt identified in the Dec 16, 2025 code health review.\n\n## Overall Health Grade: B (Solid foundation, needs cleanup)\n\n### P1 (High Priority):\n- bd-74w1: Consolidate duplicate path-finding utilities\n- bd-b6xo: Remove/fix ClearDirtyIssues() race condition\n- bd-b3og: Fix TestImportBugIntegration deadlock\n\n### P2 (Medium Priority):\n- bd-05a8: Split large files (doctor.go, sync.go)\n- bd-qioh: Standardize error handling patterns\n- bd-rgyd: Split queries.go (1586 lines)\n- bd-9g1z: Fix/remove TestFindJSONLPathDefault\n\n### P3 (Low Priority):\n- bd-ork0: Add comments to 30+ ignored errors\n- bd-4nqq: Remove dead test code in info_test.go\n- bd-dhza: Reduce global state in main.go\n\n## Key Areas:\n1. Code duplication in path utilities\n2. Large monolithic files (5 files >1000 lines)\n3. Global state (25+ variables, 3 deprecated)\n4. Silent error suppression (30+ instances)\n5. Test gaps and dead test code\n6. Atomicity risks in batch operations", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2025-12-17T02:18:58Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 10, "comment_count": 0}
{"id": "bd-9g1z", "title": "Fix or remove TestFindJSONLPathDefault (issue #356)", "description": "Code health review found .test-skip permanently skips TestFindJSONLPathDefault.\n\nThe test references issue #356 about wrong JSONL filename expectations (issues.jsonl vs beads.jsonl).\n\nTest file: internal/beads/beads_test.go\n\nThe underlying migration from beads.jsonl to issues.jsonl may be complete, so either:\n1. Fix the test expectations\n2. Remove the test if no longer needed\n3. Document why it remains skipped", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-12-17T02:17:31Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-9g1z", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-rgyd", "title": "Split internal/storage/sqlite/queries.go (1586 lines)", "description": "Code health review found queries.go is too large at 1586 lines with:\n\n- Issue scanning logic duplicated between transaction.go and queries.go\n- Timestamp defensive fixes duplicated in CreateIssue, CreateIssues, batch_ops.go\n- Multiple similar patterns that should be consolidated\n\nAlso: transaction.go at 1284 lines, dependencies.go at 893 lines\n\nRecommendation:\n1. Extract common scanning into shared function\n2. Consolidate timestamp defensive fixes\n3. Split queries.go by domain (CRUD, search, batch, events)", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-17T02:17:24Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-rgyd", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-qioh", "title": "Standardize error handling: replace direct fmt.Fprintf+os.Exit with FatalError", "description": "Code health review found inconsistent error handling patterns:\n\nPattern A (preferred): FatalError() from errors.go:21-24\nPattern B (inconsistent): Direct fmt.Fprintf(os.Stderr) + os.Exit(1)\n\nAffected files:\n- delete.go:35-49 uses direct pattern\n- create.go:213 ignores error silently\n- Various other commands\n\nFix: Standardize on FatalError() wrapper for consistent error messages and testability.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-17T02:17:19Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-qioh", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-05a8", "title": "Split large cmd/bd files: doctor.go (2948 lines), sync.go (2121 lines)", "description": "Code health review found several oversized files:\n\n1. doctor.go - 2948 lines, 48 functions mixed together\n   - Should split into doctor/checks/*.go for individual diagnostics\n   - applyFixes() and previewFixes() are nearly identical\n\n2. sync.go - 2121 lines\n   - ZFC (Zero Flush Check) logic embedded inline (lines 213-247)\n   - Multiple mode handlers should be extracted\n\n3. init.go - 1732 lines\n4. compact.go - 1097 lines\n5. show.go - 1069 lines\n\nRecommendation: Extract into focused sub-packages or split into logical files.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-17T02:17:18Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-05a8", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-8fgn", "title": "test hash length", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-16T21:49:32Z", "updated_at": "2026-02-27T02:53:45Z", "closed_at": "2026-02-27T02:53:45Z", "close_reason": "Test artifact cleanup (Clown Show #21)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-7h7", "title": "bd init should stop running daemon to avoid stale cache", "description": "When running bd init, any running daemon continues with stale cached data, causing bd stats and other commands to show old counts.\n\nRepro:\n1. Have daemon running with 788 issues cached\n2. Clean JSONL to 128 issues, delete db, run bd init\n3. bd stats still shows 788 (daemon cache)\n4. Must manually run bd daemon --stop\n\nFix: bd init should automatically stop any running daemon before reinitializing.", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-12-16T21:26:47Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-kwro.11", "title": "Documentation for messaging and graph links", "description": "Document all new features.\n\nFiles to update:\n- README.md - brief mention of messaging capability\n- AGENTS.md - update for AI agents using bd mail\n- docs/messaging.md (new) - full messaging reference\n- docs/graph-links.md (new) - graph link reference\n- CHANGELOG.md - v0.30.2 release notes\n\nTopics to cover:\n- Mail commands with examples\n- Graph link types and use cases\n- Identity configuration\n- Hooks setup for notifications\n- Migration notes", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-16T11:02:40Z", "updated_at": "2026-02-27T02:56:53Z", "closed_at": "2026-02-27T02:56:53Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-kwro.11", "depends_on_id": "bd-kwro", "type": "parent-child", "created_at": "2025-12-16T11:02:40Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-kwro"}
{"id": "bd-s0qf", "title": "GH#405: Fix prefix parsing with hyphens - multi-hyphen prefixes parsed incorrectly", "description": "Fixed: ExtractIssuePrefix was falling back to first-hyphen for word-like suffixes, breaking multi-hyphen prefixes like 'hacker-news' and 'me-py-toolkit'.", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-12-16T09:13:57Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-4uoc", "title": "Code Review Followup Summary: PR #481 + PR #551", "description": "## Merged PRs Summary\n\n### PR #551: Persist close_reason to issues table\n- ‚úÖ Merged successfully\n- ‚úÖ Bug fix: close_reason now persisted in database column (not just events table)\n- ‚úÖ Comprehensive test coverage added\n- ‚úÖ Handles reopen case (clearing close_reason)\n\n**Followup Issues Filed:**\n- bd-lxzx: Document close_reason in JSONL export format\n- bd-077e: Update CLI documentation for close_reason field\n\n---\n\n### PR #481: Context Engineering Optimizations (80-90% context reduction)\n- ‚úÖ Merged successfully  \n- ‚úÖ Lazy tool discovery: discover_tools() + get_tool_info()\n- ‚úÖ Minimal issue models: IssueMinimal (~80% smaller than full Issue)\n- ‚úÖ Result compaction: Auto-compacts results >20 items\n- ‚úÖ All 28 tests passing\n- ‚ö†Ô∏è Breaking change: ready() and list() return type changed\n\n**Followup Issues Filed:**\n- bd-b318: Add integration tests for CompactedResult\n- bd-4u2b: Make compaction settings configurable (THRESHOLD, PREVIEW_COUNT)\n- bd-2kf8: Document CompactedResult response format in CONTEXT_ENGINEERING.md\n- bd-pdr2: Document backwards compatibility considerations\n\n---\n\n## Overall Assessment\n\nBoth PRs are production-ready with solid implementations. All critical functionality works and tests pass. Followup issues focus on:\n1. Documentation improvements (5 issues)\n2. Integration test coverage (1 issue)\n3. Configuration flexibility (1 issue)\n4. Backwards compatibility guidance (1 issue)\n\nNo critical bugs or design issues found.\n\n## Review Completed By\nCode review process completed. Issues auto-created for tracking improvements.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T22:25:59Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-4uoc", "depends_on_id": "bd-otf4", "type": "discovered-from", "created_at": "2025-12-14T22:25:59Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-4uoc", "depends_on_id": "bd-z86n", "type": "discovered-from", "created_at": "2025-12-14T22:25:59Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-lxzx", "title": "Add close_reason to JSONL export format documentation", "description": "PR #551 now persists close_reason to the database, but there's a question about whether this field should be exported to JSONL format.\n\n## Current State\n- close_reason is stored in issues.close_reason column\n- close_reason is also stored in events table (audit trail)\n- The JSONL export format may or may not include close_reason\n\n## Questions\n1. Should close_reason be exported to JSONL format?\n2. If yes, where should it go (root level or nested in events)?\n3. Should there be any special handling to avoid duplication?\n4. How should close_reason be handled during JSONL import?\n\n## Why This Matters\n- JSONL is the git-friendly sync format\n- Other beads instances import from JSONL\n- close_reason is meaningful data that should be preserved across clones\n\n## Suggested Action\n- Check if close_reason is currently exported in JSONL\n- If not, add it to the export schema\n- Document the field in JSONL format spec\n- Add tests for round-trip (export -> import -> verify close_reason)", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T22:25:17Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-lxzx", "depends_on_id": "bd-z86n", "type": "discovered-from", "created_at": "2025-12-14T22:25:17Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-z86n", "title": "Code Review: PR #551 - Persist close_reason to issues table", "description": "Code review of PR #551 which fixes close_reason persistence bug.\n\n## Summary\nThe PR correctly fixes a bug where close_reason was only stored in the events table, not in the issues.close_reason column. This caused `bd show --json` to return empty close_reason.\n\n## What Was Fixed\n- ‚úÖ CloseIssue now updates both close_reason and closed_at\n- ‚úÖ ReOpenIssue clears both close_reason and closed_at\n- ‚úÖ Comprehensive tests added for both storage and CLI layers\n- ‚úÖ Clear documentation in queries.go about dual storage strategy\n\n## Quality Assessment\n‚úÖ Tests cover both storage layer and CLI JSON output\n‚úÖ Handles reopen case (clearing close_reason)\n‚úÖ Good comments explaining dual-storage design\n‚úÖ No known issues\n\n## Potential Followups\nSee linked issues for suggestions.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T22:25:07Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-pdr2", "title": "Consider backwards compatibility for ready() and list() return type change", "description": "PR #481 changed the return types of `ready()` and `list()` from `list[Issue]` to `list[IssueMinimal] | CompactedResult`. This is a breaking change for MCP clients.\n\n## Impact Assessment\nBreaking change affects:\n- Any MCP client expecting `list[Issue]` from ready()\n- Any MCP client expecting `list[Issue]` from list()\n- Client code that accesses full Issue fields (description, design, acceptance_criteria, timestamps, dependencies, dependents)\n\n## Current Behavior\n- ready() returns `list[IssueMinimal] | CompactedResult`\n- list() returns `list[IssueMinimal] | CompactedResult`\n- show() still returns full `Issue` (good)\n\n## Considerations\n**Pros of current approach:**\n- Forces clients to use show() for full details (good for context efficiency)\n- Simple mental model (always use show for full data)\n- Documentation warns about this\n\n**Cons:**\n- Clients expecting list[Issue] will break\n- No graceful degradation option\n- No migration period\n\n## Potential Solutions\n1. Add optional parameter `full_details=false` to ready/list (would increase payload)\n2. Create separate tools: ready_minimal/list_minimal + ready_full/list_full\n3. Accept breaking change and document upgrade path (current approach)\n4. Version the MCP server and document migration guide\n\n## Recommendation\nCurrent approach (solution 3) is reasonable if:\n- Changelog clearly documents the breaking change\n- Migration guide provided to clients\n- Error handling is graceful for clients expecting specific fields", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T22:24:56Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-pdr2", "depends_on_id": "bd-otf4", "type": "discovered-from", "created_at": "2025-12-14T22:24:56Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-otf4", "title": "Code Review: PR #481 - Context Engineering Optimizations", "description": "Comprehensive code review of the merged context engineering PR (PR #481) that reduces MCP context usage by 80-90%.\n\n## Summary\nThe PR successfully implements lazy tool schema loading and minimal issue models to reduce context window usage. Overall implementation is solid and well-tested.\n\n## Positive Findings\n‚úÖ Well-designed models (IssueMinimal, CompactedResult)\n‚úÖ Comprehensive test coverage (28 tests, all passing)\n‚úÖ Clear documentation and comments\n‚úÖ Backward compatibility preserved (show() still returns full Issue)\n‚úÖ Sensible defaults (COMPACTION_THRESHOLD=20, PREVIEW_COUNT=5)\n‚úÖ Tool catalog complete with all 15 tools documented\n\n## Issues Identified\nSee linked issues for specific followup tasks.\n\n## Context Engineering Architecture\n- discover_tools(): List tool names only (~500 bytes vs ~15KB)\n- get_tool_info(name): Get specific tool details on-demand\n- IssueMinimal: Lightweight model for list views (~80 bytes vs ~400 bytes)\n- CompactedResult: Auto-compacts results with >20 issues\n- _to_minimal(): Conversion function (efficient, no N+1 issues)", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T22:24:14Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-hlsw", "title": "Add sync resilience guardrails for forced pushes and prefix mismatches", "description": "Beads can get into unrecoverable sync states when remote forces pushes occur (e.g., rebases) combined with prefix mismatches from multi-worker scenarios. Add detection, prevention, and auto-recovery features to handle this gracefully.", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2025-12-14T17:40:15Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-bvec", "title": "Test coverage improvement initiative (47.8% ‚Üí 65%)", "description": "Umbrella epic for improving overall test coverage from 47.8% to 65%+.\n\n## Summary\n\n| Package | Current | Target | Issue |\n|---------|---------|--------|-------|\n| internal/compact | 18.2% | 70% | bd-thgk |\n| cmd/bd/doctor/fix | 23.9% | 50% | bd-fx7v |\n| cmd/bd | 26.2% | 50% | bd-llfl |\n| internal/daemon | 27.3% | 60% | bd-n386 |\n| cmd/bd/setup | 28.4% | 50% | bd-sh4c |\n| internal/syncbranch | 33.0% | 70% | bd-io8c |\n| internal/export | 37.1% | 60% | bd-6sm6 |\n| internal/lockfile | 42.0% | 60% | bd-9w3s |\n| internal/rpc | 47.5% | 60% | bd-m8ro |\n| internal/beads | 48.1% | 70% | bd-tvu3 |\n| internal/storage | N/A | basic | bd-a15d |\n\n## Packages with good coverage (no action needed)\n- internal/types: 91.0%\n- internal/utils: 88.9%\n- internal/deletions: 84.3%\n- internal/config: 84.2%\n- internal/autoimport: 83.5%\n- internal/validation: 80.8%\n- internal/merge: 78.9%\n- internal/routing: 74.3%\n- internal/storage/sqlite: 73.1%\n- internal/importer: 70.2%\n\nOverall target: 65%+ (from current 47.8%)", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2025-12-14T04:43:23Z", "updated_at": "2026-02-27T02:53:49Z", "closed_at": "2026-02-27T02:53:49Z", "close_reason": "Test artifact cleanup (Clown Show #21)", "dependencies": [{"issue_id": "bd-bvec", "depends_on_id": "bd-6sm6", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-9w3s", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-a15d", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-fx7v", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-io8c", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-llfl", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-m8ro", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-n386", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-sh4c", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-thgk", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-bvec", "depends_on_id": "bd-tvu3", "type": "blocks", "created_at": "2025-12-14T04:43:30Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 11, "dependent_count": 0, "comment_count": 0}
{"id": "bd-a15d", "title": "Add test files for internal/storage", "description": "The internal/storage package has no test files at all. This package provides the storage interface abstraction.\n\nCurrent coverage: N/A (no test files)\nTarget: Add basic interface tests", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T04:43:11Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-m8ro", "title": "Improve test coverage for internal/rpc (47.5% ‚Üí 60%)", "description": "The RPC package has only 47.5% test coverage. RPC is the communication layer for daemon operations.\n\nCurrent coverage: 47.5%\nTarget coverage: 60%", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T04:43:10Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-6sm6", "title": "Improve test coverage for internal/export (37.1% ‚Üí 60%)", "description": "The export package has only 37.1% test coverage. Export functionality needs good coverage to ensure data integrity.\n\nCurrent coverage: 37.1%\nTarget coverage: 60%", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T04:43:07Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-fx7v", "title": "Improve test coverage for cmd/bd/doctor/fix (23.9% ‚Üí 50%)", "description": "The doctor/fix package has only 23.9% test coverage. The doctor fix functionality is important for troubleshooting.\n\nCurrent coverage: 23.9%\nTarget coverage: 50%", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T04:43:06Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-sh4c", "title": "Improve test coverage for cmd/bd/setup (28.4% ‚Üí 50%)", "description": "The setup package has only 28.4% test coverage. Setup commands are critical for first-time user experience.\n\nCurrent coverage: 28.4%\nTarget coverage: 50%", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T04:43:04Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-llfl", "title": "Improve test coverage for cmd/bd CLI (26.2% ‚Üí 50%)", "description": "The main CLI package (cmd/bd) has only 26.2% test coverage. CLI commands should have at least 50% coverage to ensure reliability.\n\nKey areas with low/no coverage:\n- daemon_autostart.go (multiple 0% functions)\n- compact.go (several 0% functions)\n- Various command handlers\n\nCurrent coverage: 26.2%\nTarget coverage: 50%", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T04:43:03Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-n386", "title": "Improve test coverage for internal/daemon (27.3% ‚Üí 60%)", "description": "The daemon package has only 27.3% test coverage. The daemon is critical for background operations and reliability.\n\nKey areas needing tests:\n- Daemon autostart logic\n- Socket handling\n- PID file management\n- Health checks\n\nCurrent coverage: 27.3%\nTarget coverage: 60%", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-14T04:43:01Z", "updated_at": "2026-02-27T02:56:50Z", "closed_at": "2026-02-27T02:56:50Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-lfak", "title": "bd preflight: PR readiness checks for contributors", "description": "## Vision\n\nEncode project-specific institutional knowledge into executable checks. CONTRIBUTING.md is documentation that's read once and forgotten; `bd preflight` is documentation that runs at exactly the right moment.\n\n## Problem Statement\n\nContributors face a \"last mile\" problem - they do the work but stumble on project-specific gotchas at PR time:\n- Nix vendorHash gets stale when go.sum changes\n- Beads artifacts leak into PRs (see bd-umbf for namespace solution)\n- Version mismatches between version.go and default.nix\n- Tests/lint not run locally before pushing\n- Other project-specific checks that only surface when CI fails\n\nThese are too obscure to remember, exist in docs nobody reads end-to-end, and waste CI round-trips.\n\n## Why beads?\n\nBeads already has a foothold in the contributor workflow. It knows:\n- Git state (staged files, branch, dirty status)\n- Project structure\n- The specific issue being worked on\n- Project-specific configuration\n\n## Proposed Interface\n\n### Tier 1: Checklist Mode (v1)\n\n    $ bd preflight\n    PR Readiness Checklist:\n\n    [ ] Tests pass: go test -short ./...\n    [ ] Lint passes: golangci-lint run ./...\n    [ ] No beads pollution: check .beads/issues.jsonl diff\n    [ ] Nix hash current: go.sum unchanged or vendorHash updated\n    [ ] Version sync: version.go matches default.nix\n\n    Run 'bd preflight --check' to validate automatically.\n\n### Tier 2: Check Mode (v2)\n\n    $ bd preflight --check\n    ‚úì Tests pass\n    ‚úì Lint passes\n    ‚ö† Beads pollution: 3 issues in diff - are these project issues or personal?\n    ‚úó Nix hash stale: go.sum changed, vendorHash needs update\n      Fix: sha256-KRR6dXzsSw8OmEHGBEVDBOoIgfoZ2p0541T9ayjGHlI=\n    ‚úì Version sync\n\n    1 error, 1 warning. Run 'bd preflight --fix' to auto-fix where possible.\n\n### Tier 3: Fix Mode (v3)\n\n    $ bd preflight --fix\n    ‚úì Updated vendorHash in default.nix\n    ‚ö† Cannot auto-fix beads pollution - manual review needed\n\n## Checks to Implement\n\n| Check | Description | Auto-fixable |\n|-------|-------------|--------------|\n| tests | Run go test -short ./... | No |\n| lint | Run golangci-lint | Partial (gofmt) |\n| beads-pollution | Detect personal issues in diff | No (see bd-umbf) |\n| nix-hash | Detect stale vendorHash | Yes (if nix available) |\n| version-sync | version.go matches default.nix | Yes |\n| no-debug | No TODO/FIXME/console.log | Warn only |\n| clean-stage | No unintended files staged | Warn only |\n\n## Future: Configuration\n\nMake checks configurable per-project via .beads/preflight.yaml:\n\n    preflight:\n      checks:\n        - name: tests\n          run: go test -short ./...\n          required: true\n        - name: no-secrets\n          pattern: \"**/*.env\"\n          staged: deny\n        - name: custom-check\n          run: ./scripts/validate.sh\n\nThis lets any project using beads define their own preflight checks.\n\n## Implementation Phases\n\n### Phase 1: Static Checklist\n- Implement bd preflight with hardcoded checklist for beads\n- No execution, just prints what to check\n- Update CONTRIBUTING.md to reference it\n\n### Phase 2: Automated Checks\n- Implement bd preflight --check\n- Run tests, lint, detect stale hashes\n- Clear pass/fail/warn output\n\n### Phase 3: Auto-fix\n- Implement bd preflight --fix\n- Fix vendorHash, version sync\n- Integrate with bd-umbf solution for pollution\n\n### Phase 4: Configuration\n- .beads/preflight.yaml support\n- Make it useful for other projects using beads\n- Plugin/hook system for custom checks\n\n## Dependencies\n\n- bd-umbf: Namespace isolation for beads pollution (blocking for full solution)\n\n## Success Metrics\n\n- Fewer CI failures on first PR push\n- Reduced \"fix nix hash\" commits\n- Contributors report preflight caught issues before CI", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2025-12-14T02:01:40Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-lfak", "depends_on_id": "bd-umbf", "type": "blocks", "created_at": "2025-12-14T02:01:46Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-umbf", "title": "Design contributor namespace isolation for beads pollution prevention", "description": "## Problem\n\nWhen contributors work on beads-the-project using beads-the-tool, their personal work-tracking issues leak into PRs. The .beads/issues.jsonl is intentionally tracked (it's the project's issue database), but contributors' local issues pollute the diff.\n\nThis is a recursion problem unique to self-hosting projects.\n\n## Possible Solutions to Explore\n\n1. **Contributor namespaces** - Each contributor gets a private prefix (e.g., `bd-steve-xxxx`) that's gitignored or filtered\n2. **Separate database** - Contributors use BEADS_DIR pointing elsewhere for personal tracking\n3. **Issue ownership/visibility flags** - Mark issues as \"local-only\" vs \"project\"\n4. **Prefix-based filtering** - Configure which prefixes are committed vs ignored\n\n## Design Considerations\n\n- Should be zero-friction for contributors (no manual setup)\n- Must not break existing workflows\n- Needs to work with sync/collaboration features\n- Consider: what if a \"personal\" issue graduates to \"project\" issue?\n\n## Expansion Needed\n\nThis is a placeholder. Needs detailed design exploration before implementation.", "status": "closed", "priority": 2, "issue_type": "feature", "created_at": "2025-12-14T02:00:30Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-4qfb", "title": "Improve bd doctor output formatting for better readability", "description": "The current bd doctor output is a wall of text that's hard to process. Consider improvements like:\n- Grouping related checks into collapsible sections\n- Using color/bold for section headers\n- Showing only failures/warnings by default with --verbose for full output\n- Better visual hierarchy between major sections\n- Summary line at top (e.g., '24 checks passed, 0 warnings, 0 errors')", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-12T22:29:28Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-20j", "title": "sync branch not match config", "description": "./bd sync\n‚Üí Exporting pending changes to JSONL...\n‚Üí No changes to commit\n‚Üí Pulling from sync branch 'gh-386'...\nError pulling from sync branch: failed to create worktree: failed to create worktree parent directory: mkdir /var/home/matt/dev/beads/worktree-db-fail/.git: not a directory\nmatt@blufin-framation ~/d/b/worktree-db-fail (worktree-db-fail) [1]> bd config list\n\nConfiguration:\n  auto_compact_enabled = false\n  compact_batch_size = 50\n  compact_model = claude-3-5-haiku-20241022\n  compact_parallel_workers = 5\n  compact_tier1_days = 30\n  compact_tier1_dep_levels = 2\n  compact_tier2_commits = 100\n  compact_tier2_days = 90\n  compact_tier2_dep_levels = 5\n  compaction_enabled = false\n  issue_prefix = worktree-db-fail\n  sync.branch = worktree-db-fail", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-08T13:49:04Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-de6", "title": "Fix FindBeadsDir to prioritize main repo .beads for worktrees", "description": "The FindBeadsDir function should prioritize finding .beads in the main repository root when accessed from a worktree, rather than finding worktree-local .beads directories. This ensures proper sharing of the database across all worktrees.", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-12-07T23:48:37Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-yck", "title": "Fix checkExistingBeadsData to be worktree-aware", "description": "The checkExistingBeadsData function in cmd/bd/init.go checks for .beads in the current working directory, but for worktrees it should check the main repository root instead. This prevents proper worktree compatibility.", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-12-07T23:48:32Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-y2v", "title": "Refactor duplicate JSONL-from-git parsing code", "description": "Both readFirstIssueFromGit() in init.go and importFromGit() in autoimport.go have similar code patterns for:\n1. Running git show <ref>:<path>\n2. Scanning the output with bufio.Scanner\n3. Parsing JSON lines\n\nCould be refactored to share a helper like:\n- readJSONLFromGit(gitRef, path string) ([]byte, error)\n- Or a streaming version: streamJSONLFromGit(gitRef, path string) (io.Reader, error)\n\nFiles:\n- cmd/bd/autoimport.go:225-256 (importFromGit)\n- cmd/bd/init.go:1212-1243 (readFirstIssueFromGit)\n\nPriority is low since code duplication is minimal and both functions work correctly.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-05T22:51:18Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-7di", "title": "worktree: any bd command is slow", "description": "in a git worktree any bd command is slow, with a 2-3s pause before any results are shown. The identical command with `--no-daemon` is near instant.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-05T22:33:43Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-n3v", "title": "Error committing to sync branch: failed to create worktree", "description": "> bd sync --no-daemon\n‚Üí Exporting pending changes to JSONL...\n‚Üí Committing changes to sync branch 'beads-sync'...\nError committing to sync branch: failed to create worktree: failed to create worktree parent directory: mkdir /var/home/matt/dev/beads/fix-ci/.git: not a directory", "notes": "**Problem Diagnosed**: The `bd sync` command was failing with \"mkdir /var/home/matt/dev/beads/fix-ci/.git: not a directory\" because it was being executed from the wrong directory.\n\n**Root Cause**: The command was run from `/var/home/matt/dev/beads` (where the `fix-ci` worktree exists) instead of the main repository directory `/var/home/matt/dev/beads/main`. Since `fix-ci` is a git worktree with a `.git` file (not directory), the worktree creation logic failed when trying to create `<current_dir>/.git/beads-worktrees/<branch>`.\n\n**Solution Verified**: Execute `bd sync` from the main repository directory:\n```bash\ncd main && bd sync --dry-run\n```\n", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-12-05T22:25:25Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-3sz0", "title": "Auto-repair stale merge driver configs with invalid placeholders", "description": "Old bd versions (<0.24.0) installed merge driver with invalid placeholders %L %R instead of %A %B. Add detection to bd doctor --fix: check if git config merge.beads.driver contains %L or %R, auto-repair to 'bd merge %A %O %A %B'. One-time migration for users who initialized with old versions.", "status": "closed", "priority": 2, "issue_type": "feature", "created_at": "2025-11-22T07:16:11Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-3sz0", "depends_on_id": "bd-tbz3", "type": "parent-child", "created_at": "2025-11-22T07:16:11Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-tbz3"}
{"id": "bd-au0.8", "title": "Improve clean vs cleanup command naming/documentation", "description": "Clarify the difference between bd clean and bd cleanup to reduce user confusion.\n\n**Current state:**\n- bd clean: Remove temporary artifacts (.beads/bd.sock, logs, etc.)\n- bd cleanup: Delete old closed issues from database\n\n**Options:**\n1. Rename for clarity:\n   - bd clean ‚Üí bd clean-temp\n   - bd cleanup ‚Üí bd cleanup-issues\n   \n2. Keep names but improve help text and documentation\n\n3. Add prominent warnings in help output\n\n**Preferred approach:** Option 2 (improve documentation)\n- Update short/long descriptions in commands\n- Add examples to help text\n- Update README.md\n- Add cross-references in help output\n\n**Files to modify:**\n- cmd/bd/clean.go\n- cmd/bd/cleanup.go\n- README.md or ADVANCED.md", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-11-22T02:07:50Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-au0.8", "depends_on_id": "bd-au0", "type": "parent-child", "created_at": "2025-11-22T02:07:50Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-au0"}
{"id": "bd-au0", "title": "Command Set Standardization & Flag Consistency", "description": "Comprehensive improvements to bd command set based on 2025 audit findings.\n\n## Background\nSee docs/command-audit-2025.md for detailed analysis.\n\n## Goals\n1. Standardize flag naming and behavior across all commands\n2. Add missing flags for feature parity\n3. Fix naming confusion\n4. Improve consistency in JSON output\n\n## Success Criteria\n- All mutating commands support --dry-run (no --preview variants)\n- bd update supports label operations\n- bd search has filter parity with bd list\n- Priority flags accept both int and P0-P4 format everywhere\n- JSON output is consistent across all commands", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2025-11-22T02:05:56Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-r46", "title": "Support --reason flag in daemon mode for reopen command", "description": "The reopen.go command has a TODO at line 61 to add reason as a comment once RPC supports AddComment. Currently --reason flag is ignored in daemon mode with a warning.", "status": "closed", "priority": 2, "issue_type": "feature", "created_at": "2025-11-21T23:55:11Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-o4qy", "title": "Improve CheckStaleness error handling", "description": "## Problem\n\nCheckStaleness returns 'false' (not stale) for multiple error conditions instead of returning errors. This masks problems.\n\n**Location:** internal/autoimport/autoimport.go:253-285\n\n## Edge Cases That Return False\n\n1. **Invalid last_import_time format** (line 259-262)\n2. **No JSONL file found** (line 267-277)  \n3. **JSONL stat fails** (line 279-282)\n\n## Fix\n\nReturn errors for abnormal conditions:\n\n```go\nlastImportTime, err := time.Parse(time.RFC3339, lastImportStr)\nif err != nil {\n    return false, fmt.Errorf(\"corrupted last_import_time: %w\", err)\n}\n\nif jsonlPath == \"\" {\n    return false, fmt.Errorf(\"no JSONL file found\")\n}\n\nstat, err := os.Stat(jsonlPath)\nif err != nil {\n    return false, fmt.Errorf(\"cannot stat JSONL: %w\", err)\n}\n```\n\n## Impact\nMedium - edge cases are rare but should be handled\n\n## Effort  \n30 minutes - requires updating callers in RPC server", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-11-21T01:17:28Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-o4qy", "depends_on_id": "bd-2q6d", "type": "blocks", "created_at": "2025-11-21T01:18:27Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-n4td", "title": "Add warning when staleness check errors", "description": "## Problem\n\nWhen ensureDatabaseFresh() calls CheckStaleness() and it errors (corrupted metadata, permission issues, etc.), we silently proceed with potentially stale data.\n\n**Location:** cmd/bd/staleness.go:27-32\n\n**Scenarios:**\n- Corrupted metadata table\n- Database locked by another process  \n- Permission issues reading JSONL file\n- Invalid last_import_time format in DB\n\n## Current Code\n\n```go\nisStale, err := autoimport.CheckStaleness(ctx, store, dbPath)\nif err \\!= nil {\n    // If we can't determine staleness, allow operation to proceed\n    // (better to show potentially stale data than block user)\n    return nil\n}\n```\n\n## Fix\n\n```go\nisStale, err := autoimport.CheckStaleness(ctx, store, dbPath)\nif err \\!= nil {\n    fmt.Fprintf(os.Stderr, \"Warning: Could not verify database freshness: %v\\n\", err)\n    fmt.Fprintf(os.Stderr, \"Proceeding anyway. Data may be stale.\\n\\n\")\n    return nil\n}\n```\n\n## Impact\nMedium - users should know when staleness check fails\n\n## Effort\nEasy - 5 minutes", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-11-21T01:16:35Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-n4td", "depends_on_id": "bd-2q6d", "type": "blocks", "created_at": "2025-11-21T01:18:20Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-g9eu", "title": "Investigate TestRoutingIntegration failure", "description": "TestRoutingIntegration/maintainer_with_SSH_remote failed during pre-commit check with \"expected role maintainer, got contributor\".\nThis occurred while running `go test -short ./...` on darwin/arm64.\nThe failure appears unrelated to storage/sqlite changes.\nNeed to investigate if this is a flaky test or environmental issue.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-11-20T23:55:19Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-ykd9", "title": "Add bd doctor --fix flag to automatically repair issues", "description": "Implement a --fix flag for bd doctor that can automatically repair detected issues.\n\nRequirements:\n- Add --fix flag to bd doctor command\n- Show all fixable issues and prompt for confirmation before applying fixes\n- Organize fix implementations under doctor/fix/<type_of_fix>.go\n- Each fix type should have its own file (e.g., doctor/fix/hooks.go, doctor/fix/sync.go)\n- Display what will be fixed and ask user to confirm (Y/n) before proceeding\n- Support fixing issues like:\n  - Missing or broken git hooks\n  - Sync problems with remote\n  - File permission issues\n  - Any other auto-repairable issues doctor detects\n\nImplementation notes:\n- Maintain separation between detection (existing doctor code) and repair (new fix code)\n- Each fix should be idempotent and safe to run multiple times\n- Provide clear output about what was fixed\n- Log any fixes that fail with actionable error messages", "status": "closed", "priority": 2, "issue_type": "feature", "created_at": "2025-11-15T02:17:48Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-0fvq", "title": "bd doctor should recommend bd prime migration for existing repos", "description": "bd doctor should detect old beads integration patterns and recommend migrating to bd prime approach.\n\n## Current behavior\n- bd doctor checks if Claude hooks are installed globally\n- Doesn't check project-level integration (AGENTS.md, CLAUDE.md)\n- Doesn't recommend migration for repos using old patterns\n\n## Desired behavior\nbd doctor should detect and suggest:\n\n1. **Old slash command pattern detected**\n   - Check for /beads:* references in AGENTS.md, CLAUDE.md\n   - Suggest: These slash commands are deprecated, use bd prime hooks instead\n   \n2. **No agent documentation**\n   - Check if AGENTS.md or CLAUDE.md exists\n   - Suggest: Run 'bd onboard' or 'bd setup claude' to document workflow\n   \n3. **Old MCP-only pattern**\n   - Check for instructions to use MCP tools but no bd prime hooks\n   - Suggest: Add bd prime hooks for better token efficiency\n\n4. **Migration path**\n   - Show: 'Run bd setup claude to add SessionStart/PreCompact hooks'\n   - Show: 'Update AGENTS.md to reference bd prime instead of slash commands'\n\n## Example output\n\n‚ö† Warning: Old beads integration detected in CLAUDE.md\n  Found: /beads:* slash command references (deprecated)\n  Recommend: Migrate to bd prime hooks for better token efficiency\n  Fix: Run 'bd setup claude' and update CLAUDE.md\n\nüí° Tip: bd prime + hooks reduces token usage by 80-99% vs slash commands\n  MCP mode: ~50 tokens vs ~10.5k for full MCP scan\n  CLI mode: ~1-2k tokens with automatic context recovery\n\n## Benefits\n- Helps existing repos adopt new best practices\n- Clear migration path for users\n- Better token efficiency messaging", "status": "closed", "priority": 2, "issue_type": "feature", "created_at": "2025-11-12T11:20:26Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-90v", "title": "bd prime: AI context loading and Claude Code integration", "description": "Implement `bd prime` command and Claude Code hooks for context recovery. Hooks work with BOTH MCP server and CLI approaches - they solve the context memory problem (keeping bd workflow fresh after compaction) not the tool access problem (MCP vs CLI).", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2025-11-12T07:31:12Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-o78", "title": "Enhance `bd doctor` to verify Claude Code integration", "description": "Add checks to `bd doctor` that verify Claude Code integration is properly set up when .claude/ directory or Claude environment is detected.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-11-12T07:30:06Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-o78", "depends_on_id": "bd-90v", "type": "parent-child", "created_at": "2025-11-12T07:31:28Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-o78", "depends_on_id": "bd-br8", "type": "blocks", "created_at": "2025-11-12T07:30:06Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-o78", "depends_on_id": "bd-rpn", "type": "blocks", "created_at": "2025-11-12T07:30:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 2, "dependent_count": 0, "comment_count": 0, "parent": "bd-90v"}
{"id": "bd-77gm", "title": "Import reports misleading '0 created, 0 updated' when actually importing all issues", "description": "When running 'bd import' on a fresh database (no existing issues), the command reports 'Import complete: 0 created, 0 updated' even though it successfully imported all issues from the JSONL file.\n\n**Steps to reproduce:**\n1. Delete .beads/beads.db\n2. Run: bd import .beads/issues.jsonl\n3. Observe output: 'Import complete: 0 created, 0 updated'\n4. Run: bd list\n5. Confirm: All issues are actually present in the database\n\n**Expected behavior:**\nReport the actual number of issues imported, e.g., 'Import complete: 523 created, 0 updated'\n\n**Actual behavior:**\n'Import complete: 0 created, 0 updated' (misleading - makes user think import failed)\n\n**Impact:**\n- Users think import failed when it succeeded\n- Confusing during database sync operations (e.g., after git pull)\n- Makes debugging harder (can't tell if import actually worked)\n\n**Context:**\nDiscovered during VC session when syncing database after git pull. The misleading message caused confusion about whether the database was properly synced with the canonical JSONL file.", "status": "closed", "priority": 2, "issue_type": "bug", "created_at": "2025-11-10T00:20:13Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-3852", "title": "Add orphan detection migration", "description": "Create migration to detect orphaned children in existing databases. Query: SELECT id FROM issues WHERE id LIKE '%.%' AND substr(id, 1, instr(id || '.', '.') - 1) NOT IN (SELECT id FROM issues). Log results, let user decide action (delete orphans or convert to top-level).", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-11-04T20:32:31Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-9cdc", "title": "Update docs for import bug fix", "description": "Update AGENTS.md, README.md, TROUBLESHOOTING.md with import.orphan_handling config documentation. Document resurrection behavior, tombstones, config modes. Add troubleshooting section for import failures with deleted parents.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-11-04T20:32:31Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-ktng", "title": "Optimize CLI test suite - eliminate redundant git init calls", "description": "Current: Each of 13 CLI tests calls git init (31s total). Solution: Use single test binary built once in init(), skip git operations where possible, or use mock filesystem.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-11-04T19:23:14Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-ktng", "depends_on_id": "bd-l5gq", "type": "discovered-from", "created_at": "2025-11-04T19:23:14Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-28db", "title": "Add 'bd status' command for issue database overview", "description": "Implement a bd status command that provides a quick snapshot of the issue database state, similar to how git status shows working tree state.\n\nExpected output: Show summary including counts by state (open, in-progress, blocked, closed), recent activity (last 7 days), and quick overview without needing multiple queries.\n\nExample output showing issue counts, recent activity stats, and pointer to bd list for details.\n\nProposed options: --all (show all issues), --assigned (show issues assigned to current user), --json (JSON format output)\n\nUse cases: Quick project health check, onboarding for new contributors, integration with shell prompts or CI/CD, daily standup reference", "status": "closed", "priority": 2, "issue_type": "feature", "created_at": "2025-11-03T01:25:59Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-98c4e1fa.1", "title": "Update AGENTS.md with event-driven mode", "description": "Document BEADS_DAEMON_MODE env var. Explain opt-in during Phase 1. Add troubleshooting for watcher failures.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-10-30T06:05:14Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-98c4e1fa.1", "depends_on_id": "bd-0e1f2b1b", "type": "parent-child", "created_at": "2025-11-01T02:38:09Z", "created_by": "mayor", "metadata": "{}"}, {"issue_id": "bd-98c4e1fa.1", "depends_on_id": "bd-98c4e1fa", "type": "parent-child", "created_at": "2025-10-30T04:19:36Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-0e1f2b1b"}
{"id": "bd-6fe4622f", "title": "Remove unreachable utility functions", "description": "Several small utility functions are unreachable:\n\nFiles to clean:\n1. `internal/storage/sqlite/hash.go` - `computeIssueContentHash` (line 17)\n   - Check if entire file can be deleted if only contains this function\n\n2. `internal/config/config.go` - `FileUsed` (line 151)\n   - Delete unused config helper\n\n3. `cmd/bd/git_sync_test.go` - `verifyIssueOpen` (line 300)\n   - Delete dead test helper\n\n4. `internal/compact/haiku.go` - `HaikuClient.SummarizeTier2` (line 81)\n   - Tier 2 summarization not implemented\n   - Options: implement feature OR delete method\n\nImpact: Removes 50-100 LOC depending on decisions", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-10-28T23:20:02Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-89f89fc0", "title": "Remove unreachable RPC methods", "description": "Several RPC server and client methods are unreachable and should be removed:\n\nServer methods (internal/rpc/server.go):\n- `Server.GetLastImportTime` (line 2116)\n- `Server.SetLastImportTime` (line 2123)\n- `Server.findJSONLPath` (line 2255)\n\nClient methods (internal/rpc/client.go):\n- `Client.Import` (line 311) - RPC import not used (daemon uses autoimport)\n\nEvidence:\n```bash\ngo run golang.org/x/tools/cmd/deadcode@latest -test ./...\n```\n\nImpact: Removes ~80 LOC of unused RPC code", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-10-28T23:20:02Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-aec5439f", "title": "Update LINTING.md with current baseline", "description": "After cleanup, document the remaining acceptable baseline in LINTING.md so we can track regression.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2025-10-28T01:53:10Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-1lc", "title": "defaultConfig in schema.go embeds Gas Town operational constants", "description": "schema.go:250-263 defaultConfig hardcodes: compact_model='claude-haiku-4-5-20251001' (AI model), types.custom='molecule,gate,convoy,merge-request,slot,agent,role,rig,message' (Gas Town types). These are runtime operational values baked into the storage layer init. They should be injected by the application layer or read from config.yaml, not embedded in schema initialization.", "status": "open", "priority": 3, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:49:00Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T02:49:00Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-019", "title": "Dolt-specific procedures not behind interface - blocks portability", "description": "The Storage interface (storage.go) is clean but the Dolt implementation uses Dolt-specific features extensively without abstraction: DOLT_COMMIT, DOLT_PUSH/PULL/FETCH, dolt_diff(), dolt_history_*, dolt_branches, dolt_log, DOLT_HASHOF, DOLT_CONFLICTS_RESOLVE, AS OF syntax. These are used in versioned.go, federation.go, history.go, store.go. If a non-Dolt backend is ever needed, the VersionedStorage and FederatedStorage interfaces would need to be optional capabilities, not assumed.", "status": "open", "priority": 3, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:48:56Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T02:48:56Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-o4c", "title": "IsEphemeralID routes by ID substring '-wisp-' - fragile convention", "description": "ephemeral_routing.go:15 uses strings.Contains(id, '-wisp-') for routing decisions. Breaks for explicit-ID ephemerals (GH#2053). Workarounds exist (isActiveWisp, partitionByWispStatus, batchWispExists) but the fundamental pattern of routing by ID substring creates a fragile dual-path that every new storage method must remember to handle. Consider a column-based approach (check ephemeral flag in DB) as the canonical routing.", "status": "open", "priority": 3, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:48:51Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T02:48:51Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-17p", "title": "compact.go uses string literal 'closed' instead of types.StatusClosed", "description": "compact.go:35 compares status \\!= 'closed' as a raw string instead of using types.StatusClosed constant. Also compact.go:49,59 hardcode compaction thresholds (30, 90 days) despite config keys existing (compact_tier1_days, compact_tier2_days) - the config values are never read.", "status": "open", "priority": 3, "issue_type": "bug", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:48:46Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T02:48:46Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-2ws", "title": "Wire sync.git-remote config into bd init for auto-bootstrap", "description": "The sync.git-remote config key is defined in yaml_config.go and BootstrapFromGitRemote() exists in bootstrap.go, but bd init never reads this config to auto-clone from a Dolt git remote.\n\nWhen a user sets sync.git-remote in config.yaml (or ~/.config/bd/config.yaml) and runs bd init on a new machine, it should:\n1. Detect sync.git-remote is configured\n2. Call BootstrapFromGitRemote() to clone the Dolt database from the git remote\n3. Skip fresh schema creation (database already has schema from clone)\n4. Configure the remote in the new store so bd dolt push/pull work immediately\n\nThis enables the new-machine story for Dolt replication users: set the config once, bd init does the rest.", "notes": "Implemented: bd init now reads sync.git-remote from config.yaml and calls BootstrapFromGitRemoteWithDB() before dolt.New(). After store creation, adds the remote via store.AddRemote() so push/pull work immediately. All non-fatal with graceful fallback to fresh init.", "status": "closed", "priority": 3, "issue_type": "task", "assignee": "beads/polecats/jasper", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T07:49:11Z", "created_by": "beads/crew/emma", "updated_at": "2026-02-27T18:22:50Z", "closed_at": "2026-02-27T18:20:39Z", "close_reason": "Merged to main via fast-forward (8cc0874f)", "labels": ["dolt", "solo-ux"], "dependencies": [{"issue_id": "bd-2ws", "depends_on_id": "bd-wisp-yurwc8", "type": "blocks", "created_at": "2026-02-27T10:11:39Z", "created_by": "beads/crew/emma", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-5x9", "title": "Auto-push to Dolt remote with 5-minute debounce", "description": "When a Dolt remote is configured, auto-push after write operations (create, update, close, etc.) with a 5-minute debounce ‚Äî similar to how JSONL auto-backup throttles at 15 minutes.\n\nImplementation approach:\n- Same pattern as maybeAutoBackup(): check last push timestamp, skip if < 5min ago\n- Gate on store.HasRemote(ctx, 'origin') ‚Äî only if a remote exists\n- Run in PersistentPostRun after auto-commit (and after auto-backup)\n- Failure is non-fatal (warning only, like JSONL git push)\n- Configurable interval via config key (e.g. dolt.auto-push-interval: 5m)\n- Opt-out via dolt.auto-push: false\n\nThis completes the Dolt replication story: users add a remote once, and data flows automatically.", "notes": "Implemented auto-push to Dolt remote with 5-minute debounce. New file: cmd/bd/dolt_autopush.go. Config keys: dolt.auto-push (auto-enabled when origin exists), dolt.auto-push-interval (default 5m). Same pattern as maybeAutoBackup: debounce, change detection, non-fatal warnings. Tests in dolt_autopush_test.go.", "status": "closed", "priority": 3, "issue_type": "task", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T07:49:06Z", "created_by": "beads/crew/emma", "updated_at": "2026-02-27T18:22:54Z", "closed_at": "2026-02-27T18:21:04Z", "close_reason": "Closed", "labels": ["dolt", "solo-ux"], "dependencies": [{"issue_id": "bd-5x9", "depends_on_id": "bd-wisp-4qqryq", "type": "blocks", "created_at": "2026-02-27T10:11:30Z", "created_by": "beads/crew/emma", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-fhh", "title": "Add 'bd dolt remote' subcommands (add/list/remove)", "description": "The Dolt store already has working methods for remote management ‚Äî AddRemote(), HasRemote(), ListRemotes(), RemoveRemote() ‚Äî and bd dolt push/pull work. But there's no CLI command to manage remotes. Users must drop to the dolt CLI directly to add a git remote.\n\nAdd subcommands:\n- bd dolt remote add <name> <url>  ‚Äî calls store.AddRemote()\n- bd dolt remote list               ‚Äî calls store.ListRemotes()  \n- bd dolt remote remove <name>      ‚Äî calls store.RemoveRemote()\n\nThis completes the Dolt-to-git-remote story so users never need the dolt CLI for basic replication setup.", "status": "closed", "priority": 3, "issue_type": "task", "assignee": "beads/polecats/quartz", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T07:48:26Z", "created_by": "beads/crew/emma", "updated_at": "2026-02-27T08:05:14Z", "closed_at": "2026-02-27T08:03:44Z", "close_reason": "Closed", "labels": ["dolt", "solo-ux"], "dependencies": [{"issue_id": "bd-fhh", "depends_on_id": "bd-wisp-s8b24i", "type": "blocks", "created_at": "2026-02-26T23:53:23Z", "created_by": "beads/crew/emma", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-dhza", "title": "Reduce global state in cmd/bd/main.go (25+ variables)", "description": "Code health review found main.go has 25+ global variables (lines 57-112):\n\n- dbPath, actor, store, jsonOutput, daemonClient, noDaemon\n- rootCtx, rootCancel, autoFlushEnabled\n- isDirty (marked 'USED BY LEGACY CODE')\n- needsFullExport (marked 'USED BY LEGACY CODE')\n- flushTimer (marked 'DEPRECATED')\n- flushMutex, storeMutex, storeActive\n- flushFailureCount, lastFlushError, flushManager\n- skipFinalFlush, autoImportEnabled\n- versionUpgradeDetected, previousVersion, upgradeAcknowledged\n\nImpact:\n- Hard to test individual commands\n- Race conditions possible\n- State leakage between commands\n\nFix: Move toward dependency injection. Remove deprecated variables. Consider cmd/bd/internal package.", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-17T02:17:30Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-dhza", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-4nqq", "title": "Remove dead test code in info_test.go", "description": "Code health review found cmd/bd/info_test.go has two tests permanently skipped:\n\n- TestInfoCommand\n- TestInfoCommandNoDaemon\n\nBoth skip with: 'Manual test - bd info command is working, see manual testing'\n\nThese are essentially dead code. Either automate them or remove them entirely.", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-17T02:17:28Z", "updated_at": "2026-02-27T02:56:51Z", "closed_at": "2026-02-27T02:56:51Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-4nqq", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-ork0", "title": "Add comments to 30+ silently ignored errors or fix them", "description": "Code health review found 30+ instances of error suppression using blank identifier without explanation:\n\nGood examples (with comments):\n- merge.go: _ = gitRmCmd.Run() // Ignore errors\n- daemon_watcher.go: _ = watcher.Add(...) // Ignore error\n\nBad examples (no context):\n- create.go:213: dbPrefix, _ = store.GetConfig(ctx, \"issue_prefix\")\n- daemon_sync_branch.go: _ = daemonClient.Close()\n- migrate_hash_ids.go, version_tracking.go: _ = store.Close()\n\nFix: Add comments explaining WHY errors are ignored, or handle them properly.", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-17T02:17:26Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-ork0", "depends_on_id": "bd-tggf", "type": "blocks", "created_at": "2025-12-17T02:19:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 1, "dependent_count": 0, "comment_count": 0}
{"id": "bd-411u", "title": "Document BEADS_DIR pattern for multi-agent workspaces (Gas Town)", "description": "Gas Town and similar multi-agent systems need to configure separate beads databases per workspace/rig, distinct from any project-level beads.\n\n## Use Case\n\nIn Gas Town:\n- Each 'rig' (managed project) has multiple agents (polecats, refinery, witness)\n- All agents in a rig should share a single beads database at the rig level\n- This should be separate from any .beads/ the project itself uses\n- The BEADS_DIR env var enables this\n\n## Documentation Needed\n\n1. Add a section to docs explaining BEADS_DIR for multi-agent setups\n2. Example: setting BEADS_DIR in agent startup scripts/hooks\n3. Clarify interaction with project-level .beads/ (BEADS_DIR takes precedence)\n\n## Current Support\n\nAlready implemented in internal/beads/beads.go:FindDatabasePath():\n- BEADS_DIR env var is checked first (preferred)\n- BEADS_DB env var still supported (deprecated)\n- Falls back to .beads/ search in tree\n\nJust needs documentation for the multi-agent workspace pattern.", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-16T06:08:22Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-077e", "title": "Add close_reason field to CLI schema and documentation", "description": "PR #551 persists close_reason, but the CLI documentation may not mention this field as part of the issue schema.\n\n## Current State\n- close_reason is now persisted in database\n- `bd show --json` will return close_reason in JSON output\n- Documentation may not reflect this new field\n\n## What's Missing\n- CLI reference documentation for close_reason field\n- Schema documentation showing close_reason is a top-level issue field\n- Example output showing close_reason in bd show --json\n- bd close command documentation should mention close_reason parameter is optional\n\n## Suggested Action\n1. Update README.md or CLI reference docs to list close_reason as an issue field\n2. Add example to bd close documentation\n3. Update any type definitions or schema specs\n4. Consider adding close_reason to verbose list output (bd list --verbose)", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-14T22:25:28Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-077e", "depends_on_id": "bd-z86n", "type": "discovered-from", "created_at": "2025-12-14T22:25:28Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-hlsw.3", "title": "Auto-recovery mode (bd sync --auto-recover)", "description": "Add bd sync --auto-recover flag that: detects problematic sync state, backs up .beads/issues.db with timestamp, rebuilds DB from JSONL atomically, verifies consistency, reports what was fixed. Provides safety valve when sync integrity fails.", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-14T17:40:21Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-hlsw.3", "depends_on_id": "bd-hlsw", "type": "parent-child", "created_at": "2025-12-14T17:40:21Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-hlsw"}
{"id": "bd-hlsw.4", "title": "Sync branch integrity guards", "description": "Track sync branch parent commit. If sync branch was force-pushed, warn user and require confirmation before proceeding. Add option to reset to remote if user accepts rebase. Prevents silent corruption from forced pushes.", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-14T17:40:21Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependencies": [{"issue_id": "bd-hlsw.4", "depends_on_id": "bd-hlsw", "type": "parent-child", "created_at": "2025-12-14T17:40:21Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-hlsw"}
{"id": "bd-s2t", "title": "wish: a 'continue' or similar cmd/flag which means alter last issue", "description": "so many time I create an issue and then have another thought: 'oh, before I did X and it crashed there was ZZZ happening' or 'actually that is P4 not P2'. It would be nice if when `bd {cmd}` is used without a {title} or {id} it just adds or updates the most recently touched issue.", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-08T13:46:38Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-4hn", "title": "wish: list & ready show issues as hierarchy tree", "description": "`bd ready` and `bd list` just show a flat list, and it's up to the reader to parse which ones are dependent or sub-issues of others. It would be much easier to understand if they were shown in a tree format", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-08T13:38:24Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-eyto", "title": "Time-dependent tests may be flaky near TTL boundary", "description": "Several tombstone merge tests use time.Now() to create test data: time.Now().Add(-24 * time.Hour), time.Now().Add(-60 * 24 * time.Hour), etc. While these work reliably in practice (24h vs 30d TTL has large margin), they could theoretically be flaky if: 1) Tests run slowly, 2) System clock changes during test, 3) TTL constants change. Recommendation: Consider using a fixed reference time or time injection for deterministic tests. Lower priority since current margin is large. Files: internal/merge/merge_test.go:1337-1338, 1352-1353, 1548-1549, 1590-1591", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-12-06T00:37:02Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-6rl", "title": "Merge3Way public API does not expose TTL parameter", "description": "The public Merge3Way() function in merge.go does not allow callers to configure the tombstone TTL. It hard-codes the default via merge3WayWithTTL(). While merge3WayWithTTL() exists, it is unexported (lowercase). This means the CLI and tests cannot configure TTL at merge time. Use cases: testing with different TTL values, per-repository TTL configuration, debugging with short TTL, supporting --ttl flag in bd merge command (mentioned in design doc bd-zvg). Recommendation: Export Merge3WayWithTTL (rename to uppercase). Files: internal/merge/merge.go:77, 292-298", "status": "closed", "priority": 3, "issue_type": "feature", "created_at": "2025-12-06T00:36:16Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-au0.10", "title": "Add global verbosity flags (--verbose, --quiet)", "description": "Add consistent verbosity controls across all commands.\n\n**Current state:**\n- bd init has --quiet flag\n- No other commands have verbosity controls\n- Debug output controlled by BD_VERBOSE env var\n\n**Proposal:**\nAdd persistent flags:\n- --verbose / -v: Enable debug output\n- --quiet / -q: Suppress non-essential output\n\n**Implementation:**\n- Add to rootCmd.PersistentFlags()\n- Replace BD_VERBOSE checks with flag checks\n- Standardize output levels:\n  * Quiet: Errors only\n  * Normal: Errors + success messages\n  * Verbose: Errors + success + debug info\n\n**Files to modify:**\n- cmd/bd/main.go (add flags)\n- internal/debug/debug.go (respect flags)\n- Update all commands to respect quiet mode\n\n**Testing:**\n- Verify --verbose shows debug output\n- Verify --quiet suppresses normal output\n- Ensure errors always show regardless of mode", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-11-22T02:08:22Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-au0.10", "depends_on_id": "bd-au0", "type": "parent-child", "created_at": "2025-11-22T02:08:22Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-au0"}
{"id": "bd-au0.9", "title": "Review and document rarely-used commands", "description": "Document use cases or consider deprecation for infrequently-used commands.\n\n**Commands to review:**\n1. bd rename-prefix - How often is this used? Document use cases\n2. bd detect-pollution - Consider integrating into bd validate\n3. bd migrate-hash-ids - One-time migration, keep but document as legacy\n\n**For each command:**\n- Document typical use cases\n- Add examples to help text\n- Consider if it should be a subcommand instead\n- Add deprecation warning if appropriate\n\n**Not changing:**\n- duplicates ‚úì (useful for data quality)\n- repair-deps ‚úì (useful for fixing broken refs)\n- restore ‚úì (critical for compacted issues)\n- compact ‚úì (performance feature)\n\n**Deliverable:**\n- Updated help text\n- Documentation in ADVANCED.md\n- Deprecation plan if needed", "status": "closed", "priority": 3, "issue_type": "task", "created_at": "2025-11-22T02:08:06Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependencies": [{"issue_id": "bd-au0.9", "depends_on_id": "bd-au0", "type": "parent-child", "created_at": "2025-11-22T02:08:06Z", "created_by": "mayor", "metadata": "{}"}], "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-au0"}
{"id": "bd-379", "title": "Implement `bd setup cursor` for Cursor IDE integration", "description": "Create a `bd setup cursor` command that integrates Beads workflow into Cursor IDE via .cursorrules file. Unlike Claude Code (which has hooks), Cursor uses a static rules file to provide context to its AI.", "status": "closed", "priority": 3, "issue_type": "feature", "created_at": "2025-11-12T07:32:22Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-mql4", "title": "getLocalSyncBranch silently ignores YAML parse errors", "description": "In autoimport.go:170-172, YAML parsing errors are silently ignored. If a user has malformed YAML in config.yaml, sync-branch will just silently be empty with no feedback.\n\nRecommendation: Add debug logging since this function is only called during auto-import, and debugging silent failures is painful.\n\nAdd: debug.Logf(\"Warning: failed to parse config.yaml: %v\", err)", "status": "closed", "priority": 4, "issue_type": "task", "created_at": "2025-12-07T10:03:44Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-abjw", "title": "Consider consolidating config.yaml parsing into shared utility", "description": "Multiple places parse config.yaml with custom structs:\n\n1. **autoimport.go:148** - `localConfig{SyncBranch}`\n2. **main.go:310** - strings.Contains for no-db (fragile, see bd-r6k2)\n3. **doctor.go:863** - strings.Contains for no-db (fragile, see bd-r6k2)\n4. **internal/config/config.go** - Uses viper (but caches at startup, problematic for tests)\n\nConsider creating a shared utility in `internal/configfile/` or extending the viper config:\n\n```go\n// internal/configfile/yaml.go\ntype YAMLConfig struct {\n    SyncBranch string `yaml:\"sync-branch\"`\n    NoDb       bool   `yaml:\"no-db\"`\n    IssuePrefix string `yaml:\"issue-prefix\"`\n    Author     string `yaml:\"author\"`\n}\n\nfunc LoadYAML(beadsDir string) (*YAMLConfig, error) {\n    // Parse config.yaml with proper YAML library\n}\n```\n\nBenefits:\n- Single source of truth for config.yaml structure\n- Proper YAML parsing everywhere\n- Easier to add new config fields\n\nTrade-off: May add complexity for simple one-off reads.", "status": "closed", "priority": 4, "issue_type": "task", "created_at": "2025-12-07T10:03:26Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-a0cp", "title": "Consider using types.Status in merge package for type safety", "description": "The merge package uses string for status comparison (e.g., result.Status == closed, issue.Status == StatusTombstone). The types package defines Status as a type alias with validation. While the merge package needs its own Issue struct for JSONL flexibility, it could import and use types.Status for constants to get compile-time type checking. Current code: if left == closed || right == closed. Could be: if left == string(types.StatusClosed). This is low priority since string comparison works correctly. Files: internal/merge/merge.go:44, 488, 501-521", "status": "closed", "priority": 4, "issue_type": "task", "created_at": "2025-12-06T00:37:11Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-nl2", "title": "No logging/debugging for tombstone resurrection events", "description": "Per the design document bd-zvg Open Question 1: Should resurrection log a warning? Recommendation was Yes. Currently, when an expired tombstone loses to a live issue (resurrection), there is no logging or debugging output. This makes it hard to understand why an issue reappeared. Recommendation: Add optional debug logging when resurrection occurs, e.g., Issue bd-abc resurrected (tombstone expired). Files: internal/merge/merge.go:359-366, 371-378, 400-405, 410-415", "status": "closed", "priority": 4, "issue_type": "feature", "created_at": "2025-12-06T00:36:52Z", "updated_at": "2026-02-26T20:45:26Z", "closed_at": "2026-02-26T20:45:26Z", "close_reason": "stale:auto-closed by reaper", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-5b6e", "title": "Add tests for helper functions (GetDirtyIssueHash, GetAllDependencyRecords, export hashes)", "description": "Several utility functions have 0% coverage:\n- GetDirtyIssueHash (dirty.go)\n- GetAllDependencyRecords (dependencies.go)\n- GetExportHash, SetExportHash, ClearAllExportHashes (hash.go)\n\nThese are lower priority but should have basic coverage.", "status": "closed", "priority": 4, "issue_type": "task", "created_at": "2025-11-02T05:40:59Z", "updated_at": "2026-02-27T02:56:52Z", "closed_at": "2026-02-27T02:56:52Z", "close_reason": "Stale aspirational items (Clown Show #21 cleanup)", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-0385z", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-0385z", "depends_on_id": "bd-wisp-3ljff", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0385z", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-046b8", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-046b8", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-046b8", "depends_on_id": "bd-wisp-rkwua", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-04r7", "title": "Merge: bd-7vk", "description": "branch: polecat/amber/bd-7vk@mm5l4dwf\ntarget: main\nsource_issue: bd-7vk\nrig: beads\nworker: amber\nagent_bead: bd-beads-polecat-amber\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T01:01:51Z", "created_by": "beads/polecats/amber", "updated_at": "2026-02-28T01:09:12Z", "closed_at": "2026-02-28T01:09:12Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-0f20f", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-0f20f", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0f20f", "depends_on_id": "bd-wisp-6e4wh", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-0is84", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-0is84", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0is84", "depends_on_id": "bd-wisp-q2ibb", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-0knlk", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 14: Quartz (bd-1x0) and obsidian (bd-39c) both completed gt done, nuked. Rig empty. 3 MRs submitted to merge queue this session.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:19:16Z", "closed_at": "2026-02-28T03:19:16Z", "close_reason": "patrol cycle complete: Patrol 14: Quartz (bd-1x0) and obsidian (bd-39c) both completed gt done, nuked. Rig empty. 3 MRs submitted to merge queue this session.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-0lyvr", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-0lyvr", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0lyvr", "depends_on_id": "bd-wisp-sg8cp", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-0oug7", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-0oug7", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0oug7", "depends_on_id": "bd-wisp-fdji0", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-12fn8", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-12fn8", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-12fn8", "depends_on_id": "bd-wisp-wlpa2", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-14jn3", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 13: Both polecats in test phase. Quartz dolt tests pass. Obsidian full suite running. All healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:16:02Z", "closed_at": "2026-02-28T03:16:02Z", "close_reason": "patrol cycle complete: Patrol 13: Both polecats in test phase. Quartz dolt tests pass. Obsidian full suite running. All healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1bq0u0", "title": "ü§ù HANDOFF: Witness patrol", "description": "10 patrols. Key events: (1) Furiosa idle, force stopped after gt-0cxc done. (2) Slit completed gt-2yx7 (dogs idle fix), MR gt-wisp-zi2q. (3) Rictus completed gt-r8m9 (dog agent beads), MR gt-wisp-pki2. (4) Nux DEFERRED gt-z6tn (skip docked rigs) - branch pushed to origin but NO MR submitted. RECOVERY_NEEDED sent to Mayor. Deacon alive, refinery running.", "status": "hooked", "priority": 1, "issue_type": "task", "assignee": "gastown/witness", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:04:10Z", "created_by": "gastown/witness", "updated_at": "2026-02-27T23:04:10Z", "labels": ["from:gastown/witness", "gt:message", "read"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1dbct", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-1dbct", "depends_on_id": "bd-wisp-93m8l", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1dbct", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-1g88n", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-1g88n", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1g88n", "depends_on_id": "bd-wisp-h7w5b", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-1hyhg", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-1hyhg", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1hyhg", "depends_on_id": "bd-wisp-xuh4a", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-1il8b", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-1il8b", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1il8b", "depends_on_id": "bd-wisp-pejdu", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-1lum8", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 9: 3 polecats active. jasper spawning. obsidian running tests. quartz near done (134.7s->42.1s). Archived MERGED jasper mail.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:49:09Z", "closed_at": "2026-02-28T03:49:09Z", "close_reason": "patrol cycle complete: Patrol 9: 3 polecats active. jasper spawning. obsidian running tests. quartz near done (134.7s->42.1s). Archived MERGED jasper mail.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1o19n", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-1o19n", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1o19n", "depends_on_id": "bd-wisp-kcyd5", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-1v7hm", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-1v7hm", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1v7hm", "depends_on_id": "bd-wisp-eimiy", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-1x487", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 10: 4 polecats active. quartz committed, running verification tests. obsidian waiting on bg test task ~9min (resource contention likely). jasper+onyx ramping up. Monitoring obsidian.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:52:14Z", "closed_at": "2026-02-28T03:52:14Z", "close_reason": "patrol cycle complete: Patrol 10: 4 polecats active. quartz committed, running verification tests. obsidian waiting on bg test task ~9min (resource contention likely). jasper+onyx ramping up. Monitoring obsidian.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-368p0", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-368p0", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-368p0", "depends_on_id": "bd-wisp-nz27a", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-3i027", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 2: Obsidian running tests on bd-39c (cherry-picked impl). Refinery+deacon healthy. No mail, no cleanup wisps, no gates, no swarm. Sleeping.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:23:08Z", "closed_at": "2026-02-28T03:23:08Z", "close_reason": "patrol cycle complete: Patrol 2: Obsidian running tests on bd-39c (cherry-picked impl). Refinery+deacon healthy. No mail, no cleanup wisps, no gates, no swarm. Sleeping.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3j6k", "title": "Merge: bd-bwk2", "description": "branch: polecat/opal/bd-bwk2@mm5ju9hc\ntarget: main\nsource_issue: bd-bwk2\nrig: beads\nworker: opal\nagent_bead: bd-beads-polecat-opal\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:22:29Z", "created_by": "beads/polecats/opal", "updated_at": "2026-02-28T00:25:17Z", "closed_at": "2026-02-28T00:25:17Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3ljff", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-3ljff", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3ljff", "depends_on_id": "bd-wisp-s0ahq", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-3m1dz", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-3m1dz", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3m1dz", "depends_on_id": "bd-wisp-nxmmj", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-3orq", "title": "Merge: bd-19i", "description": "branch: polecat/jasper/bd-19i@mm5kxwsz\ntarget: main\nsource_issue: bd-19i\nrig: beads\nworker: jasper\nagent_bead: bd-beads-polecat-jasper\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:31:54Z", "created_by": "beads/polecats/jasper", "updated_at": "2026-02-28T00:33:16Z", "closed_at": "2026-02-28T00:33:16Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3qcwb", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-3qcwb", "depends_on_id": "bd-wisp-e6395", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3qcwb", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-3tmpl", "title": "mol-refinery-patrol", "description": "Merge queue processor patrol loop.\n\nThe Refinery is the Engineer in the engine room. You process polecat branches, merging them to main one at a time with sequential rebasing.\n\n**The Scotty Test**: Before proceeding past any failure, ask yourself: \"Would Scotty walk past a warp core leak because it existed before his shift?\"\n\n## Merge Flow\n\nThe Refinery receives MERGE_READY mail from Witnesses when polecats complete work:\n\n```\nWitness                    Refinery                      Git\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGE_READY              ‚îÇ                           ‚îÇ\n   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (verify branch)                   ‚îÇ\n   ‚îÇ                          ‚îÇ fetch & rebase            ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (run tests)                       ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (if pass)                         ‚îÇ\n   ‚îÇ                          ‚îÇ merge & push              ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGED                   ‚îÇ                           ‚îÇ\n   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n```\n\nAfter successful merge, Refinery sends MERGED mail back to Witness so it can\ncomplete cleanup (nuke the polecat worktree).", "status": "open", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:51:09Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3ust", "title": "Merge: bd-tm2p", "description": "branch: polecat/jasper/bd-tm2p@mm5kl3tm\ntarget: main\nsource_issue: bd-tm2p\nrig: beads\nworker: jasper\nagent_bead: bd-beads-polecat-jasper\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:19:23Z", "created_by": "beads/polecats/jasper", "updated_at": "2026-02-28T00:23:03Z", "closed_at": "2026-02-28T00:23:03Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3vsh4", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-3vsh4", "depends_on_id": "bd-wisp-6naxp", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3vsh4", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-49drh", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-49drh", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-49drh", "depends_on_id": "bd-wisp-h1135", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-4dg3v", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-4dg3v", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-4dg3v", "depends_on_id": "bd-wisp-yzuzd", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-551qw", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-551qw", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-551qw", "depends_on_id": "bd-wisp-1g88n", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-5eap", "title": "Merge: bd-7vk", "description": "branch: polecat/quartz/bd-7vk@mm5mbz1e\ntarget: main\nsource_issue: bd-7vk\nrig: beads\nworker: quartz\nagent_bead: bd-beads-polecat-quartz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T01:13:14Z", "created_by": "beads/polecats/quartz", "updated_at": "2026-02-28T01:13:45Z", "closed_at": "2026-02-28T01:13:45Z", "close_reason": "rejected: Duplicate: bd-7vk fix already merged via amber (bd-wisp-04r7). Quartz branch conflicts with already-merged code in routed.go and agent_routing_test.go.", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-5i6i6", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-5i6i6", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-5i6i6", "depends_on_id": "bd-wisp-r0vwo", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-5mfp4", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:19:14Z", "updated_at": "2026-02-28T03:41:29Z", "closed_at": "2026-02-28T03:41:29Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-5mqch", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 8: Both polecats progressing well. Obsidian measuring test timings. Quartz identified t.Parallel() optimization, implementing. No issues.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:46:17Z", "closed_at": "2026-02-28T03:46:17Z", "close_reason": "patrol cycle complete: Patrol 8: Both polecats progressing well. Obsidian measuring test timings. Quartz identified t.Parallel() optimization, implementing. No issues.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-5p3nq", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-5p3nq", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-5qhko", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-5qhko", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-5qhko", "depends_on_id": "bd-wisp-63q3w", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-630gd", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-630gd", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-630gd", "depends_on_id": "bd-wisp-551qw", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-63q3w", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-63q3w", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-63q3w", "depends_on_id": "bd-wisp-o4xyo", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-69kuh", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged ‚Üí archive\n- HELP/Blocked that was handled ‚Üí archive\n- MERGE_READY where merge completed but archive was missed ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/<branch>`\n2. If branch gone, verify work is on main: `git log origin/main --oneline | grep \"<source_issue>\"`\n3. If work on main ‚Üí close MR with reason \"Merged (verified on main)\"\n4. If work NOT on main ‚Üí investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ‚â§3 active messages at end of cycle.\nKeep only: pending MRs in queue.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-69kuh", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-69kuh", "depends_on_id": "bd-wisp-ejny4", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-6awdl", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "hooked", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6e4wh", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-6e4wh", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-6e4wh", "depends_on_id": "bd-wisp-lc1nd", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-6hpnv", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-6hpnv", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-6hpnv", "depends_on_id": "bd-wisp-x2wyn", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-6i5cu", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-6i5cu", "depends_on_id": "bd-wisp-8nw7v", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-6i5cu", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-6naxp", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-6naxp", "depends_on_id": "bd-wisp-8h1fa", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-6naxp", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-6obg", "title": "Merge: bd-ee1", "description": "branch: polecat/topaz/bd-ee1@mm5juj3h\ntarget: main\nsource_issue: bd-ee1\nrig: beads\nworker: topaz\nagent_bead: bd-beads-polecat-topaz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:01:00Z", "created_by": "beads/polecats/topaz", "updated_at": "2026-02-28T00:11:17Z", "closed_at": "2026-02-28T00:11:17Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6rxpt", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-6rxpt", "depends_on_id": "bd-wisp-49drh", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-6rxpt", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-6s2aq", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-6s2aq", "depends_on_id": "bd-wisp-mp5hu", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-6s2aq", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-7ap84", "title": "Merge: bd-1x0", "description": "branch: polecat/quartz/bd-1x0@mm5q8g51\ntarget: main\nsource_issue: bd-1x0\nrig: beads\nworker: quartz\nagent_bead: bd-beads-polecat-quartz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:05:40Z", "created_by": "beads/polecats/quartz", "updated_at": "2026-02-28T03:19:52Z", "closed_at": "2026-02-28T03:19:52Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-7lasi", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-7lasi", "depends_on_id": "bd-wisp-0lyvr", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-7lasi", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-7r7dv", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-7r7dv", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-7r7dv", "depends_on_id": "bd-wisp-rj77x", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-84ky2", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-84ky2", "depends_on_id": "bd-wisp-a505e", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-84ky2", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-87qq8", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-87qq8", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-87qq8", "depends_on_id": "bd-wisp-q00af", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-8b0r", "title": "Merge: bd-tm2p", "description": "branch: polecat/jasper/bd-tm2p@mm5jtrhq\ntarget: main\nsource_issue: bd-tm2p\nrig: beads\nworker: jasper\nagent_bead: bd-beads-polecat-jasper\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:13:34Z", "created_by": "beads/polecats/jasper", "updated_at": "2026-02-28T00:18:00Z", "closed_at": "2026-02-28T00:18:00Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-8h1fa", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-8h1fa", "depends_on_id": "bd-wisp-5p3nq", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-8h1fa", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-8hnyi", "title": "Merge: bd-e5e", "description": "branch: polecat/obsidian/bd-e5e@mm5op584\ntarget: main\nsource_issue: bd-e5e\nrig: beads\nworker: obsidian\nagent_bead: bd-beads-polecat-obsidian\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T02:15:29Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T02:17:26Z", "closed_at": "2026-02-28T02:17:26Z", "close_reason": "Merged to main as 852bfe65 via fast-forward. Test passed.", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-8nw7v", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-8nw7v", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-93m8l", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-93m8l", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-93m8l", "depends_on_id": "bd-wisp-rssxo", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-951js", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-951js", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-951js", "depends_on_id": "bd-wisp-jbi5f", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-997ze", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-997ze", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-997ze", "depends_on_id": "bd-wisp-mujak", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-9v7jq", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-9v7jq", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-9xg5i", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-9xg5i", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-a2c6d", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-a2c6d", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-a2c6d", "depends_on_id": "bd-wisp-uwe76", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-a505e", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-a505e", "depends_on_id": "bd-wisp-3vsh4", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-a505e", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-acsd6", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 4: Obsidian tests completed (flaky failures passed on re-run), now in thinking phase 19m. Likely preparing MR. All systems nominal.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:38:40Z", "closed_at": "2026-02-28T03:38:40Z", "close_reason": "patrol cycle complete: Patrol 4: Obsidian tests completed (flaky failures passed on re-run), now in thinking phase 19m. Likely preparing MR. All systems nominal.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-addtz", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-addtz", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:30Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-addtz", "depends_on_id": "bd-wisp-xk9dw", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-as6bz", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-as6bz", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-as6bz", "depends_on_id": "bd-wisp-up624", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-auco6", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-auco6", "depends_on_id": "bd-wisp-3qcwb", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-auco6", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-bce10", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-bce10", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bce10", "depends_on_id": "bd-wisp-g3g17", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-bcozn", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-bcozn", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bcozn", "depends_on_id": "bd-wisp-tnwss", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-bfi94", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-bfi94", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bfi94", "depends_on_id": "bd-wisp-zmzcy", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-bicu6", "title": "Burn and respawn or loop", "description": "End of patrol cycle decision.\n\n**Step 1: Estimate remaining context**\n\nAsk yourself:\n- Have I processed many branches this cycle?\n- Is the conversation getting long?\n- Am I starting to lose track of earlier context?\n\nRule of thumb: If you've done 3+ merges or processed significant cleanup work,\nit's time for a fresh session.\n\n**Step 2: Decision tree**\n\nIf queue non-empty AND context LOW:\n- Squash this wisp to digest\n- Spawn fresh patrol wisp\n- Return to inbox-check\n\nIf queue empty OR context HIGH OR good stopping point:\n- Squash wisp with summary digest\n- Use `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nNext: [any notes for successor]\"\n```\n\n**Why gt handoff?**\n- Sends handoff mail to yourself with context\n- Respawns with fresh Claude instance\n- SessionStart hook runs gt prime\n- Successor picks up from your hook\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-bicu6", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-bicu6", "depends_on_id": "bd-wisp-69kuh", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-bo3db", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-bo3db", "depends_on_id": "bd-wisp-as6bz", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bo3db", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-bwghx", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 5: Obsidian tests passed, found branch divergence with origin/main (bd-1x0 merged). Investigating git state. Session healthy at 20m.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:40:28Z", "closed_at": "2026-02-28T03:40:28Z", "close_reason": "patrol cycle complete: Patrol 5: Obsidian tests passed, found branch divergence with origin/main (bd-1x0 merged). Investigating git state. Session healthy at 20m.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-c12lk", "title": "Merge and push to main", "description": "Merge to main and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Step 1: Merge and Push**\n```bash\ngit checkout main\ngit merge --ff-only temp\ngit push origin main\n```\n\n‚ö†Ô∏è **STOP HERE - DO NOT PROCEED UNTIL STEPS 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send <rig>/witness -s \"MERGED <polecat-name>\" -m \"Branch: <branch>\nIssue: <issue-id>\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Close MR Bead (REQUIRED - DO THIS IMMEDIATELY)**\n\n‚ö†Ô∏è **VERIFICATION BEFORE CLOSING**: Confirm the work is actually on main:\n```bash\n# Get the commit message/issue from the branch\ngit log origin/main --oneline | grep \"<issue-id>\"\n# OR verify the commit SHA is on main:\ngit branch --contains <commit-sha> | grep main\n```\n\nIf work is NOT on main, DO NOT close the MR bead. Investigate first.\n\n```bash\nbd close <mr-bead-id> --reason \"Merged to main at $(git rev-parse --short HEAD)\"\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep <polecat-name>\n```\n\n**VALIDATION**: The MR bead's source_issue should be a valid bead ID (gt-xxxxx),\nnot a branch name. If source_issue contains a branch name, flag for investigation.\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive <merge-ready-message-id>\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup (only after Steps 2-4 confirmed)**\n```bash\ngit branch -d temp\ngit push origin --delete <polecat-branch>\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] MR bead closed\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nMain has moved. Any remaining branches need rebasing on new baseline.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-c12lk", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-c12lk", "depends_on_id": "bd-wisp-vn4qe", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-c5fyv", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-c5fyv", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-c5fyv", "depends_on_id": "bd-wisp-5qhko", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-ck2u6", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-ck2u6", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ck2u6", "depends_on_id": "bd-wisp-r05bw", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-cufht", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 12: Both polecats approaching completion. Obsidian full tests running. Quartz regression tests pass, package tests running.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:13:59Z", "closed_at": "2026-02-28T03:13:59Z", "close_reason": "patrol cycle complete: Patrol 12: Both polecats approaching completion. Obsidian full tests running. Quartz regression tests pass, package tests running.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-cyqib", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-cyqib", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-dm5w3", "title": "Scan merge queue", "description": "Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list <rig>\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to context-check step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep <branch>\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close <mr-id> --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-dm5w3", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-dm5w3", "depends_on_id": "bd-wisp-y7xh7", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-dn631", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-dn631", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-dn631", "depends_on_id": "bd-wisp-dngtz", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-dngtz", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-dngtz", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-dngtz", "depends_on_id": "bd-wisp-pk7f8", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-e42xj", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-e42xj", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-e42xj", "depends_on_id": "bd-wisp-swt8z", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-e6395", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-e6395", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-e6395", "depends_on_id": "bd-wisp-r31hq", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-eimiy", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-eimiy", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-eimiy", "depends_on_id": "bd-wisp-xyx3x", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-ejbiw", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-ejbiw", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ejbiw", "depends_on_id": "bd-wisp-ofhjp", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-ejny4", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Write handoff summary\n- Prepare for burn/respawn\n\nIf context is LOW:\n- Can continue processing", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-ejny4", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-ejny4", "depends_on_id": "bd-wisp-owl10", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-en3kl", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-en3kl", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-en3kl", "depends_on_id": "bd-wisp-1hyhg", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-f3s6z", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-f3s6z", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-f7mez", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-f7mez", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-f7mez", "depends_on_id": "bd-wisp-9v7jq", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-fdji0", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-fdji0", "depends_on_id": "bd-wisp-1v7hm", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fdji0", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-fivid", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-fivid", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fivid", "depends_on_id": "bd-wisp-jx7oe", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-fjnr1", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-fjnr1", "depends_on_id": "bd-wisp-5i6i6", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fjnr1", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-fjq03", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-fjq03", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fjq03", "depends_on_id": "bd-wisp-pmh8t", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-fnrmr", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-fnrmr", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fnrmr", "depends_on_id": "bd-wisp-wc1hs", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-fpxxu", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-fpxxu", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-fvvyn", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-fvvyn", "depends_on_id": "bd-wisp-7r7dv", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fvvyn", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-g02na", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-g02na", "depends_on_id": "bd-wisp-1il8b", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-g02na", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-g3g17", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-g3g17", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-g3g17", "depends_on_id": "bd-wisp-j90jc", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-gntlc", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-gntlc", "depends_on_id": "bd-wisp-1dbct", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-gntlc", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-h1135", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-h1135", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-h7w5b", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-h7w5b", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-h7w5b", "depends_on_id": "bd-wisp-6hpnv", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-hda5k", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 7: Two polecats active - obsidian (bd-xmf) and quartz (bd-dgp) both healthy, exploring test optimization tasks. Refinery+deacon healthy. No issues.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:43:53Z", "closed_at": "2026-02-28T03:43:53Z", "close_reason": "patrol cycle complete: Patrol 7: Two polecats active - obsidian (bd-xmf) and quartz (bd-dgp) both healthy, exploring test optimization tasks. Refinery+deacon healthy. No issues.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-hispx", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "open", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:49:05Z", "updated_at": "2026-02-28T03:49:05Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-hlp72", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-hlp72", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-hlp72", "depends_on_id": "bd-wisp-uudcs", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-hwc1o", "title": "Check for more work", "description": "More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-hwc1o", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-hwc1o", "depends_on_id": "bd-wisp-c12lk", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-i27f2", "title": "Mechanical rebase", "description": "Pick next branch from queue. Attempt mechanical rebase on current main.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/<polecat-branch>\ngit rebase origin/main\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2>/dev/null && echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture main SHA for reference\nMAIN_SHA=$(git rev-parse origin/main)\nBRANCH_SHA=$(git rev-parse origin/<polecat-branch>)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: <original-issue-title>\" --description=\"## Conflict Resolution Required\n\nOriginal MR: <mr-bead-id>\nBranch: <polecat-branch>\nOriginal Issue: <issue-id>\nConflict with main at: ${MAIN_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on current main: git rebase origin/main\n3. Resolve conflicts\n4. Force push: git push -f origin <branch>\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-i27f2", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-i27f2", "depends_on_id": "bd-wisp-dm5w3", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-i39cl", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-i39cl", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-i39cl", "depends_on_id": "bd-wisp-swnin", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-ihokj", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-ihokj", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ihokj", "depends_on_id": "bd-wisp-fjnr1", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-irdhy", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 6: Processed POLECAT_DONE for obsidian (bd-39c already merged). Nuked clean obsidian. No active polecats. Refinery+deacon healthy. Inbox clean.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:42:13Z", "closed_at": "2026-02-28T03:42:13Z", "close_reason": "patrol cycle complete: Patrol 6: Processed POLECAT_DONE for obsidian (bd-39c already merged). Nuked clean obsidian. No active polecats. Refinery+deacon healthy. Inbox clean.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-iszw1", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-iszw1", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-iszw1", "depends_on_id": "bd-wisp-pv5ys", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-j4k01", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-j4k01", "depends_on_id": "bd-wisp-6s2aq", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-j4k01", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-j5pcn", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-j5pcn", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-j5pcn", "depends_on_id": "bd-wisp-r8ndg", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-j89t3", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-j89t3", "depends_on_id": "bd-wisp-i39cl", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-j89t3", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-j90jc", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-j90jc", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-j90jc", "depends_on_id": "bd-wisp-iszw1", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-jbi5f", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-jbi5f", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-jbi5f", "depends_on_id": "bd-wisp-t9094", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-jtdkj", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:43:05Z", "updated_at": "2026-02-28T03:54:41Z", "closed_at": "2026-02-28T03:54:41Z", "close_reason": "done", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-jx7oe", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-jx7oe", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-jx7oe", "depends_on_id": "bd-wisp-mw1xd", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-kcyd5", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-kcyd5", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-kcyd5", "depends_on_id": "bd-wisp-ywaiv", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-kf100", "title": "Merge: bd-dgp", "description": "branch: polecat/quartz/bd-dgp@mm5rzuut\ntarget: main\nsource_issue: bd-dgp\nrig: beads\nworker: quartz\nagent_bead: bd-beads-polecat-quartz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "open", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:54:36Z", "created_by": "beads/polecats/quartz", "updated_at": "2026-02-28T03:54:36Z", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-kj9g7", "title": "Merge: bd-1x0", "description": "branch: polecat/quartz/bd-1x0@mm5qp96g\ntarget: main\nsource_issue: bd-1x0\nrig: beads\nworker: quartz\nagent_bead: bd-beads-polecat-quartz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:16:28Z", "created_by": "beads/polecats/quartz", "updated_at": "2026-02-28T03:44:32Z", "closed_at": "2026-02-28T03:44:32Z", "close_reason": "rejected: Build failure: TestIsBlocked_CustomStatusBlocker declared twice in dependencies_extended_test.go (lines 589 and 799). Duplicate test function introduced by branch. Please rename the second test function and resubmit.", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-kle4v", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-kle4v", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-kle4v", "depends_on_id": "bd-wisp-a2c6d", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-kqfsv", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-kqfsv", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-kqfsv", "depends_on_id": "bd-wisp-r7sj4", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-l7ewl", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-l7ewl", "depends_on_id": "bd-wisp-368p0", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-l7ewl", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-lc1nd", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-lc1nd", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-lc1nd", "depends_on_id": "bd-wisp-en3kl", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-lqag7", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-lqag7", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-lqag7", "depends_on_id": "bd-wisp-kle4v", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-mlrd6", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 1: Nuked clean quartz (bd-1x0 no-op). Obsidian actively working on bd-39c (cherry-picked impl, running tests). Refinery+deacon healthy. No cleanup wisps, no swarm, no gates. Inbox clean.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:22:30Z", "closed_at": "2026-02-28T03:22:30Z", "close_reason": "patrol cycle complete: Patrol 1: Nuked clean quartz (bd-1x0 no-op). Obsidian actively working on bd-39c (cherry-picked impl, running tests). Refinery+deacon healthy. No cleanup wisps, no swarm, no gates. Inbox clean.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-mp5hu", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-mp5hu", "depends_on_id": "bd-wisp-f3s6z", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-mp5hu", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-mw1xd", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-mw1xd", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-n07ul", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 3: Obsidian still running tests on bd-39c (6m+ into go test). Session healthy. No mail, no incidents. All systems nominal.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:25:39Z", "closed_at": "2026-02-28T03:25:39Z", "close_reason": "patrol cycle complete: Patrol 3: Obsidian still running tests on bd-39c (6m+ into go test). Session healthy. No mail, no incidents. All systems nominal.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-nxmmj", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-nxmmj", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-nxmmj", "depends_on_id": "bd-wisp-umto6", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-nyoi9", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:19:27Z", "updated_at": "2026-02-28T03:21:18Z", "closed_at": "2026-02-28T03:21:18Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-nz27a", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-nz27a", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-o4xyo", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-o4xyo", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-o5aic", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 11: 4 polecats all healthy. quartz submitting MR (gt done). obsidian profiling bottlenecks. jasper+onyx in analysis/implementation phase. No issues.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:54:46Z", "closed_at": "2026-02-28T03:54:46Z", "close_reason": "patrol cycle complete: Patrol 11: 4 polecats all healthy. quartz submitting MR (gt done). obsidian profiling bottlenecks. jasper+onyx in analysis/implementation phase. No issues.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-o5wo6", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-o5wo6", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-oa5si", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-oa5si", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-oa5si", "depends_on_id": "bd-wisp-ejbiw", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-ofhjp", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-ofhjp", "depends_on_id": "bd-wisp-6i5cu", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ofhjp", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-ofry3", "title": "Merge: bd-39c", "description": "branch: polecat/obsidian/bd-39c@mm5qmpjo\ntarget: main\nsource_issue: bd-39c\nrig: beads\nworker: obsidian\nagent_bead: bd-beads-polecat-obsidian\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:16:32Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T03:48:12Z", "closed_at": "2026-02-28T03:48:12Z", "close_reason": "Merged (verified on main at 8e22d275)", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-os2oj", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-os2oj", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-os2oj", "depends_on_id": "bd-wisp-zus21", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-ovk0s", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-ovk0s", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:30Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-owl10", "title": "Generate handoff summary", "description": "Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate main is moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-owl10", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-owl10", "depends_on_id": "bd-wisp-hwc1o", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-p90sy", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-p90sy", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:30Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-p90sy", "depends_on_id": "bd-wisp-ovk0s", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-pejdu", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-pejdu", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-pejdu", "depends_on_id": "bd-wisp-bfi94", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-pk7f8", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-pk7f8", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-pk7f8", "depends_on_id": "bd-wisp-cyqib", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-pmh8t", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-pmh8t", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-pmh8t", "depends_on_id": "bd-wisp-bcozn", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-pv5ys", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-pv5ys", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-pv5ys", "depends_on_id": "bd-wisp-o5wo6", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-q00af", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-q00af", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-q00af", "depends_on_id": "bd-wisp-7lasi", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-q2ibb", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-q2ibb", "depends_on_id": "bd-wisp-84ky2", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-q2ibb", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-qpql4", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-qpql4", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-qpql4", "depends_on_id": "bd-wisp-thgr2", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-qr4h3", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-qr4h3", "depends_on_id": "bd-wisp-j89t3", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-qr4h3", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-qyxqj", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-qyxqj", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-qyxqj", "depends_on_id": "bd-wisp-qpql4", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-r05bw", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-r05bw", "depends_on_id": "bd-wisp-auco6", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-r05bw", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-r0vwo", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-r0vwo", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-r0vwo", "depends_on_id": "bd-wisp-gntlc", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-r31hq", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-r31hq", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-r31hq", "depends_on_id": "bd-wisp-wy25a", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-r7sj4", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-r7sj4", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-r8ndg", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-r8ndg", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-r8ndg", "depends_on_id": "bd-wisp-xg0i6", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-riycn", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-riycn", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-riycn", "depends_on_id": "bd-wisp-g02na", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-rj77x", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-rj77x", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-rj77x", "depends_on_id": "bd-wisp-w80rj", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-rssxo", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:25:39Z", "updated_at": "2026-02-28T03:25:39Z", "dependencies": [{"issue_id": "bd-wisp-rssxo", "depends_on_id": "bd-wisp-acsd6", "type": "parent-child", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-rssxo", "depends_on_id": "bd-wisp-kqfsv", "type": "blocks", "created_at": "2026-02-27T19:25:39Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-acsd6"}
{"id": "bd-wisp-s0ahq", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-s0ahq", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-s0ahq", "depends_on_id": "bd-wisp-fpxxu", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-sg8cp", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-sg8cp", "depends_on_id": "bd-wisp-12fn8", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-sg8cp", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-sn6r", "title": "Merge: bd-74w1", "description": "branch: polecat/obsidian/bd-74w1@mm5jteku\ntarget: main\nsource_issue: bd-74w1\nrig: beads\nworker: obsidian\nagent_bead: bd-beads-polecat-obsidian\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 1, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:59:29Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T00:10:49Z", "closed_at": "2026-02-28T00:10:49Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-swnin", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-swnin", "depends_on_id": "bd-wisp-hlp72", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-swnin", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-swt8z", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:19:16Z", "updated_at": "2026-02-28T03:19:16Z", "dependencies": [{"issue_id": "bd-wisp-swt8z", "depends_on_id": "bd-wisp-0is84", "type": "blocks", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-swt8z", "depends_on_id": "bd-wisp-mlrd6", "type": "parent-child", "created_at": "2026-02-27T19:19:16Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-mlrd6"}
{"id": "bd-wisp-t5dmm", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-t5dmm", "depends_on_id": "bd-wisp-0f20f", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-t5dmm", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-t7gxl", "title": "Run test suite", "description": "Run the test suite.\n\n```bash\ngo test ./...\n```\n\nTrack results: pass count, fail count, specific failures.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-t7gxl", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-t7gxl", "depends_on_id": "bd-wisp-i27f2", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-t9094", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-t9094", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-t9kb3", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-t9kb3", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-t9kb3", "depends_on_id": "bd-wisp-wkgny", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-thgr2", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-thgr2", "depends_on_id": "bd-wisp-951js", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-thgr2", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-tnwss", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-tnwss", "depends_on_id": "bd-wisp-0385z", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-tnwss", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-txbi2", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-txbi2", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-txbi2", "depends_on_id": "bd-wisp-uqrh9", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-ucaoi", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-ucaoi", "depends_on_id": "bd-wisp-bo3db", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ucaoi", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-ul8wo", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-ul8wo", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ul8wo", "depends_on_id": "bd-wisp-oa5si", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-umto6", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-umto6", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-umto6", "depends_on_id": "bd-wisp-f7mez", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-up624", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:42:13Z", "updated_at": "2026-02-28T03:42:13Z", "dependencies": [{"issue_id": "bd-wisp-up624", "depends_on_id": "bd-wisp-hda5k", "type": "parent-child", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-up624", "depends_on_id": "bd-wisp-qyxqj", "type": "blocks", "created_at": "2026-02-27T19:42:13Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-hda5k"}
{"id": "bd-wisp-uq6fx", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "open", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:42:48Z", "updated_at": "2026-02-28T03:42:48Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-uqrh9", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-uqrh9", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-uqrh9", "depends_on_id": "bd-wisp-lqag7", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-uudcs", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:52:15Z", "updated_at": "2026-02-28T03:52:15Z", "dependencies": [{"issue_id": "bd-wisp-uudcs", "depends_on_id": "bd-wisp-j4k01", "type": "blocks", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-uudcs", "depends_on_id": "bd-wisp-o5aic", "type": "parent-child", "created_at": "2026-02-27T19:52:14Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-o5aic"}
{"id": "bd-wisp-uwe76", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-uwe76", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:30Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-uwe76", "depends_on_id": "bd-wisp-addtz", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-vl926", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-vl926", "depends_on_id": "bd-wisp-l7ewl", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-vl926", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-vn4qe", "title": "Handle test failures", "description": "**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf tests PASSED: This step auto-completes. Proceed to merge.\n\nIf tests FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on main?\n2. If branch caused it:\n   - Abort merge\n   - Notify polecat: \"Tests failing. Please fix and resubmit.\"\n   - Skip to loop-check\n3. If pre-existing on main:\n   - File a bead: bd create --type=bug --priority=1 --title=\"...\"\n   - FORBIDDEN: Writing code to fix test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- Tests passing, OR\n- Bead filed for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-vn4qe", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-vn4qe", "depends_on_id": "bd-wisp-t7gxl", "type": "blocks", "created_at": "2026-02-27T19:48:46Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-vnssv", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "open", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:48:47Z", "updated_at": "2026-02-28T03:48:47Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-vvd9q", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-vvd9q", "depends_on_id": "bd-wisp-bce10", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-vvd9q", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-w80rj", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-w80rj", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-w80rj", "depends_on_id": "bd-wisp-vl926", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-wc1hs", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-wc1hs", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-wc1hs", "depends_on_id": "bd-wisp-ul8wo", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-wkgny", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:38:40Z", "updated_at": "2026-02-28T03:38:40Z", "dependencies": [{"issue_id": "bd-wisp-wkgny", "depends_on_id": "bd-wisp-bwghx", "type": "parent-child", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-wkgny", "depends_on_id": "bd-wisp-fnrmr", "type": "blocks", "created_at": "2026-02-27T19:38:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-bwghx"}
{"id": "bd-wisp-wlpa2", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:43:54Z", "updated_at": "2026-02-28T03:43:54Z", "dependencies": [{"issue_id": "bd-wisp-wlpa2", "depends_on_id": "bd-wisp-5mqch", "type": "parent-child", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-wlpa2", "depends_on_id": "bd-wisp-6rxpt", "type": "blocks", "created_at": "2026-02-27T19:43:53Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5mqch"}
{"id": "bd-wisp-wy25a", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-wy25a", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-x2wyn", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:16:02Z", "updated_at": "2026-02-28T03:16:02Z", "dependencies": [{"issue_id": "bd-wisp-x2wyn", "depends_on_id": "bd-wisp-0knlk", "type": "parent-child", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-x2wyn", "depends_on_id": "bd-wisp-c5fyv", "type": "blocks", "created_at": "2026-02-27T19:16:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-0knlk"}
{"id": "bd-wisp-xg0i6", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:40:28Z", "updated_at": "2026-02-28T03:40:28Z", "dependencies": [{"issue_id": "bd-wisp-xg0i6", "depends_on_id": "bd-wisp-ck2u6", "type": "blocks", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xg0i6", "depends_on_id": "bd-wisp-irdhy", "type": "parent-child", "created_at": "2026-02-27T19:40:28Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-irdhy"}
{"id": "bd-wisp-xk9dw", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:22:31Z", "updated_at": "2026-02-28T03:22:31Z", "dependencies": [{"issue_id": "bd-wisp-xk9dw", "depends_on_id": "bd-wisp-3i027", "type": "parent-child", "created_at": "2026-02-27T19:22:30Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xk9dw", "depends_on_id": "bd-wisp-p90sy", "type": "blocks", "created_at": "2026-02-27T19:22:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3i027"}
{"id": "bd-wisp-xuh4a", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:13:59Z", "updated_at": "2026-02-28T03:13:59Z", "dependencies": [{"issue_id": "bd-wisp-xuh4a", "depends_on_id": "bd-wisp-14jn3", "type": "parent-child", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xuh4a", "depends_on_id": "bd-wisp-fivid", "type": "blocks", "created_at": "2026-02-27T19:13:59Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-14jn3"}
{"id": "bd-wisp-xyx3x", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:49:10Z", "updated_at": "2026-02-28T03:49:10Z", "dependencies": [{"issue_id": "bd-wisp-xyx3x", "depends_on_id": "bd-wisp-1x487", "type": "parent-child", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xyx3x", "depends_on_id": "bd-wisp-3m1dz", "type": "blocks", "created_at": "2026-02-27T19:49:09Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1x487"}
{"id": "bd-wisp-y7xh7", "title": "Check refinery mail", "description": "Check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: <branch>\n# Issue: <issue-id>\n# Polecat: <polecat-name>\n# MR: <mr-bead-id>\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive <message-id>\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:48:46Z", "updated_at": "2026-02-28T03:48:46Z", "dependencies": [{"issue_id": "bd-wisp-y7xh7", "depends_on_id": "bd-wisp-3tmpl", "type": "parent-child", "created_at": "2026-02-27T19:48:45Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3tmpl"}
{"id": "bd-wisp-ywaiv", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:12:35Z", "updated_at": "2026-02-28T03:12:35Z", "dependencies": [{"issue_id": "bd-wisp-ywaiv", "depends_on_id": "bd-wisp-cufht", "type": "parent-child", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ywaiv", "depends_on_id": "bd-wisp-vvd9q", "type": "blocks", "created_at": "2026-02-27T19:12:35Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-cufht"}
{"id": "bd-wisp-yzuzd", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:54:47Z", "updated_at": "2026-02-28T03:54:47Z", "dependencies": [{"issue_id": "bd-wisp-yzuzd", "depends_on_id": "bd-wisp-6awdl", "type": "parent-child", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-yzuzd", "depends_on_id": "bd-wisp-fjq03", "type": "blocks", "created_at": "2026-02-27T19:54:47Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-6awdl"}
{"id": "bd-wisp-zmzcy", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:46:17Z", "updated_at": "2026-02-28T03:46:17Z", "dependencies": [{"issue_id": "bd-wisp-zmzcy", "depends_on_id": "bd-wisp-1lum8", "type": "parent-child", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-zmzcy", "depends_on_id": "bd-wisp-dn631", "type": "blocks", "created_at": "2026-02-27T19:46:17Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-1lum8"}
{"id": "bd-wisp-zus21", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:23:08Z", "updated_at": "2026-02-28T03:23:08Z", "dependencies": [{"issue_id": "bd-wisp-zus21", "depends_on_id": "bd-wisp-fvvyn", "type": "blocks", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-zus21", "depends_on_id": "bd-wisp-n07ul", "type": "parent-child", "created_at": "2026-02-27T19:23:08Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n07ul"}
{"id": "bd-wisp-0354b", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:49:55Z", "closed_at": "2026-02-28T01:49:55Z", "close_reason": "No active polecats", "dependencies": [{"issue_id": "bd-wisp-0354b", "depends_on_id": "bd-wisp-4erf3", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0354b", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-08988", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:49:17Z", "closed_at": "2026-02-28T01:49:17Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-08988", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-0a7v6", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-0a7v6", "depends_on_id": "bd-wisp-plk6j", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0a7v6", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-0fzjd", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-0fzjd", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0fzjd", "depends_on_id": "bd-wisp-adodu", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-0g8fy", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:53:39Z", "updated_at": "2026-02-28T03:04:47Z", "closed_at": "2026-02-28T03:04:47Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-0my45", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 1: No polecats active. Refinery+Deacon healthy. Orphaned wisp bd-wisp-5xon7z nudged to deacon. Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:23:21Z", "updated_at": "2026-02-28T02:23:38Z", "closed_at": "2026-02-28T02:23:38Z", "close_reason": "patrol cycle complete: Patrol 1: No polecats active. Refinery+Deacon healthy. Orphaned wisp bd-wisp-5xon7z nudged to deacon. Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-0nnvm", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 2: Rig idle. No polecats. Deacon alive. Refinery session up but no pending MRs. Orphaned wisp bd-wisp-5xon7z noted (not ours).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:23:38Z", "updated_at": "2026-02-28T02:35:29Z", "closed_at": "2026-02-28T02:35:29Z", "close_reason": "patrol cycle complete: Patrol 2: Rig idle. No polecats. Deacon alive. Refinery session up but no pending MRs. Orphaned wisp bd-wisp-5xon7z noted (not ours).", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-11hc8", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 5: LIFECYCLE:Shutdown obsidian processed. Code review complete (7 findings filed). Nuked clean. Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:50:02Z", "closed_at": "2026-02-28T02:50:02Z", "close_reason": "patrol cycle complete: Patrol 5: LIFECYCLE:Shutdown obsidian processed. Code review complete (7 findings filed). Nuked clean. Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1ac87", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:57:34Z", "closed_at": "2026-02-28T01:57:34Z", "close_reason": "No mail", "dependencies": [{"issue_id": "bd-wisp-1ac87", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-1c5i3", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-1c5i3", "depends_on_id": "bd-wisp-ichr3", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1c5i3", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-1fggw", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-1fggw", "depends_on_id": "bd-wisp-bb2sw", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1fggw", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-1qu1b", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-1qu1b", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-1qu1b", "depends_on_id": "bd-wisp-l03r8", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-2bhbw", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-2bhbw", "depends_on_id": "bd-wisp-2sxnk", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-2bhbw", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-2hmvg", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:01Z", "closed_at": "2026-02-28T01:55:01Z", "close_reason": "No polecats", "dependencies": [{"issue_id": "bd-wisp-2hmvg", "depends_on_id": "bd-wisp-tqgim", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-2hmvg", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-2l7gw", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-2l7gw", "depends_on_id": "bd-wisp-1c5i3", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-2l7gw", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-2oss8", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-2oss8", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-2oss8", "depends_on_id": "bd-wisp-i9plj", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-2sxnk", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-2sxnk", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-2sxnk", "depends_on_id": "bd-wisp-917ey", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-37lxk", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:01:24Z", "updated_at": "2026-02-28T02:02:08Z", "closed_at": "2026-02-28T02:02:08Z", "close_reason": "Manual patrol complete, mol instantiation broken", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3ai4y", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-3ai4y", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-3dxkq", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:53:25Z", "closed_at": "2026-02-28T01:53:25Z", "close_reason": "Patrol 2 complete, rig idle", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3f43q", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:58:23Z", "closed_at": "2026-02-28T01:58:23Z", "close_reason": "Context manageable, patrol 4", "dependencies": [{"issue_id": "bd-wisp-3f43q", "depends_on_id": "bd-wisp-enocs", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3f43q", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-3lzfe", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-3lzfe", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3lzfe", "depends_on_id": "bd-wisp-zrebm", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-3n1j4", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 10: Obsidian and quartz both actively coding. Tests running. All systems healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:11:04Z", "closed_at": "2026-02-28T03:11:04Z", "close_reason": "patrol cycle complete: Patrol 10: Obsidian and quartz both actively coding. Tests running. All systems healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3r9bi", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-3r9bi", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3r9bi", "depends_on_id": "bd-wisp-t58ws", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-44599", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-44599", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-44599", "depends_on_id": "bd-wisp-llvpr", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-46umv", "title": "Generate handoff summary", "description": "Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate main is moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:39Z", "updated_at": "2026-02-28T01:50:42Z", "closed_at": "2026-02-28T01:50:42Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-46umv", "depends_on_id": "bd-wisp-df19i", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-46umv", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-47fu4", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:22:00Z", "updated_at": "2026-02-28T02:22:26Z", "closed_at": "2026-02-28T02:22:26Z", "close_reason": "Old patrol wisp from previous witness session", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-48086", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-48086", "depends_on_id": "bd-wisp-slckl", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-48086", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-4bsdt", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:52:18Z", "closed_at": "2026-02-28T01:52:18Z", "close_reason": "No cleanup wisps", "dependencies": [{"issue_id": "bd-wisp-4bsdt", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-4bsdt", "depends_on_id": "bd-wisp-whkx2", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-4erf3", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:49:47Z", "closed_at": "2026-02-28T01:49:47Z", "close_reason": "Refinery running, no pending MRs", "dependencies": [{"issue_id": "bd-wisp-4erf3", "depends_on_id": "bd-wisp-ar089", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-4erf3", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-4qdfv", "title": "mol-refinery-patrol", "description": "Patrol report: Empty queue, clean cycle. No merges needed.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T02:04:12Z", "updated_at": "2026-02-28T02:22:31Z", "closed_at": "2026-02-28T02:22:31Z", "close_reason": "patrol cycle complete: Empty queue, clean cycle. No merges needed.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-4y7xj", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:50:16Z", "closed_at": "2026-02-28T01:50:16Z", "close_reason": "No active swarms", "dependencies": [{"issue_id": "bd-wisp-4y7xj", "depends_on_id": "bd-wisp-7eadz", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-4y7xj", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-56l5k", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-56l5k", "depends_on_id": "bd-wisp-a44we", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-56l5k", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-571lx", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-571lx", "depends_on_id": "bd-wisp-tid7s", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-571lx", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-5cuju", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-5cuju", "depends_on_id": "bd-wisp-2l7gw", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-5cuju", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-5v43w", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-5v43w", "depends_on_id": "bd-wisp-rcp8a", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-5v43w", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-5whic", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-5whic", "depends_on_id": "bd-wisp-7tv2w", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-5whic", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-5xqov", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:57:58Z", "closed_at": "2026-02-28T01:57:58Z", "close_reason": "No polecats", "dependencies": [{"issue_id": "bd-wisp-5xqov", "depends_on_id": "bd-wisp-fakfx", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-5xqov", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-5xt5x", "title": "Merge: bd-tcn", "description": "branch: polecat/jasper/bd-tcn@mm5qa8ud\ntarget: main\nsource_issue: bd-tcn\nrig: beads\nworker: jasper\nagent_bead: bd-beads-polecat-jasper\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:06:17Z", "created_by": "beads/polecats/jasper", "updated_at": "2026-02-28T03:47:32Z", "closed_at": "2026-02-28T03:47:32Z", "close_reason": "Merged to main at 4394fdc4", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6334e", "title": "mol-refinery-patrol", "description": "Patrol report: Patrol cycle complete: merge queue empty, inbox clear, no integration branches pending. Session healthy (RSS 3MB). Looping.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T02:00:13Z", "updated_at": "2026-02-28T02:04:12Z", "closed_at": "2026-02-28T02:04:12Z", "close_reason": "patrol cycle complete: Patrol cycle complete: merge queue empty, inbox clear, no integration branches pending. Session healthy (RSS 3MB). Looping.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6uazx", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-6uazx", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-6xids", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-6xids", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-6xids", "depends_on_id": "bd-wisp-ebict", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-71vcf", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:50:39Z", "closed_at": "2026-02-28T01:50:39Z", "close_reason": "Inbox already clean (0 messages)", "dependencies": [{"issue_id": "bd-wisp-71vcf", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-71vcf", "depends_on_id": "bd-wisp-wimlq", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-789i5", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 10: Rig idle. No polecats, no mail. Refinery+Deacon healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:05:34Z", "updated_at": "2026-02-28T02:06:55Z", "closed_at": "2026-02-28T02:06:55Z", "close_reason": "patrol cycle complete: Patrol 10: Rig idle. No polecats, no mail. Refinery+Deacon healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-7bt8t", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:28Z", "closed_at": "2026-02-28T01:55:28Z", "close_reason": "Deacon alive", "dependencies": [{"issue_id": "bd-wisp-7bt8t", "depends_on_id": "bd-wisp-vi3gh", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-7bt8t", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-7btpf", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:58:02Z", "closed_at": "2026-02-28T01:58:02Z", "close_reason": "No timer gates", "dependencies": [{"issue_id": "bd-wisp-7btpf", "depends_on_id": "bd-wisp-5xqov", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-7btpf", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-7eadz", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:50:05Z", "closed_at": "2026-02-28T01:50:05Z", "close_reason": "No timer gates found", "dependencies": [{"issue_id": "bd-wisp-7eadz", "depends_on_id": "bd-wisp-0354b", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-7eadz", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-7m3d2", "title": "Mechanical rebase", "description": "Pick next branch from queue. Attempt mechanical rebase on current main.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/<polecat-branch>\ngit rebase origin/main\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2>/dev/null && echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture main SHA for reference\nMAIN_SHA=$(git rev-parse origin/main)\nBRANCH_SHA=$(git rev-parse origin/<polecat-branch>)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: <original-issue-title>\" --description=\"## Conflict Resolution Required\n\nOriginal MR: <mr-bead-id>\nBranch: <polecat-branch>\nOriginal Issue: <issue-id>\nConflict with main at: ${MAIN_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on current main: git rebase origin/main\n3. Resolve conflicts\n4. Force push: git push -f origin <branch>\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:38Z", "updated_at": "2026-02-28T01:50:06Z", "closed_at": "2026-02-28T01:50:06Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-7m3d2", "depends_on_id": "bd-wisp-b0pgy", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-7m3d2", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-7tv2w", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-7tv2w", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-7zux3", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 9: Rig idle. Cleaned 20 orphaned step wisps from 2 old patrols. Obsidian orphaned state reported to Deacon. Refinery+Deacon healthy. No polecats, no swarm, no timer gates.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:03:22Z", "updated_at": "2026-02-28T02:05:34Z", "closed_at": "2026-02-28T02:05:34Z", "close_reason": "patrol cycle complete: Patrol 9: Rig idle. Cleaned 20 orphaned step wisps from 2 old patrols. Obsidian orphaned state reported to Deacon. Refinery+Deacon healthy. No polecats, no swarm, no timer gates.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-8c7rf", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:01:03Z", "updated_at": "2026-02-28T02:01:20Z", "closed_at": "2026-02-28T02:01:20Z", "close_reason": "Steps not instantiating", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-8hbrk", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:53:54Z", "updated_at": "2026-02-28T02:55:06Z", "closed_at": "2026-02-28T02:55:06Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-8qccv", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-8qccv", "depends_on_id": "bd-wisp-dte3m", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-8qccv", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-8sqxn", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 3: No polecats. Refinery+Deacon alive. Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:21:03Z", "updated_at": "2026-02-28T02:22:00Z", "closed_at": "2026-02-28T02:22:00Z", "close_reason": "patrol cycle complete: Patrol 3: No polecats. Refinery+Deacon alive. Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-908ng", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:55:06Z", "updated_at": "2026-02-28T03:08:32Z", "closed_at": "2026-02-28T03:08:32Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-917ey", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-917ey", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-917ey", "depends_on_id": "bd-wisp-44599", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-9582b", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:00:42Z", "updated_at": "2026-02-28T02:01:00Z", "closed_at": "2026-02-28T02:01:00Z", "close_reason": "Stale orphan from concurrent session", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-97xcl", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 12: Rig idle. No polecats, no mail. Deacon+Refinery healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:08:13Z", "updated_at": "2026-02-28T02:09:57Z", "closed_at": "2026-02-28T02:09:57Z", "close_reason": "patrol cycle complete: Patrol 12: Rig idle. No polecats, no mail. Deacon+Refinery healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-9uqhn", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:53:13Z", "closed_at": "2026-02-28T01:53:13Z", "close_reason": "Context manageable, patrol 2", "dependencies": [{"issue_id": "bd-wisp-9uqhn", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-9uqhn", "depends_on_id": "bd-wisp-xoqcz", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-a44we", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-a44we", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-a44we", "depends_on_id": "bd-wisp-wth90", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-a4hs8", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:53:25Z", "closed_at": "2026-02-28T01:53:25Z", "close_reason": "Context low, looping", "dependencies": [{"issue_id": "bd-wisp-a4hs8", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-a4hs8", "depends_on_id": "bd-wisp-9uqhn", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-a7kx6", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:04:48Z", "updated_at": "2026-02-28T03:19:14Z", "closed_at": "2026-02-28T03:19:14Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-adodu", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-adodu", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-adodu", "depends_on_id": "bd-wisp-jhni3", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-ap0pl", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-ap0pl", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ap0pl", "depends_on_id": "bd-wisp-fwzrb", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-b0pgy", "title": "Scan merge queue", "description": "Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list <rig>\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to context-check step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep <branch>\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close <mr-id> --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:38Z", "updated_at": "2026-02-28T01:50:01Z", "closed_at": "2026-02-28T01:50:01Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-b0pgy", "depends_on_id": "bd-wisp-cgwxj", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-b0pgy", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-b0z0j", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:52:26Z", "closed_at": "2026-02-28T01:52:26Z", "close_reason": "Refinery running, no MRs", "dependencies": [{"issue_id": "bd-wisp-b0z0j", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-b0z0j", "depends_on_id": "bd-wisp-4bsdt", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-b3bk7", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-b3bk7", "depends_on_id": "bd-wisp-571lx", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-b3bk7", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-bb2sw", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-bb2sw", "depends_on_id": "bd-wisp-gucxa", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bb2sw", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-bk75t", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:52:41Z", "closed_at": "2026-02-28T01:52:41Z", "close_reason": "No timer gates", "dependencies": [{"issue_id": "bd-wisp-bk75t", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bk75t", "depends_on_id": "bd-wisp-h6w3r", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-bream", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-bream", "depends_on_id": "bd-wisp-endjr", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bream", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-bu1xt", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:58:06Z", "closed_at": "2026-02-28T01:58:06Z", "close_reason": "No swarms", "dependencies": [{"issue_id": "bd-wisp-bu1xt", "depends_on_id": "bd-wisp-7btpf", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bu1xt", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-bzj74", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:46Z", "updated_at": "2026-02-28T02:53:46Z", "dependencies": [{"issue_id": "bd-wisp-bzj74", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-c2nxw", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-c2nxw", "depends_on_id": "bd-wisp-5cuju", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-c2nxw", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-c4isl", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 11: Obsidian running full tests on bd-39c. Quartz writing regression tests for bd-1x0. Both near completion. All healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:12:35Z", "closed_at": "2026-02-28T03:12:35Z", "close_reason": "patrol cycle complete: Patrol 11: Obsidian running full tests on bd-39c. Quartz writing regression tests for bd-1x0. Both near completion. All healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-c9el4", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-c9el4", "depends_on_id": "bd-wisp-9xg5i", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-c9el4", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-c9hox", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-c9hox", "depends_on_id": "bd-wisp-bream", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-c9hox", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-camem", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:58:33Z", "closed_at": "2026-02-28T01:58:33Z", "close_reason": "Context low, looping with 120s backoff", "dependencies": [{"issue_id": "bd-wisp-camem", "depends_on_id": "bd-wisp-3f43q", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-camem", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-cejfg", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-cejfg", "depends_on_id": "bd-wisp-mv6bo", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-cejfg", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-cgwxj", "title": "Check refinery mail", "description": "Check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: <branch>\n# Issue: <issue-id>\n# Polecat: <polecat-name>\n# MR: <mr-bead-id>\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive <message-id>\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:38Z", "updated_at": "2026-02-28T01:49:51Z", "closed_at": "2026-02-28T01:49:51Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-cgwxj", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-cwnlc", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-cwnlc", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-cwnlc", "depends_on_id": "bd-wisp-xpk8r", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-czuvg", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 1: Nuked completed obsidian polecat (bd-e5e done, in merge queue). No active polecats. Refinery+Deacon alive. Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:19:37Z", "updated_at": "2026-02-28T02:19:44Z", "closed_at": "2026-02-28T02:19:44Z", "close_reason": "patrol cycle complete: Patrol 1: Nuked completed obsidian polecat (bd-e5e done, in merge queue). No active polecats. Refinery+Deacon alive. Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-d4fp4", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-d4fp4", "depends_on_id": "bd-wisp-lc09d", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-d4fp4", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-dbpt8", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-dbpt8", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-dbpt8", "depends_on_id": "bd-wisp-rb7o8", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-df19i", "title": "Check for more work", "description": "More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:39Z", "updated_at": "2026-02-28T01:50:34Z", "closed_at": "2026-02-28T01:50:34Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-df19i", "depends_on_id": "bd-wisp-kvwuy", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-df19i", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-dk2c2", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-dk2c2", "depends_on_id": "bd-wisp-iawrh", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-dk2c2", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-dl0c7", "title": "mol-refinery-patrol", "description": "Patrol report: Patrol cycle: queue empty, no merges to process. Main current. Session healthy, context low.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T01:58:53Z", "updated_at": "2026-02-28T01:59:53Z", "closed_at": "2026-02-28T01:59:53Z", "close_reason": "patrol cycle complete: Patrol cycle: queue empty, no merges to process. Main current. Session healthy, context low.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-dmv91", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 15: Obsidian completed bd-e5e, submitted to merge queue. Rig idle. Handoff threshold (15) reached.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:14:49Z", "updated_at": "2026-02-28T02:17:18Z", "closed_at": "2026-02-28T02:17:18Z", "close_reason": "patrol cycle complete: Patrol 15: Obsidian completed bd-e5e, submitted to merge queue. Rig idle. Handoff threshold (15) reached.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-dqu06", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-dqu06", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-dqu06", "depends_on_id": "bd-wisp-c9el4", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-dte3m", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-dte3m", "depends_on_id": "bd-wisp-fwzsx", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-dte3m", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-du8l9", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-du8l9", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-du8l9", "depends_on_id": "bd-wisp-x3fzf", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-dvqma", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:17:19Z", "updated_at": "2026-02-28T02:18:34Z", "closed_at": "2026-02-28T02:18:34Z", "close_reason": "Previous session patrol wisp, replaced by bd-wisp-igiw6", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-ebict", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-ebict", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ebict", "depends_on_id": "bd-wisp-yi19c", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-endjr", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-endjr", "depends_on_id": "bd-wisp-cwnlc", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-endjr", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-enocs", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:58:19Z", "closed_at": "2026-02-28T01:58:19Z", "close_reason": "Inbox clean", "dependencies": [{"issue_id": "bd-wisp-enocs", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-enocs", "depends_on_id": "bd-wisp-xcvrt", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-fakfx", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:57:55Z", "closed_at": "2026-02-28T01:57:55Z", "close_reason": "Refinery running", "dependencies": [{"issue_id": "bd-wisp-fakfx", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fakfx", "depends_on_id": "bd-wisp-xj4a2", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-fly1i", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 9: Archived 5 stale LIFECYCLE mails. Nuked jasper (bd-tcn done, MR submitted). Obsidian/quartz actively coding. Refinery+deacon healthy. Inbox clean.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:09:26Z", "closed_at": "2026-02-28T03:09:26Z", "close_reason": "patrol cycle complete: Patrol 9: Archived 5 stale LIFECYCLE mails. Nuked jasper (bd-tcn done, MR submitted). Obsidian/quartz actively coding. Refinery+deacon healthy. Inbox clean.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-fwgt9", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-fwgt9", "depends_on_id": "bd-wisp-5whic", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fwgt9", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-fwzrb", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-fwzrb", "depends_on_id": "bd-wisp-046b8", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fwzrb", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-fwzsx", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-fwzsx", "depends_on_id": "bd-wisp-t50fb", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fwzsx", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-g1nhj", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:52:48Z", "closed_at": "2026-02-28T01:52:48Z", "close_reason": "No active swarms", "dependencies": [{"issue_id": "bd-wisp-g1nhj", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-g1nhj", "depends_on_id": "bd-wisp-bk75t", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-g7y3h", "title": "Merge: bd-39c", "description": "branch: polecat/obsidian/bd-39c@mm5q8cbf\ntarget: main\nsource_issue: bd-39c\nrig: beads\nworker: obsidian\nagent_bead: bd-beads-polecat-obsidian\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T03:03:34Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T03:39:44Z", "closed_at": "2026-02-28T03:39:44Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-ghxf8", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-ghxf8", "depends_on_id": "bd-wisp-56l5k", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ghxf8", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-gl8z7", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 2: Rig idle. No polecats, no new mail. Refinery+Deacon healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:19:44Z", "updated_at": "2026-02-28T02:20:34Z", "closed_at": "2026-02-28T02:20:34Z", "close_reason": "patrol cycle complete: Patrol 2: Rig idle. No polecats, no new mail. Refinery+Deacon healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-gucxa", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-gucxa", "depends_on_id": "bd-wisp-nb8rw", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-gucxa", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-h04t1", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:38Z", "closed_at": "2026-02-28T01:55:38Z", "close_reason": "Context manageable, patrol 3", "dependencies": [{"issue_id": "bd-wisp-h04t1", "depends_on_id": "bd-wisp-vzuka", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-h04t1", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-h6w3r", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:52:33Z", "closed_at": "2026-02-28T01:52:33Z", "close_reason": "No polecats", "dependencies": [{"issue_id": "bd-wisp-h6w3r", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-h6w3r", "depends_on_id": "bd-wisp-b0z0j", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-hhtcg", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-hhtcg", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-hhtcg", "depends_on_id": "bd-wisp-zh1ly", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-hrw53", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-hrw53", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-i43vy", "title": "mol-refinery-patrol", "description": "Patrol report: Patrol cycle 1: merge queue empty, no branches to process. Archived 2 stale handoff messages. Session healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T02:22:31Z", "updated_at": "2026-02-28T02:34:27Z", "closed_at": "2026-02-28T02:34:27Z", "close_reason": "patrol cycle complete: Patrol cycle 1: merge queue empty, no branches to process. Archived 2 stale handoff messages. Session healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-i8vgy", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:48Z", "closed_at": "2026-02-28T01:55:48Z", "close_reason": "Context low, looping with 90s backoff", "dependencies": [{"issue_id": "bd-wisp-i8vgy", "depends_on_id": "bd-wisp-h04t1", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-i8vgy", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-i9plj", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-i9plj", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-i9plj", "depends_on_id": "bd-wisp-o6qm2", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-iawrh", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-iawrh", "depends_on_id": "bd-wisp-oktkn", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-iawrh", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-ichr3", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-ichr3", "depends_on_id": "bd-wisp-6uazx", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ichr3", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-igiw6", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 1: Nuked completed obsidian (bd-e5e fix in MQ). Closed predecessor patrol wisp. Refinery+Deacon healthy. No active polecats. Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:17:55Z", "updated_at": "2026-02-28T02:19:37Z", "closed_at": "2026-02-28T02:19:37Z", "close_reason": "patrol cycle complete: Patrol 1: Nuked completed obsidian (bd-e5e fix in MQ). Closed predecessor patrol wisp. Refinery+Deacon healthy. No active polecats. Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-is8km", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-is8km", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-is8km", "depends_on_id": "bd-wisp-q0wkf", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-izpnn", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 5: Rig idle. No polecats active. Orphaned wisp bd-wisp-5xon7z (obsidian) reported to Deacon. Refinery alive (8h). Deacon alive. Inbox clean.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:58:47Z", "updated_at": "2026-02-28T02:00:42Z", "closed_at": "2026-02-28T02:00:42Z", "close_reason": "patrol cycle complete: Patrol 5: Rig idle. No polecats active. Orphaned wisp bd-wisp-5xon7z (obsidian) reported to Deacon. Refinery alive (8h). Deacon alive. Inbox clean.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-j28gj", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:53:41Z", "updated_at": "2026-02-28T03:06:45Z", "closed_at": "2026-02-28T03:06:45Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-j5cge", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-j5cge", "depends_on_id": "bd-wisp-48086", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-j5cge", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-jdvy3", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-jdvy3", "depends_on_id": "bd-wisp-1fggw", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-jdvy3", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-jdzun", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-jdzun", "depends_on_id": "bd-wisp-ap0pl", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-jdzun", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-jfvhs", "title": "mol-refinery-patrol", "description": "Patrol report: Merged 1 branch (jasper/bd-tcn). Rejected 1 (quartz/bd-1x0, duplicate test fn). Closed 1 orphaned MR (obsidian/bd-39c, already on main). All tests passing. Queue empty.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T02:34:44Z", "updated_at": "2026-02-28T03:48:45Z", "closed_at": "2026-02-28T03:48:45Z", "close_reason": "patrol cycle complete: Merged 1 branch (jasper/bd-tcn). Rejected 1 (quartz/bd-1x0, duplicate test fn). Closed 1 orphaned MR (obsidian/bd-39c, already on main). All tests passing. Queue empty.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-jhni3", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-jhni3", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-jhni3", "depends_on_id": "bd-wisp-spsed", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-jwqsh", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 4: Nuked done polecat obsidian (bd-cgk code review, clean state). Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:36:06Z", "updated_at": "2026-02-28T02:44:56Z", "closed_at": "2026-02-28T02:44:56Z", "close_reason": "patrol cycle complete: Patrol 4: Nuked done polecat obsidian (bd-cgk code review, clean state). Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-k41mv", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 11: Rig idle. No polecats, no mail. Deacon+Refinery healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:06:55Z", "updated_at": "2026-02-28T02:08:13Z", "closed_at": "2026-02-28T02:08:13Z", "close_reason": "patrol cycle complete: Patrol 11: Rig idle. No polecats, no mail. Deacon+Refinery healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-kvdgv", "title": "Handle test failures", "description": "**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf tests PASSED: This step auto-completes. Proceed to merge.\n\nIf tests FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on main?\n2. If branch caused it:\n   - Abort merge\n   - Notify polecat: \"Tests failing. Please fix and resubmit.\"\n   - Skip to loop-check\n3. If pre-existing on main:\n   - File a bead: bd create --type=bug --priority=1 --title=\"...\"\n   - FORBIDDEN: Writing code to fix test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- Tests passing, OR\n- Bead filed for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:38Z", "updated_at": "2026-02-28T01:50:20Z", "closed_at": "2026-02-28T01:50:20Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-kvdgv", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-kvdgv", "depends_on_id": "bd-wisp-telnm", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-kvwuy", "title": "Merge and push to main", "description": "Merge to main and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Step 1: Merge and Push**\n```bash\ngit checkout main\ngit merge --ff-only temp\ngit push origin main\n```\n\n‚ö†Ô∏è **STOP HERE - DO NOT PROCEED UNTIL STEPS 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send <rig>/witness -s \"MERGED <polecat-name>\" -m \"Branch: <branch>\nIssue: <issue-id>\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Close MR Bead (REQUIRED - DO THIS IMMEDIATELY)**\n\n‚ö†Ô∏è **VERIFICATION BEFORE CLOSING**: Confirm the work is actually on main:\n```bash\n# Get the commit message/issue from the branch\ngit log origin/main --oneline | grep \"<issue-id>\"\n# OR verify the commit SHA is on main:\ngit branch --contains <commit-sha> | grep main\n```\n\nIf work is NOT on main, DO NOT close the MR bead. Investigate first.\n\n```bash\nbd close <mr-bead-id> --reason \"Merged to main at $(git rev-parse --short HEAD)\"\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep <polecat-name>\n```\n\n**VALIDATION**: The MR bead's source_issue should be a valid bead ID (gt-xxxxx),\nnot a branch name. If source_issue contains a branch name, flag for investigation.\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive <merge-ready-message-id>\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup (only after Steps 2-4 confirmed)**\n```bash\ngit branch -d temp\ngit push origin --delete <polecat-branch>\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] MR bead closed\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nMain has moved. Any remaining branches need rebasing on new baseline.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:39Z", "updated_at": "2026-02-28T01:50:27Z", "closed_at": "2026-02-28T01:50:27Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-kvwuy", "depends_on_id": "bd-wisp-kvdgv", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-kvwuy", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-l03r8", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-l03r8", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-l03r8", "depends_on_id": "bd-wisp-me34k", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-l5zas", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 9: Stale LIFECYCLE:Shutdown jasper (already nuked, new one spawned). 3 polecats active: jasper(bd-tcn), obsidian(bd-39c), quartz(bd-1x0). All healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:54Z", "closed_at": "2026-02-28T02:55:54Z", "close_reason": "patrol cycle complete: Patrol 9: Stale LIFECYCLE:Shutdown jasper (already nuked, new one spawned). 3 polecats active: jasper(bd-tcn), obsidian(bd-39c), quartz(bd-1x0). All healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-lc09d", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-lc09d", "depends_on_id": "bd-wisp-dk2c2", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-lc09d", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-llvpr", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-llvpr", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-llvpr", "depends_on_id": "bd-wisp-hrw53", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-lwmre", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:52:59Z", "closed_at": "2026-02-28T01:52:59Z", "close_reason": "Deacon alive", "dependencies": [{"issue_id": "bd-wisp-lwmre", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-lwmre", "depends_on_id": "bd-wisp-g1nhj", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-lzr0e", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:14Z", "closed_at": "2026-02-28T01:55:14Z", "close_reason": "No timer gates", "dependencies": [{"issue_id": "bd-wisp-lzr0e", "depends_on_id": "bd-wisp-2hmvg", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-lzr0e", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-md6mn", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:58:33Z", "closed_at": "2026-02-28T01:58:33Z", "close_reason": "Patrol 4 complete, rig idle", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-me34k", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-me34k", "depends_on_id": "bd-wisp-dbpt8", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-me34k", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-mfmcc", "title": "mol-refinery-patrol", "description": "Patrol report: Patrol cycle 2: merge queue empty again. Two consecutive idle cycles. Handing off.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T02:34:28Z", "updated_at": "2026-02-28T02:34:43Z", "closed_at": "2026-02-28T02:34:43Z", "close_reason": "patrol cycle complete: Patrol cycle 2: merge queue empty again. Two consecutive idle cycles. Handing off.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-mkawj", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 3: Rig idle. No polecats. Deacon alive. No new work.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:35:29Z", "updated_at": "2026-02-28T02:36:06Z", "closed_at": "2026-02-28T02:36:06Z", "close_reason": "patrol cycle complete: Patrol 3: Rig idle. No polecats. Deacon alive. No new work.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-msg49", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-msg49", "depends_on_id": "bd-wisp-c2nxw", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-msg49", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-mujak", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-mujak", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-mujak", "depends_on_id": "bd-wisp-jdzun", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-mv6bo", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-mv6bo", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-mv6bo", "depends_on_id": "bd-wisp-vahxt", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-mz4lk", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged ‚Üí archive\n- HELP/Blocked that was handled ‚Üí archive\n- MERGE_READY where merge completed but archive was missed ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/<branch>`\n2. If branch gone, verify work is on main: `git log origin/main --oneline | grep \"<source_issue>\"`\n3. If work on main ‚Üí close MR with reason \"Merged (verified on main)\"\n4. If work NOT on main ‚Üí investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ‚â§3 active messages at end of cycle.\nKeep only: pending MRs in queue.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:39Z", "updated_at": "2026-02-28T01:50:56Z", "closed_at": "2026-02-28T01:50:56Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-mz4lk", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-mz4lk", "depends_on_id": "bd-wisp-s3dce", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-narb2", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:00:42Z", "updated_at": "2026-02-28T02:01:00Z", "closed_at": "2026-02-28T02:01:00Z", "close_reason": "Steps not generated, recreating", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-natap", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-natap", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-natap", "depends_on_id": "bd-wisp-nyswk", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-nb8rw", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-nb8rw", "depends_on_id": "bd-wisp-shp0o", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-nb8rw", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-njhc7", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 14: Obsidian fix applied for bd-e5e. All shim tests pass, running full suite. Deacon+Refinery healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:12:30Z", "updated_at": "2026-02-28T02:14:49Z", "closed_at": "2026-02-28T02:14:49Z", "close_reason": "patrol cycle complete: Patrol 14: Obsidian fix applied for bd-e5e. All shim tests pass, running full suite. Deacon+Refinery healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-nu2sp", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:52:51Z", "updated_at": "2026-02-28T02:53:41Z", "closed_at": "2026-02-28T02:53:41Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-nyswk", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-nyswk", "depends_on_id": "bd-wisp-0fzjd", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-nyswk", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-o30in", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-o30in", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-o30in", "depends_on_id": "bd-wisp-natap", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-o6qm2", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-o6qm2", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-o6qm2", "depends_on_id": "bd-wisp-o30in", "type": "blocks", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-oktkn", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:46Z", "updated_at": "2026-02-28T02:53:46Z", "dependencies": [{"issue_id": "bd-wisp-oktkn", "depends_on_id": "bd-wisp-bzj74", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-oktkn", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-om4u4", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 11: Nuked done obsidian (bd-39c, pushed+merged). Jasper(bd-tcn) and quartz(bd-1x0) both running tests. Healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T03:04:26Z", "closed_at": "2026-02-28T03:04:26Z", "close_reason": "patrol cycle complete: Patrol 11: Nuked done obsidian (bd-39c, pushed+merged). Jasper(bd-tcn) and quartz(bd-1x0) both running tests. Healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-p0w55", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:43:52Z", "updated_at": "2026-02-28T02:45:19Z", "closed_at": "2026-02-28T02:45:19Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-plk6j", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-plk6j", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-plk6j", "depends_on_id": "bd-wisp-tmqq5", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-psxiw", "title": "mol-refinery-patrol", "description": "Merge queue processor patrol loop.\n\nThe Refinery is the Engineer in the engine room. You process polecat branches, merging them to main one at a time with sequential rebasing.\n\n**The Scotty Test**: Before proceeding past any failure, ask yourself: \"Would Scotty walk past a warp core leak because it existed before his shift?\"\n\n## Merge Flow\n\nThe Refinery receives MERGE_READY mail from Witnesses when polecats complete work:\n\n```\nWitness                    Refinery                      Git\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGE_READY              ‚îÇ                           ‚îÇ\n   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (verify branch)                   ‚îÇ\n   ‚îÇ                          ‚îÇ fetch & rebase            ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (run tests)                       ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (if pass)                         ‚îÇ\n   ‚îÇ                          ‚îÇ merge & push              ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGED                   ‚îÇ                           ‚îÇ\n   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n```\n\nAfter successful merge, Refinery sends MERGED mail back to Witness so it can\ncomplete cleanup (nuke the polecat worktree).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:38Z", "updated_at": "2026-02-28T01:51:08Z", "closed_at": "2026-02-28T01:51:08Z", "close_reason": "Closed", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-pzhxc", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 13: Obsidian active on bd-e5e (TestShimExtract_FullMigration bug). Diagnosed root cause, Hyperspacing on fix. No nudge needed. Deacon+Refinery healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:09:58Z", "updated_at": "2026-02-28T02:12:29Z", "closed_at": "2026-02-28T02:12:29Z", "close_reason": "patrol cycle complete: Patrol 13: Obsidian active on bd-e5e (TestShimExtract_FullMigration bug). Diagnosed root cause, Hyperspacing on fix. No nudge needed. Deacon+Refinery healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-q00nq", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 8: Stale LIFECYCLE:Shutdown for obsidian (bd-1x0 already reassigned to quartz). Obsidian active on bd-39c. Both polecats healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:55:19Z", "closed_at": "2026-02-28T02:55:19Z", "close_reason": "patrol cycle complete: Patrol 8: Stale LIFECYCLE:Shutdown for obsidian (bd-1x0 already reassigned to quartz). Obsidian active on bd-39c. Both polecats healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-q0wkf", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-q0wkf", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-q0wkf", "depends_on_id": "bd-wisp-vmla5", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-qs4hz", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T03:06:45Z", "updated_at": "2026-02-28T03:19:27Z", "closed_at": "2026-02-28T03:19:27Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-qtxi9", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:10:41Z", "updated_at": "2026-02-28T02:18:58Z", "closed_at": "2026-02-28T02:18:58Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-r53mq", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-r53mq", "depends_on_id": "bd-wisp-d4fp4", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-r53mq", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-rb7o8", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-rb7o8", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-rb7o8", "depends_on_id": "bd-wisp-zovb3", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-rcp8a", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-rcp8a", "depends_on_id": "bd-wisp-du8l9", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-rcp8a", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-rkwua", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:11:05Z", "updated_at": "2026-02-28T03:11:05Z", "dependencies": [{"issue_id": "bd-wisp-rkwua", "depends_on_id": "bd-wisp-c4isl", "type": "parent-child", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-rkwua", "depends_on_id": "bd-wisp-dqu06", "type": "blocks", "created_at": "2026-02-27T19:11:04Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-c4isl"}
{"id": "bd-wisp-rsi16", "title": "Burn and respawn or loop", "description": "End of patrol cycle decision.\n\n**Step 1: Estimate remaining context**\n\nAsk yourself:\n- Have I processed many branches this cycle?\n- Is the conversation getting long?\n- Am I starting to lose track of earlier context?\n\nRule of thumb: If you've done 3+ merges or processed significant cleanup work,\nit's time for a fresh session.\n\n**Step 2: Decision tree**\n\nIf queue non-empty AND context LOW:\n- Squash this wisp to digest\n- Spawn fresh patrol wisp\n- Return to inbox-check\n\nIf queue empty OR context HIGH OR good stopping point:\n- Squash wisp with summary digest\n- Use `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nNext: [any notes for successor]\"\n```\n\n**Why gt handoff?**\n- Sends handoff mail to yourself with context\n- Respawns with fresh Claude instance\n- SessionStart hook runs gt prime\n- Successor picks up from your hook\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:39Z", "updated_at": "2026-02-28T01:51:02Z", "closed_at": "2026-02-28T01:51:02Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-rsi16", "depends_on_id": "bd-wisp-mz4lk", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-rsi16", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-s3dce", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Write handoff summary\n- Prepare for burn/respawn\n\nIf context is LOW:\n- Can continue processing", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:39Z", "updated_at": "2026-02-28T01:50:49Z", "closed_at": "2026-02-28T01:50:49Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-s3dce", "depends_on_id": "bd-wisp-46umv", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-s3dce", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-shf33", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T02:45:19Z", "updated_at": "2026-02-28T02:49:48Z", "closed_at": "2026-02-28T02:49:48Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-shp0o", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-shp0o", "depends_on_id": "bd-wisp-b3bk7", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-shp0o", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-skicl", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-skicl", "depends_on_id": "bd-wisp-is8km", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-skicl", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-slckl", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:53:47Z", "updated_at": "2026-02-28T02:53:47Z", "dependencies": [{"issue_id": "bd-wisp-slckl", "depends_on_id": "bd-wisp-r53mq", "type": "blocks", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-slckl", "depends_on_id": "bd-wisp-wc77g", "type": "parent-child", "created_at": "2026-02-27T18:53:46Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-wc77g"}
{"id": "bd-wisp-smmfn", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-smmfn", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-smmfn", "depends_on_id": "bd-wisp-skicl", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-spsed", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:44:56Z", "updated_at": "2026-02-28T02:44:56Z", "dependencies": [{"issue_id": "bd-wisp-spsed", "depends_on_id": "bd-wisp-11hc8", "type": "parent-child", "created_at": "2026-02-27T18:44:56Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-11hc8"}
{"id": "bd-wisp-sti0i", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:54:41Z", "closed_at": "2026-02-28T01:54:41Z", "close_reason": "No mail", "dependencies": [{"issue_id": "bd-wisp-sti0i", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-t50fb", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-t50fb", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-t58ws", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-t58ws", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-t58ws", "depends_on_id": "bd-wisp-smmfn", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-t8rm0", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 2: No polecats. Refinery+Deacon alive. Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:20:34Z", "updated_at": "2026-02-28T02:21:03Z", "closed_at": "2026-02-28T02:21:03Z", "close_reason": "patrol cycle complete: Patrol 2: No polecats. Refinery+Deacon alive. Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-tdaau", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 6: Nuked done polecat obsidian (bd-1x0, SQL views bug, report-only). Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:53:46Z", "closed_at": "2026-02-28T02:53:46Z", "close_reason": "patrol cycle complete: Patrol 6: Nuked done polecat obsidian (bd-1x0, SQL views bug, report-only). Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-telnm", "title": "Run test suite", "description": "Run the test suite.\n\n```bash\ngo test ./...\n```\n\nTrack results: pass count, fail count, specific failures.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:49:38Z", "updated_at": "2026-02-28T01:50:13Z", "closed_at": "2026-02-28T01:50:13Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-telnm", "depends_on_id": "bd-wisp-7m3d2", "type": "blocks", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-telnm", "depends_on_id": "bd-wisp-psxiw", "type": "parent-child", "created_at": "2026-02-27T17:49:38Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-psxiw"}
{"id": "bd-wisp-tid7s", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:55:55Z", "dependencies": [{"issue_id": "bd-wisp-tid7s", "depends_on_id": "bd-wisp-3ai4y", "type": "blocks", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-tid7s", "depends_on_id": "bd-wisp-y6497", "type": "parent-child", "created_at": "2026-02-27T18:55:55Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-y6497"}
{"id": "bd-wisp-tmqq5", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-tmqq5", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-tqgim", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:54:57Z", "closed_at": "2026-02-28T01:54:57Z", "close_reason": "Refinery running, no MRs", "dependencies": [{"issue_id": "bd-wisp-tqgim", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-tqgim", "depends_on_id": "bd-wisp-y9vyo", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-vahxt", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:56:29Z", "updated_at": "2026-02-28T02:56:29Z", "dependencies": [{"issue_id": "bd-wisp-vahxt", "depends_on_id": "bd-wisp-msg49", "type": "blocks", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-vahxt", "depends_on_id": "bd-wisp-om4u4", "type": "parent-child", "created_at": "2026-02-27T18:56:29Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-om4u4"}
{"id": "bd-wisp-vi3gh", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:20Z", "closed_at": "2026-02-28T01:55:20Z", "close_reason": "No swarms", "dependencies": [{"issue_id": "bd-wisp-vi3gh", "depends_on_id": "bd-wisp-lzr0e", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-vi3gh", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-vmla5", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:55:19Z", "updated_at": "2026-02-28T02:55:19Z", "dependencies": [{"issue_id": "bd-wisp-vmla5", "depends_on_id": "bd-wisp-fwgt9", "type": "blocks", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-vmla5", "depends_on_id": "bd-wisp-l5zas", "type": "parent-child", "created_at": "2026-02-27T18:55:19Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-l5zas"}
{"id": "bd-wisp-vzuka", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:34Z", "closed_at": "2026-02-28T01:55:34Z", "close_reason": "Inbox clean", "dependencies": [{"issue_id": "bd-wisp-vzuka", "depends_on_id": "bd-wisp-7bt8t", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-vzuka", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-w766u", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-w766u", "depends_on_id": "bd-wisp-2bhbw", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-w766u", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-wc77g", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 7: Nuked done jasper (bd-tcn). Obsidian(bd-39c) and quartz(bd-1x0) actively working.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:53:46Z", "updated_at": "2026-02-28T02:54:40Z", "closed_at": "2026-02-28T02:54:40Z", "close_reason": "patrol cycle complete: Patrol 7: Nuked done jasper (bd-tcn). Obsidian(bd-39c) and quartz(bd-1x0) actively working.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-whkx2", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:52:09Z", "closed_at": "2026-02-28T01:52:09Z", "close_reason": "No mail", "dependencies": [{"issue_id": "bd-wisp-whkx2", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-wth90", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-wth90", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-x3fzf", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-x3fzf", "depends_on_id": "bd-wisp-hhtcg", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-x3fzf", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-xcvrt", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:58:15Z", "closed_at": "2026-02-28T01:58:15Z", "close_reason": "Deacon alive", "dependencies": [{"issue_id": "bd-wisp-xcvrt", "depends_on_id": "bd-wisp-bu1xt", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xcvrt", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-xj4a2", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:57:24Z", "updated_at": "2026-02-28T01:57:43Z", "closed_at": "2026-02-28T01:57:43Z", "close_reason": "No cleanup wisps", "dependencies": [{"issue_id": "bd-wisp-xj4a2", "depends_on_id": "bd-wisp-1ac87", "type": "blocks", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xj4a2", "depends_on_id": "bd-wisp-md6mn", "type": "parent-child", "created_at": "2026-02-27T17:57:23Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-md6mn"}
{"id": "bd-wisp-xoqcz", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:51:59Z", "updated_at": "2026-02-28T01:53:05Z", "closed_at": "2026-02-28T01:53:05Z", "close_reason": "Inbox clean", "dependencies": [{"issue_id": "bd-wisp-xoqcz", "depends_on_id": "bd-wisp-3dxkq", "type": "parent-child", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xoqcz", "depends_on_id": "bd-wisp-lwmre", "type": "blocks", "created_at": "2026-02-27T17:51:58Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3dxkq"}
{"id": "bd-wisp-xpk8r", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-xpk8r", "depends_on_id": "bd-wisp-3lzfe", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-xpk8r", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-wisp-xy7wf", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:55:48Z", "closed_at": "2026-02-28T01:55:48Z", "close_reason": "Patrol 3 complete, rig idle", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-y6497", "title": "mol-witness-patrol", "description": "Patrol report: Patrol 10: All 3 polecats active and healthy. Jasper testing, obsidian coding, quartz exploring. No issues.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T02:55:55Z", "updated_at": "2026-02-28T02:56:28Z", "closed_at": "2026-02-28T02:56:28Z", "close_reason": "patrol cycle complete: Patrol 10: All 3 polecats active and healthy. Jasper testing, obsidian coding, quartz exploring. No issues.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-y9vyo", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:54:32Z", "updated_at": "2026-02-28T01:54:47Z", "closed_at": "2026-02-28T01:54:47Z", "close_reason": "No cleanup wisps", "dependencies": [{"issue_id": "bd-wisp-y9vyo", "depends_on_id": "bd-wisp-sti0i", "type": "blocks", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-y9vyo", "depends_on_id": "bd-wisp-xy7wf", "type": "parent-child", "created_at": "2026-02-27T17:54:31Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-xy7wf"}
{"id": "bd-wisp-ycrox", "title": "mol-refinery-patrol", "description": "Patrol report: Patrol cycle: queue empty, no merges. Two consecutive idle cycles. Session healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T01:59:54Z", "updated_at": "2026-02-28T02:00:13Z", "closed_at": "2026-02-28T02:00:13Z", "close_reason": "patrol cycle complete: Patrol cycle: queue empty, no merges. Two consecutive idle cycles. Session healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-yi19c", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:09:27Z", "updated_at": "2026-02-28T03:09:27Z", "dependencies": [{"issue_id": "bd-wisp-yi19c", "depends_on_id": "bd-wisp-3n1j4", "type": "parent-child", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-yi19c", "depends_on_id": "bd-wisp-w766u", "type": "blocks", "created_at": "2026-02-27T19:09:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-3n1j4"}
{"id": "bd-wisp-zh1ly", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:50:02Z", "updated_at": "2026-02-28T02:50:02Z", "dependencies": [{"issue_id": "bd-wisp-zh1ly", "depends_on_id": "bd-wisp-8qccv", "type": "blocks", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-zh1ly", "depends_on_id": "bd-wisp-tdaau", "type": "parent-child", "created_at": "2026-02-27T18:50:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-tdaau"}
{"id": "bd-wisp-zovb3", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T03:04:27Z", "updated_at": "2026-02-28T03:04:27Z", "dependencies": [{"issue_id": "bd-wisp-zovb3", "depends_on_id": "bd-wisp-fly1i", "type": "parent-child", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-zovb3", "depends_on_id": "bd-wisp-ghxf8", "type": "blocks", "created_at": "2026-02-27T19:04:26Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-fly1i"}
{"id": "bd-wisp-zrebm", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T02:54:40Z", "updated_at": "2026-02-28T02:54:40Z", "dependencies": [{"issue_id": "bd-wisp-zrebm", "depends_on_id": "bd-wisp-0a7v6", "type": "blocks", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-zrebm", "depends_on_id": "bd-wisp-q00nq", "type": "parent-child", "created_at": "2026-02-27T18:54:40Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-q00nq"}
{"id": "bd-beads-polecat-amber", "title": "bd-beads-polecat-amber", "description": "bd-beads-polecat-amber\n\nrole_type: polecat\nrig: beads\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:30:34Z", "created_by": "mayor", "updated_at": "2026-02-28T01:04:11Z", "labels": ["gt:agent"], "ephemeral": true, "agent_state": "idle", "last_activity": "2026-02-28T01:01:55Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-garnet", "title": "bd-beads-polecat-garnet", "description": "bd-beads-polecat-garnet\n\nrole_type: polecat\nrig: beads\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:55:03Z", "created_by": "mayor", "updated_at": "2026-02-28T00:41:31Z", "labels": ["gt:agent"], "ephemeral": true, "agent_state": "idle", "last_activity": "2026-02-28T00:34:03Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-jasper", "title": "bd-beads-polecat-jasper", "description": "bd-beads-polecat-jasper\n\nrole_type: polecat\nrig: beads\nagent_state: spawning\nhook_bead: bd-5ua\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T07:53:43Z", "created_by": "beads/crew/emma", "updated_at": "2026-02-28T03:48:52Z", "labels": ["gt:agent"], "ephemeral": true, "hook_bead": "bd-5ua", "agent_state": "working", "last_activity": "2026-02-28T03:48:52Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-obsidian", "title": "bd-beads-polecat-obsidian", "description": "bd-beads-polecat-obsidian\n\nrole_type: polecat\nrig: beads\nagent_state: spawning\nhook_bead: bd-xmf\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-26T00:04:39Z", "created_by": "mayor", "updated_at": "2026-02-28T03:42:53Z", "labels": ["gt:agent"], "ephemeral": true, "hook_bead": "bd-xmf", "agent_state": "working", "last_activity": "2026-02-28T03:42:53Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-onyx", "title": "bd-beads-polecat-onyx", "description": "bd-beads-polecat-onyx\n\nrole_type: polecat\nrig: beads\nagent_state: spawning\nhook_bead: bd-6bq\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T07:54:03Z", "created_by": "beads/crew/emma", "updated_at": "2026-02-28T03:49:11Z", "labels": ["gt:agent"], "ephemeral": true, "hook_bead": "bd-6bq", "agent_state": "working", "last_activity": "2026-02-28T03:49:11Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-opal", "title": "bd-beads-polecat-opal", "description": "bd-beads-polecat-opal\n\nrole_type: polecat\nrig: beads\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:54:39Z", "created_by": "mayor", "updated_at": "2026-02-28T00:41:54Z", "labels": ["gt:agent"], "ephemeral": true, "agent_state": "idle", "last_activity": "2026-02-28T00:29:24Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-quartz", "title": "bd-beads-polecat-quartz", "description": "bd-beads-polecat-quartz\n\nrole_type: polecat\nrig: beads\nagent_state: spawning\nhook_bead: bd-dgp\ncleanup_status: clean\nactive_mr: bd-wisp-kf100\nnotification_level: null\nexit_type: COMPLETED\nmr_id: bd-wisp-kf100\nbranch: polecat/quartz/bd-dgp@mm5rzuut\ncompletion_time: 2026-02-28T03:54:38Z", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:54:07Z", "created_by": "mayor", "updated_at": "2026-02-28T03:54:44Z", "labels": ["gt:agent"], "ephemeral": true, "agent_state": "done", "last_activity": "2026-02-28T03:54:43Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-ruby", "title": "bd-beads-polecat-ruby", "description": "bd-beads-polecat-ruby\n\nrole_type: polecat\nrig: beads\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:55:15Z", "created_by": "mayor", "updated_at": "2026-02-28T00:43:11Z", "labels": ["gt:agent"], "ephemeral": true, "agent_state": "idle", "last_activity": "2026-02-28T00:41:05Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-beads-polecat-topaz", "title": "bd-beads-polecat-topaz", "description": "bd-beads-polecat-topaz\n\nrole_type: polecat\nrig: beads\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null", "status": "open", "priority": 2, "issue_type": "agent", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:54:51Z", "created_by": "mayor", "updated_at": "2026-02-28T00:41:42Z", "labels": ["gt:agent"], "ephemeral": true, "agent_state": "idle", "last_activity": "2026-02-28T00:35:06Z", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-0i138", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:10Z", "closed_at": "2026-02-28T02:04:10Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-0i138", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-0i138", "depends_on_id": "bd-wisp-jtodq", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-0t4s", "title": "Merge: bd-tk8y", "description": "branch: polecat/quartz/bd-tk8y@mm5ll0o7\ntarget: main\nsource_issue: bd-tk8y\nrig: beads\nworker: quartz\nagent_bead: bd-beads-polecat-quartz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:59:27Z", "created_by": "beads/polecats/quartz", "updated_at": "2026-02-28T01:10:09Z", "closed_at": "2026-02-28T01:10:09Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1fqq", "title": "Merge: bd-zafu", "description": "branch: polecat/quartz/bd-zafu@mm5l0oed\ntarget: main\nsource_issue: bd-zafu\nrig: beads\nworker: quartz\nagent_bead: bd-beads-polecat-quartz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:40:04Z", "created_by": "beads/polecats/quartz", "updated_at": "2026-02-28T00:41:30Z", "closed_at": "2026-02-28T00:41:30Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1fzx", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:03:46Z", "updated_at": "2026-02-28T00:07:23Z", "closed_at": "2026-02-28T00:07:23Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-1hc1f", "title": "mol-refinery-patrol", "description": "Merge queue processor patrol loop.\n\nThe Refinery is the Engineer in the engine room. You process polecat branches, merging them to main one at a time with sequential rebasing.\n\n**The Scotty Test**: Before proceeding past any failure, ask yourself: \"Would Scotty walk past a warp core leak because it existed before his shift?\"\n\n## Merge Flow\n\nThe Refinery receives MERGE_READY mail from Witnesses when polecats complete work:\n\n```\nWitness                    Refinery                      Git\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGE_READY              ‚îÇ                           ‚îÇ\n   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (verify branch)                   ‚îÇ\n   ‚îÇ                          ‚îÇ fetch & rebase            ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (run tests)                       ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (if pass)                         ‚îÇ\n   ‚îÇ                          ‚îÇ merge & push              ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGED                   ‚îÇ                           ‚îÇ\n   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n```\n\nAfter successful merge, Refinery sends MERGED mail back to Witness so it can\ncomplete cleanup (nuke the polecat worktree).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T01:16:03Z", "updated_at": "2026-02-28T01:47:28Z", "closed_at": "2026-02-28T01:47:28Z", "close_reason": "Closed", "labels": ["idle:1"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1lgp", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 14: Nuked garnet (bd-kzn MR) + quartz (bd-2q6d clean). 3 polecats remain: jasper, opal, ruby. All active.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:09:05Z", "updated_at": "2026-02-28T00:10:59Z", "closed_at": "2026-02-28T00:10:59Z", "close_reason": "patrol cycle complete: Cycle 14: Nuked garnet (bd-kzn MR) + quartz (bd-2q6d clean). 3 polecats remain: jasper, opal, ruby. All active.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-1o1i", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:28:11Z", "updated_at": "2026-02-28T00:43:33Z", "closed_at": "2026-02-28T00:43:33Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-200p", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:11:02Z", "updated_at": "2026-02-28T00:23:19Z", "closed_at": "2026-02-28T00:23:19Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-215b", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 15: Handoff threshold. 9 polecats healthy. No incidents across 15 cycles.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:37:37Z", "updated_at": "2026-02-28T00:38:44Z", "closed_at": "2026-02-28T00:38:44Z", "close_reason": "patrol cycle complete: Cycle 15: Handoff threshold. 9 polecats healthy. No incidents across 15 cycles.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-2kcg", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 4: Rig idle. No polecats, no new mail. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:36:37Z", "updated_at": "2026-02-27T23:38:50Z", "closed_at": "2026-02-27T23:38:50Z", "close_reason": "patrol cycle complete: Cycle 4: Rig idle. No polecats, no new mail. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-2wwt5", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged ‚Üí archive\n- HELP/Blocked that was handled ‚Üí archive\n- MERGE_READY where merge completed but archive was missed ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/<branch>`\n2. If branch gone, verify work is on main: `git log origin/main --oneline | grep \"<source_issue>\"`\n3. If work on main ‚Üí close MR with reason \"Merged (verified on main)\"\n4. If work NOT on main ‚Üí investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ‚â§3 active messages at end of cycle.\nKeep only: pending MRs in queue.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:49:15Z", "closed_at": "2026-02-28T01:49:15Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-2wwt5", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-2wwt5", "depends_on_id": "bd-wisp-f1szd", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-2y171", "title": "POLECAT_DONE alpha", "description": "Exit: DEFERRED\nIssue: gt-a6gp\nBranch: polecat/furiosa/gt-a6gp@mm5n4o99", "status": "open", "priority": 2, "issue_type": "task", "assignee": "gastown/witness", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T01:38:17Z", "created_by": "gastown/alpha", "updated_at": "2026-02-28T01:38:17Z", "labels": ["delivery-acked-at:2026-02-28T01:39:40Z", "delivery-acked-by:gastown/witness", "delivery:acked", "delivery:pending", "from:gastown/alpha", "gt:message", "read"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-2z439", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 11: Rig idle. No polecats, no new mail, deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:36:00Z", "updated_at": "2026-02-28T01:37:24Z", "closed_at": "2026-02-28T01:37:24Z", "close_reason": "patrol cycle complete: Cycle 11: Rig idle. No polecats, no new mail, deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-349j", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:55:06Z", "updated_at": "2026-02-28T00:11:02Z", "closed_at": "2026-02-28T00:11:02Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3dhz", "title": "mol-refinery-patrol", "description": "Patrol report: Cycle 2: Queue empty, no branches to process. Session healthy, looping.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-27T23:37:50Z", "updated_at": "2026-02-27T23:38:04Z", "closed_at": "2026-02-27T23:38:04Z", "close_reason": "patrol cycle complete: Cycle 2: Queue empty, no branches to process. Session healthy, looping.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-3ue9z", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:11Z", "closed_at": "2026-02-28T02:04:11Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-3ue9z", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-3ue9z", "depends_on_id": "bd-wisp-nwd9x", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-3vae", "title": "mol-refinery-patrol", "description": "Patrol report: Merged 5 branches (ruby/bd-tk8y, onyx/bd-2c0, obsidian/bd-kyu, amber/bd-7vk P1, quartz/bd-tk8y). Rejected 3 duplicates (jasper/bd-2c0 x2, obsidian/bd-kyu). Filed bd-e5e for pre-existing TestShimExtract_FullMigration failure. Queue empty.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T00:26:08Z", "updated_at": "2026-02-28T01:11:33Z", "closed_at": "2026-02-28T01:11:33Z", "close_reason": "patrol cycle complete: Merged 5 branches (ruby/bd-tk8y, onyx/bd-2c0, obsidian/bd-kyu, amber/bd-7vk P1, quartz/bd-tk8y). Rejected 3 duplicates (jasper/bd-2c0 x2, obsidian/bd-kyu). Filed bd-e5e for pre-existing TestShimExtract_FullMigration failure. Queue empty.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-42bij", "title": "Run test suite", "description": "Run the test suite.\n\n```bash\ngo test ./...\n```\n\nTrack results: pass count, fail count, specific failures.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:48:17Z", "closed_at": "2026-02-28T01:48:17Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-42bij", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-42bij", "depends_on_id": "bd-wisp-7bj62", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-4b0npf", "title": "Archive: jsonl=3/3, git=true, dolt_push=0/0, verify=3/3", "description": "Archive: jsonl=3/3, git=true, dolt_push=0/0, verify=3/3", "status": "closed", "priority": 2, "issue_type": "chore", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T13:17:24Z", "created_by": "dog", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["plugin:dolt-archive", "result:success", "type:plugin-run"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-4cvx", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:27:45Z", "updated_at": "2026-02-28T00:42:57Z", "closed_at": "2026-02-28T00:42:57Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-4da9", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:13:07Z", "updated_at": "2026-02-28T00:26:09Z", "closed_at": "2026-02-28T00:26:09Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-4tsii5", "title": "dolt-backup: Backup: 3 synced, 0 unchanged, 0 failed (of 3 DBs)", "description": "Backup: 3 synced, 0 unchanged, 0 failed (of 3 DBs)", "status": "closed", "priority": 2, "issue_type": "chore", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:10:30Z", "created_by": "dog", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["plugin:dolt-backup", "result:success", "type:plugin-run"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-5167w", "title": "mol-refinery-patrol", "description": "Merge queue processor patrol loop.\n\nThe Refinery is the Engineer in the engine room. You process polecat branches, merging them to main one at a time with sequential rebasing.\n\n**The Scotty Test**: Before proceeding past any failure, ask yourself: \"Would Scotty walk past a warp core leak because it existed before his shift?\"\n\n## Merge Flow\n\nThe Refinery receives MERGE_READY mail from Witnesses when polecats complete work:\n\n```\nWitness                    Refinery                      Git\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGE_READY              ‚îÇ                           ‚îÇ\n   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (verify branch)                   ‚îÇ\n   ‚îÇ                          ‚îÇ fetch & rebase            ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (run tests)                       ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (if pass)                         ‚îÇ\n   ‚îÇ                          ‚îÇ merge & push              ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGED                   ‚îÇ                           ‚îÇ\n   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n```\n\nAfter successful merge, Refinery sends MERGED mail back to Witness so it can\ncomplete cleanup (nuke the polecat worktree).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:49:35Z", "closed_at": "2026-02-28T01:49:35Z", "close_reason": "Closed", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-56lz", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:43:33Z", "updated_at": "2026-02-28T01:00:36Z", "closed_at": "2026-02-28T01:00:36Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-5ebk", "title": "Merge: bd-0tn", "description": "branch: polecat/garnet/bd-0tn@mm5kyq8s\ntarget: main\nsource_issue: bd-0tn\nrig: beads\nworker: garnet\nagent_bead: bd-beads-polecat-garnet\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:33:55Z", "created_by": "beads/polecats/garnet", "updated_at": "2026-02-28T00:35:35Z", "closed_at": "2026-02-28T00:35:35Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-5omg", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:27:19Z", "updated_at": "2026-02-28T00:52:47Z", "closed_at": "2026-02-28T00:52:47Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-5xon7z", "title": "Submit work and self-clean", "description": "Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n‚úì Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/<name>\n  Target: main\n  Issue: bd-8mg\n‚úì Sandbox nuked\n‚úì Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.", "status": "in_progress", "priority": 2, "issue_type": "task", "assignee": "beads/polecats/obsidian", "created_at": "2026-02-27T07:53:03Z", "updated_at": "2026-02-28T03:42:53Z", "dependencies": [{"issue_id": "bd-wisp-5xon7z", "depends_on_id": "bd-wisp-7k9ztg", "type": "blocks", "created_at": "2026-02-26T23:53:02Z", "created_by": "beads/crew/emma", "metadata": "{}"}, {"issue_id": "bd-wisp-5xon7z", "depends_on_id": "bd-wisp-n35vje", "type": "parent-child", "created_at": "2026-02-26T23:53:02Z", "created_by": "beads/crew/emma", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-n35vje"}
{"id": "bd-wisp-669m", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 2: Rig idle. No polecats, no new mail. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:34:31Z", "updated_at": "2026-02-27T23:35:23Z", "closed_at": "2026-02-27T23:35:23Z", "close_reason": "patrol cycle complete: Cycle 2: Rig idle. No polecats, no new mail. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6j3zb", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:39:10Z", "updated_at": "2026-02-28T01:41:39Z", "closed_at": "2026-02-28T01:41:39Z", "close_reason": "Cycle 13: Rig idle", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6l6t", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 7: Rig idle. No polecats, no new mail. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:47:19Z", "updated_at": "2026-02-27T23:52:33Z", "closed_at": "2026-02-27T23:52:33Z", "close_reason": "patrol cycle complete: Cycle 7: Rig idle. No polecats, no new mail. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6lv5by", "title": "POLECAT_DONE rictus", "description": "Exit: COMPLETED\nIssue: gt-r8m9\nBranch: polecat/rictus/gt-r8m9@mm5hkoyf", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "gastown/witness", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:05:50Z", "created_by": "gastown/polecats/rictus", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["delivery-acked-at:2026-02-27T23:06:40Z", "delivery-acked-by:gastown/witness", "delivery:acked", "delivery:pending", "from:gastown/polecats/rictus", "gt:message", "read"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6r9f", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 1: Rig idle. No polecats. Refinery idle (last merged bd-05an). Deacon alive. No actionable mail.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:32:03Z", "updated_at": "2026-02-27T23:34:31Z", "closed_at": "2026-02-27T23:34:31Z", "close_reason": "patrol cycle complete: Cycle 1: Rig idle. No polecats. Refinery idle (last merged bd-05an). Deacon alive. No actionable mail.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-6unv", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 13: 9 polecats healthy. topaz completed bd-qy0. Refinery processing merge. No issues.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:35:07Z", "updated_at": "2026-02-28T00:36:35Z", "closed_at": "2026-02-28T00:36:35Z", "close_reason": "patrol cycle complete: Cycle 13: 9 polecats healthy. topaz completed bd-qy0. Refinery processing merge. No issues.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-71e0f0", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:17:22Z", "updated_at": "2026-02-27T23:30:44Z", "closed_at": "2026-02-27T23:30:44Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-77wh", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 11: 9 polecats healthy (amber new on bd-7vk). jasper completed bd-19i. Refinery and deacon alive. No issues.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:31:49Z", "updated_at": "2026-02-28T00:33:39Z", "closed_at": "2026-02-28T00:33:39Z", "close_reason": "patrol cycle complete: Cycle 11: 9 polecats healthy (amber new on bd-7vk). jasper completed bd-19i. Refinery and deacon alive. No issues.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-79u8", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 3: Rig idle. No polecats, no new mail. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:35:23Z", "updated_at": "2026-02-27T23:36:37Z", "closed_at": "2026-02-27T23:36:37Z", "close_reason": "patrol cycle complete: Cycle 3: Rig idle. No polecats, no new mail. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-7bj62", "title": "Mechanical rebase", "description": "Pick next branch from queue. Attempt mechanical rebase on current main.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/<polecat-branch>\ngit rebase origin/main\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2>/dev/null && echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture main SHA for reference\nMAIN_SHA=$(git rev-parse origin/main)\nBRANCH_SHA=$(git rev-parse origin/<polecat-branch>)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: <original-issue-title>\" --description=\"## Conflict Resolution Required\n\nOriginal MR: <mr-bead-id>\nBranch: <polecat-branch>\nOriginal Issue: <issue-id>\nConflict with main at: ${MAIN_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on current main: git rebase origin/main\n3. Resolve conflicts\n4. Force push: git push -f origin <branch>\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:48:10Z", "closed_at": "2026-02-28T01:48:10Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-7bj62", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-7bj62", "depends_on_id": "bd-wisp-t77h5", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-7nj06", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-7nj06", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-7nj06", "depends_on_id": "bd-wisp-u9zoc", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-85r08", "title": "mol-refinery-patrol", "description": "Patrol report: Queue empty (cycle 2). No merges. Session healthy, context low.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T01:15:49Z", "updated_at": "2026-02-28T01:16:03Z", "closed_at": "2026-02-28T01:16:03Z", "close_reason": "patrol cycle complete: Queue empty (cycle 2). No merges. Session healthy, context low.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-86yb", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:25:31Z", "updated_at": "2026-02-28T00:41:17Z", "closed_at": "2026-02-28T00:41:17Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-8gnok", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:10Z", "closed_at": "2026-02-28T02:04:10Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-8gnok", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-8vvl", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 1: Nuked jasper (bd-tm2p clean, MR queued). 3 active: obsidian(bd-kzn), opal(bd-bwk2 near ctx limit), quartz(bd-ftc). Refinery alive. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:11:00Z", "updated_at": "2026-02-28T00:16:13Z", "closed_at": "2026-02-28T00:16:13Z", "close_reason": "patrol cycle complete: Cycle 1: Nuked jasper (bd-tm2p clean, MR queued). 3 active: obsidian(bd-kzn), opal(bd-bwk2 near ctx limit), quartz(bd-ftc). Refinery alive. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-8z7a7", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-8z7a7", "depends_on_id": "bd-wisp-bniel", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-8z7a7", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-92bqm", "title": "Burn and respawn or loop", "description": "End of patrol cycle decision.\n\n**Step 1: Estimate remaining context**\n\nAsk yourself:\n- Have I processed many branches this cycle?\n- Is the conversation getting long?\n- Am I starting to lose track of earlier context?\n\nRule of thumb: If you've done 3+ merges or processed significant cleanup work,\nit's time for a fresh session.\n\n**Step 2: Decision tree**\n\nIf queue non-empty AND context LOW:\n- Squash this wisp to digest\n- Spawn fresh patrol wisp\n- Return to inbox-check\n\nIf queue empty OR context HIGH OR good stopping point:\n- Squash wisp with summary digest\n- Use `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nNext: [any notes for successor]\"\n```\n\n**Why gt handoff?**\n- Sends handoff mail to yourself with context\n- Respawns with fresh Claude instance\n- SessionStart hook runs gt prime\n- Successor picks up from your hook\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:49:27Z", "closed_at": "2026-02-28T01:49:27Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-92bqm", "depends_on_id": "bd-wisp-2wwt5", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-92bqm", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-94nc", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:54:17Z", "updated_at": "2026-02-28T00:15:33Z", "closed_at": "2026-02-28T00:15:33Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-9cx5q", "title": "Check if active swarm is complete", "description": "If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --wisp --labels=swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: <swarm_id>\" -m \"All <total> polecats merged.\nDuration: <minutes> minutes\nSwarm: <swarm_id>\"\n\n# Close the swarm tracking wisp\nbd close <swarm-wisp-id> --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:10Z", "closed_at": "2026-02-28T02:04:10Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-9cx5q", "depends_on_id": "bd-wisp-0i138", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-9cx5q", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-9fen", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:25:41Z", "updated_at": "2026-02-28T00:45:01Z", "closed_at": "2026-02-28T00:45:01Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-9q2h", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 9: Nuked onyx (bd-49kw done, clean). 7 polecats active, all working. Obsidian+topaz submitted work, re-priming. Refinery+deacon healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:58:14Z", "updated_at": "2026-02-28T00:02:26Z", "closed_at": "2026-02-28T00:02:26Z", "close_reason": "patrol cycle complete: Cycle 9: Nuked onyx (bd-49kw done, clean). 7 polecats active, all working. Obsidian+topaz submitted work, re-priming. Refinery+deacon healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-9uyw", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:33:15Z", "updated_at": "2026-02-28T01:12:14Z", "closed_at": "2026-02-28T01:12:14Z", "close_reason": "Stale patrol wisp from previous witness session; replaced by bd-wisp-avxe", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-9waq", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:25:49Z", "updated_at": "2026-02-28T00:41:51Z", "closed_at": "2026-02-28T00:41:51Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-al09", "title": "Merge: bd-2c0", "description": "branch: polecat/onyx/bd-2c0@mm5ky484\ntarget: main\nsource_issue: bd-2c0\nrig: beads\nworker: onyx\nagent_bead: bd-beads-polecat-onyx\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:43:28Z", "created_by": "beads/polecats/onyx", "updated_at": "2026-02-28T01:02:13Z", "closed_at": "2026-02-28T01:02:13Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-ar089", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:49:33Z", "closed_at": "2026-02-28T01:49:33Z", "close_reason": "No cleanup wisps found", "dependencies": [{"issue_id": "bd-wisp-ar089", "depends_on_id": "bd-wisp-08988", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ar089", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-avxe", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 1: Quartz active on bd-7vk (already merged - nudged). Refinery idle but healthy. Deacon alive. Closed stale wisp bd-wisp-9uyw. No incidents.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:08:53Z", "updated_at": "2026-02-28T01:12:36Z", "closed_at": "2026-02-28T01:12:36Z", "close_reason": "patrol cycle complete: Cycle 1: Quartz active on bd-7vk (already merged - nudged). Refinery idle but healthy. Deacon alive. Closed stale wisp bd-wisp-9uyw. No incidents.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-azbte", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:51:14Z", "closed_at": "2026-02-28T01:51:14Z", "close_reason": "Patrol 1 complete, rig idle", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-b6dql", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:10Z", "closed_at": "2026-02-28T02:04:10Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-b6dql", "depends_on_id": "bd-wisp-fbyfj", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-b6dql", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-bje6rq", "title": "MERGE_FAILED quartz bd-05an", "description": "MR bd-wisp-x8ku REJECTED: gofmt check failed on 2 files modified by the branch (internal/storage/dolt/circuit_breaker.go, internal/storage/dolt/store.go). All tests pass but code formatting is non-compliant. Polecat quartz needs to run 'gofmt -w' on these files and resubmit. Source issue: bd-05an.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:10:53Z", "created_by": "beads/refinery", "updated_at": "2026-02-27T23:30:02Z", "closed_at": "2026-02-27T23:30:02Z", "close_reason": "Moot - obsidian's MR bd-wisp-hcao82 successfully merged. Quartz's failed attempt superseded.", "labels": ["delivery:pending", "from:beads/refinery", "gt:message", "thread:thread-4ac8c25927af"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-bniel", "title": "Check timer gates for expiration", "description": "Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now > created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-bniel", "depends_on_id": "bd-wisp-oui82", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-bniel", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-bocpcp", "title": "mol-deacon-patrol", "description": "Mayor's daemon patrol loop.\n\nThe Deacon is the Mayor's background process that runs continuously, handling callbacks, monitoring rig health, and performing cleanup. Each patrol cycle runs these steps in sequence, then loops or exits.\n\n## Idle Town Principle\n\n**The Deacon should be silent/invisible when the town is healthy and idle.**\n\n- Skip HEALTH_CHECK nudges when no active work exists\n- Sleep 60+ seconds between patrol cycles (longer when idle)\n- Let the feed subscription wake agents on actual events\n- The daemon (10-minute heartbeat) is the safety net for dead sessions\n\nThis prevents flooding idle agents with health checks every few seconds.\n\n## Second-Order Monitoring\n\nWitnesses send WITNESS_PING messages to verify the Deacon is alive. This\nprevents the \"who watches the watchers\" problem - if the Deacon dies,\nWitnesses detect it and escalate to the Mayor.\n\nThe Deacon's agent bead last_activity timestamp is updated during each patrol\ncycle. Witnesses check this timestamp to verify health.", "status": "hooked", "priority": 2, "issue_type": "epic", "assignee": "deacon", "created_at": "2026-02-27T23:04:35Z", "updated_at": "2026-02-27T23:04:35Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-bxbjg", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 7: Rig idle. All healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:20:52Z", "updated_at": "2026-02-28T01:24:07Z", "closed_at": "2026-02-28T01:24:07Z", "close_reason": "patrol cycle complete: Cycle 7: Rig idle. All healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-byijtt", "title": "Plugin run: rebuild-gt", "description": "Manual run via gt plugin run", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:10:43Z", "created_by": "dog", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["plugin:rebuild-gt", "result:success", "rig:gastown", "type:plugin-run"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-c6va", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:55:18Z", "updated_at": "2026-02-28T00:13:07Z", "closed_at": "2026-02-28T00:13:07Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-dz5h", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 8: 8 polecats dispatched and all actively working. No stuck workers.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:52:33Z", "updated_at": "2026-02-27T23:58:14Z", "closed_at": "2026-02-27T23:58:14Z", "close_reason": "patrol cycle complete: Cycle 8: 8 polecats dispatched and all actively working. No stuck workers.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-e8cq", "title": "mol-refinery-patrol", "description": "Patrol report: Queue empty, no merges this cycle. Session healthy, looping.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T01:11:34Z", "updated_at": "2026-02-28T01:15:49Z", "closed_at": "2026-02-28T01:15:49Z", "close_reason": "patrol cycle complete: Queue empty, no merges this cycle. Session healthy, looping.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-edg2", "title": "Merge: bd-7z5", "description": "branch: polecat/opal/bd-7z5@mm5kyb6d\ntarget: main\nsource_issue: bd-7z5\nrig: beads\nworker: opal\nagent_bead: bd-beads-polecat-opal\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:29:11Z", "created_by": "beads/polecats/opal", "updated_at": "2026-02-28T00:30:50Z", "closed_at": "2026-02-28T00:30:50Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-esp6", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:52:47Z", "updated_at": "2026-02-28T01:04:27Z", "closed_at": "2026-02-28T01:04:27Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-etz16", "title": "Handle test failures", "description": "**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf tests PASSED: This step auto-completes. Proceed to merge.\n\nIf tests FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on main?\n2. If branch caused it:\n   - Abort merge\n   - Notify polecat: \"Tests failing. Please fix and resubmit.\"\n   - Skip to loop-check\n3. If pre-existing on main:\n   - File a bead: bd create --type=bug --priority=1 --title=\"...\"\n   - FORBIDDEN: Writing code to fix test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- Tests passing, OR\n- Bead filed for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:48:23Z", "closed_at": "2026-02-28T01:48:23Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-etz16", "depends_on_id": "bd-wisp-42bij", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-etz16", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-f19z7", "title": "Ensure refinery is alive", "description": "Ensure the refinery is alive and processing merge requests.\n\n```bash\n# Check if refinery session exists\ngt session status <rig>/refinery\n\n# Check for pending merge requests\nbd list --type=merge-request --status=open\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start <rig>/refinery\ngt mail send <rig>/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\n```\n\nIf refinery running but queue stale (>30 min), send nudge.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-f19z7", "depends_on_id": "bd-wisp-kzrv0", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-f19z7", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-f1szd", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Write handoff summary\n- Prepare for burn/respawn\n\nIf context is LOW:\n- Can continue processing", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:49:04Z", "closed_at": "2026-02-28T01:49:04Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-f1szd", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-f1szd", "depends_on_id": "bd-wisp-n8jn7", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-fawc", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 5: Rig idle. No polecats, no new mail. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:38:51Z", "updated_at": "2026-02-27T23:42:05Z", "closed_at": "2026-02-27T23:42:05Z", "close_reason": "patrol cycle complete: Cycle 5: Rig idle. No polecats, no new mail. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-fbyfj", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:10Z", "closed_at": "2026-02-28T02:04:10Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-fbyfj", "depends_on_id": "bd-wisp-8gnok", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fbyfj", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-ftyf9", "title": "Merge and push to main", "description": "Merge to main and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Step 1: Merge and Push**\n```bash\ngit checkout main\ngit merge --ff-only temp\ngit push origin main\n```\n\n‚ö†Ô∏è **STOP HERE - DO NOT PROCEED UNTIL STEPS 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send <rig>/witness -s \"MERGED <polecat-name>\" -m \"Branch: <branch>\nIssue: <issue-id>\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Close MR Bead (REQUIRED - DO THIS IMMEDIATELY)**\n\n‚ö†Ô∏è **VERIFICATION BEFORE CLOSING**: Confirm the work is actually on main:\n```bash\n# Get the commit message/issue from the branch\ngit log origin/main --oneline | grep \"<issue-id>\"\n# OR verify the commit SHA is on main:\ngit branch --contains <commit-sha> | grep main\n```\n\nIf work is NOT on main, DO NOT close the MR bead. Investigate first.\n\n```bash\nbd close <mr-bead-id> --reason \"Merged to main at $(git rev-parse --short HEAD)\"\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep <polecat-name>\n```\n\n**VALIDATION**: The MR bead's source_issue should be a valid bead ID (gt-xxxxx),\nnot a branch name. If source_issue contains a branch name, flag for investigation.\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive <merge-ready-message-id>\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup (only after Steps 2-4 confirmed)**\n```bash\ngit branch -d temp\ngit push origin --delete <polecat-branch>\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] MR bead closed\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nMain has moved. Any remaining branches need rebasing on new baseline.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:48:31Z", "closed_at": "2026-02-28T01:48:31Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-ftyf9", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-ftyf9", "depends_on_id": "bd-wisp-etz16", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-fxbes", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-fxbes", "depends_on_id": "bd-wisp-p97ag", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-fxbes", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-g2qh0", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T01:48:44Z", "closed_at": "2026-02-28T01:48:44Z", "close_reason": "Stale wisp from previous session, replaced by bd-wisp-azbte", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-g9rz", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 13: Garnet submitting (gt done). Jasper debugging test failures. 5 polecats active, all progressing. Healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:07:42Z", "updated_at": "2026-02-28T00:09:05Z", "closed_at": "2026-02-28T00:09:05Z", "close_reason": "patrol cycle complete: Cycle 13: Garnet submitting (gt done). Jasper debugging test failures. 5 polecats active, all progressing. Healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-gnsr", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 2: Quartz done (bd-7vk). Nuked quartz polecat. MR rejected as duplicate by refinery. Rig empty, queue empty. All healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:12:36Z", "updated_at": "2026-02-28T01:14:23Z", "closed_at": "2026-02-28T01:14:23Z", "close_reason": "patrol cycle complete: Cycle 2: Quartz done (bd-7vk). Nuked quartz polecat. MR rejected as duplicate by refinery. Rig empty, queue empty. All healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-h2wl", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:54:17Z", "updated_at": "2026-02-28T01:04:18Z", "closed_at": "2026-02-28T01:04:18Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-hjp6w3", "title": "DOG_DONE: plugin:dolt-reaper", "description": "Dolt Reaper plugin execution complete. Data reaping operation finished: 0 wisps total, 0 squashed, 0 flagged for burn. System clean.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "deacon/", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:10:50Z", "created_by": "overseer", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["delivery:pending", "from:overseer", "gt:message", "thread:thread-c509174dc690"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-hq25", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:54:09Z", "updated_at": "2026-02-28T00:10:44Z", "closed_at": "2026-02-28T00:10:44Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-i9xwp", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 9: Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:27:21Z", "updated_at": "2026-02-28T01:31:35Z", "closed_at": "2026-02-28T01:31:35Z", "close_reason": "patrol cycle complete: Cycle 9: Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-ic7j", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:45:01Z", "updated_at": "2026-02-28T00:54:17Z", "closed_at": "2026-02-28T00:54:17Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-id4g", "title": "Merge: bd-ftc", "description": "branch: polecat/ruby/bd-ftc@mm5jv1ha\ntarget: main\nsource_issue: bd-ftc\nrig: beads\nworker: ruby\nagent_bead: bd-beads-polecat-ruby\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:11:31Z", "created_by": "beads/polecats/ruby", "updated_at": "2026-02-28T00:21:48Z", "closed_at": "2026-02-28T00:21:48Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-iset7", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 8: Rig idle. All healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:24:08Z", "updated_at": "2026-02-28T01:27:21Z", "closed_at": "2026-02-28T01:27:21Z", "close_reason": "patrol cycle complete: Cycle 8: Rig idle. All healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-j3cujd", "title": "DOG_DONE", "description": "Plugin dolt-archive completed successfully. Closed bead bd-wisp-gg3nhf.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "deacon/", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:10:03Z", "created_by": "overseer", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["delivery:pending", "from:overseer", "gt:message", "thread:thread-af4664e2ac25"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-j5dp", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:26:00Z", "updated_at": "2026-02-28T00:41:40Z", "closed_at": "2026-02-28T00:41:40Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-jbjv", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 13: Nuked 3 done polecats (amber/jasper/obsidian). Recovered obsidian branch after nuke deleted it prematurely. Refinery merged obsidian/bd-kyu, rejected duplicate jasper/bd-2c0. 1 active polecat (quartz/bd-7vk). Nudged refinery about 4 pending MRs.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:44:53Z", "updated_at": "2026-02-28T01:07:23Z", "closed_at": "2026-02-28T01:07:23Z", "close_reason": "patrol cycle complete: Cycle 13: Nuked 3 done polecats (amber/jasper/obsidian). Recovered obsidian branch after nuke deleted it prematurely. Refinery merged obsidian/bd-kyu, rejected duplicate jasper/bd-2c0. 1 active polecat (quartz/bd-7vk). Nudged refinery about 4 pending MRs.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-jjg6", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:30:40Z", "updated_at": "2026-02-28T01:04:26Z", "closed_at": "2026-02-28T01:04:26Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-jtodq", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:10Z", "closed_at": "2026-02-28T02:04:10Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-jtodq", "depends_on_id": "bd-wisp-b6dql", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-jtodq", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-k453", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T01:04:26Z", "updated_at": "2026-02-28T01:14:00Z", "closed_at": "2026-02-28T01:14:00Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-k4r9", "title": "Merge: bd-kyu", "description": "branch: polecat/obsidian/bd-kyu@mm5l051u\ntarget: main\nsource_issue: bd-kyu\nrig: beads\nworker: obsidian\nagent_bead: bd-beads-polecat-obsidian\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:50:53Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T01:05:14Z", "closed_at": "2026-02-28T01:05:14Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-kzrv0", "title": "Process pending cleanup wisps", "description": "Process cleanup wisps (exception handling for dirty polecats).\n\nIn the ephemeral model, cleanup wisps are only created when a polecat has\ndirty state (uncommitted changes, unpushed commits) that prevented immediate\nnuke. Most polecats are nuked immediately on POLECAT_DONE and never create wisps.\n\n```bash\n# Find all cleanup wisps\nbd list --wisp --labels=cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/<name>\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log origin/main..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Mayor for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt polecat nuke <name>\n\n# Close the wisp\nbd close <wisp-id> --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Mayor\n```bash\ngt mail send mayor/ -s \"RECOVERY_NEEDED <rig>/<polecat>\" \\\n  -m \"Cleanup Status: <status>\nBranch: <branch>\nIssue: <issue-id>\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Mayor resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-kzrv0", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-kzrv0", "depends_on_id": "bd-wisp-ryvn4", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-l1hx", "title": "Merge: bd-kzn", "description": "branch: polecat/garnet/bd-kzn@mm5jurzh\ntarget: main\nsource_issue: bd-kzn\nrig: beads\nworker: garnet\nagent_bead: bd-beads-polecat-garnet\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:09:00Z", "created_by": "beads/polecats/garnet", "updated_at": "2026-02-28T00:15:55Z", "closed_at": "2026-02-28T00:15:55Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-l6kpf", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 6: Rig idle. All systems healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:18:31Z", "updated_at": "2026-02-28T01:20:52Z", "closed_at": "2026-02-28T01:20:52Z", "close_reason": "patrol cycle complete: Cycle 6: Rig idle. All systems healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-l6tw", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:15:33Z", "updated_at": "2026-02-28T00:23:38Z", "closed_at": "2026-02-28T00:23:38Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-lg6j", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:54:26Z", "updated_at": "2026-02-28T00:00:31Z", "closed_at": "2026-02-28T00:00:31Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-lltq9u", "title": "mol-refinery-patrol", "description": "Patrol report: Cycle 1: Queue empty, no branches to process. Inbox cleaned (archived stale handoff from previous session). Session healthy, looping.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-27T23:11:50Z", "updated_at": "2026-02-27T23:37:50Z", "closed_at": "2026-02-27T23:37:50Z", "close_reason": "patrol cycle complete: Cycle 1: Queue empty, no branches to process. Inbox cleaned (archived stale handoff from previous session). Session healthy, looping.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-mjy2", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:54:53Z", "updated_at": "2026-02-28T00:03:45Z", "closed_at": "2026-02-28T00:03:45Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-mtsze2", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 14: Nuked obsidian (bd-05an merged to main, commit 0cb7936f). Closed MERGE_FAILED wisp for quartz. No active polecats. Refinery alive, deacon alive. Rig idle.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:27:34Z", "updated_at": "2026-02-27T23:32:03Z", "closed_at": "2026-02-27T23:32:03Z", "close_reason": "patrol cycle complete: Cycle 14: Nuked obsidian (bd-05an merged to main, commit 0cb7936f). Closed MERGE_FAILED wisp for quartz. No active polecats. Refinery alive, deacon alive. Rig idle.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-n2hf", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 12: Nuked onyx (bd-ee1 duplicate, clean). 5 polecats active, all working. Systems healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:06:04Z", "updated_at": "2026-02-28T00:07:42Z", "closed_at": "2026-02-28T00:07:42Z", "close_reason": "patrol cycle complete: Cycle 12: Nuked onyx (bd-ee1 duplicate, clean). 5 polecats active, all working. Systems healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-n7f8c", "title": "Loop or exit for respawn", "description": "End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n1. Generate a brief summary of this patrol cycle\n2. Squash the current wisp:\n```bash\nbd mol squash <mol-id> --summary \"<patrol-summary>\"\n```\n3. Create a new patrol wisp:\n```bash\nbd mol wisp mol-witness-patrol\n```\n4. Continue executing from the inbox-check step of the new wisp\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"<observations>\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either create a new wisp (context LOW) or exit (context HIGH).\nNever leave the session without work on your hook.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:51:13Z", "closed_at": "2026-02-28T01:51:13Z", "close_reason": "Context low, looping", "dependencies": [{"issue_id": "bd-wisp-n7f8c", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-n7f8c", "depends_on_id": "bd-wisp-ofntd", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-n8jn7", "title": "Generate handoff summary", "description": "Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate main is moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:48:50Z", "closed_at": "2026-02-28T01:48:50Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-n8jn7", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-n8jn7", "depends_on_id": "bd-wisp-t7l78", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-np4i", "title": "mol-refinery-patrol", "description": "Patrol report: Queue empty, context heavy from test runs. Handing off.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-28T00:25:49Z", "updated_at": "2026-02-28T00:26:07Z", "closed_at": "2026-02-28T00:26:07Z", "close_reason": "patrol cycle complete: Queue empty, context heavy from test runs. Handing off.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-nv73fx", "title": "dolt-backup: Dolt backup completed: size=241M files=     709 path=/Users/stevey/.dolt-backups/dolt-backup-20260227-150650.tar.gz", "description": "Dolt backup completed: size=241M files=     709 path=/Users/stevey/.dolt-backups/dolt-backup-20260227-150650.tar.gz", "status": "closed", "priority": 2, "issue_type": "chore", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:07:15Z", "created_by": "dog", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["plugin:dolt-backup", "result:success", "type:plugin-run"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-nwd9x", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:11Z", "closed_at": "2026-02-28T02:04:11Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-nwd9x", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-nwd9x", "depends_on_id": "bd-wisp-ovw3f", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-o5xr", "title": "mol-refinery-patrol", "description": "Patrol report: Cycle 3: Queue empty again. Three consecutive empty cycles. Handing off.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-27T23:38:04Z", "updated_at": "2026-02-27T23:38:17Z", "closed_at": "2026-02-27T23:38:17Z", "close_reason": "patrol cycle complete: Cycle 3: Queue empty again. Three consecutive empty cycles. Handing off.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-ofkv", "title": "Merge: bd-tk8y", "description": "branch: polecat/ruby/bd-tk8y@mm5l1669\ntarget: main\nsource_issue: bd-tk8y\nrig: beads\nworker: ruby\nagent_bead: bd-beads-polecat-ruby\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:40:55Z", "created_by": "beads/polecats/ruby", "updated_at": "2026-02-28T00:53:01Z", "closed_at": "2026-02-28T00:53:01Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-ofntd", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:50:46Z", "closed_at": "2026-02-28T01:50:46Z", "close_reason": "Fresh session, context low", "dependencies": [{"issue_id": "bd-wisp-ofntd", "depends_on_id": "bd-wisp-71vcf", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ofntd", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-opuy", "title": "Merge: bd-2c0", "description": "branch: polecat/jasper/bd-2c0@mm5lyr6y\ntarget: main\nsource_issue: bd-2c0\nrig: beads\nworker: jasper\nagent_bead: bd-beads-polecat-jasper\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T01:02:43Z", "created_by": "beads/polecats/jasper", "updated_at": "2026-02-28T01:10:59Z", "closed_at": "2026-02-28T01:10:59Z", "close_reason": "rejected: Duplicate: bd-2c0 fix already merged via onyx (bd-wisp-al09). Previous jasper submission also rejected (bd-wisp-qmyb).", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-orq3n", "title": "Check refinery mail", "description": "Check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: <branch>\n# Issue: <issue-id>\n# Polecat: <polecat-name>\n# MR: <mr-bead-id>\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive <message-id>\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:47:43Z", "closed_at": "2026-02-28T01:47:43Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-orq3n", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-oui82", "title": "Inspect all active polecats", "description": "Survey all polecats using agent beads (ZFC: trust what agents report).\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: <rig-name>`\n- `agent_state: running|orphaned|stuck|done`\n- `hook_bead: <current-work-id>`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check progress (Step 3) |\n| orphaned | Crashed before self-nuke | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 3: For running polecats, assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show <hook_bead>  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ntmux capture-pane -t gt-<rig>-<name> -p | tail -20\n```\n\nLook for:\n- Recent tool activity ‚Üí making progress\n- Inactive at prompt ‚Üí may need nudge\n- Error messages ‚Üí may need help\n\n**Step 3a: For orphaned polecats, auto-nuke if clean**\n\nWhen a polecat has no hook_bead, it likely crashed before running gt done (orphaned). Check if it's safe to nuke:\n\n```bash\n# Check git status in the polecat's worktree\ncd polecats/<name>\ngit status --porcelain         # Should be empty (clean)\ngit log origin/main..HEAD      # Should have no unpushed commits\n```\n\n**If clean** (no uncommitted changes, no unpushed commits):\n```bash\n# Safe to nuke - no work to lose\ngt polecat nuke <name>\n```\nLog the auto-nuke for audit purposes. No escalation needed.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Mayor - polecat has work that might be valuable\ngt mail send mayor/ -s \\\"ORPHAN_DIRTY: <polecat> has uncommitted work\\\" \\\n  -m \\\"Polecat: <name>\nState: orphaned (crashed before self-nuke)\nGit status: <uncommitted-files>\nUnpushed commits: <count>\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Orphaned polecats with clean git state are pure overhead. They have\nno work and no state worth preserving. Nuking them immediately frees resources\nand reduces noise. Only escalate when there's actual work at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, recent activity | None |\n| agent_state=running, inactive 5-15 min | Gentle nudge |\n| agent_state=running, inactive 15+ min | Direct nudge with deadline |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the ephemeral model, polecats with agent_state=done and cleanup_status=clean\nshould already be nuked by HandlePolecatDone. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/<name> 2>/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --wisp --labels=polecat:<name> --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Try auto-nuke directly (ephemeral model):\n   ```bash\n   # Check cleanup_status and nuke if clean\n   gt polecat nuke <name>  # Will fail if dirty\n   ```\n   If nuke fails (dirty state), create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\ngt nudge <rig>/polecats/<name> \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> stuck\" \\\n  -m \"Polecat <name> reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads. Don't infer state from PID/tmux.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-oui82", "depends_on_id": "bd-wisp-f19z7", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-oui82", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-ovw3f", "title": "End-of-cycle inbox hygiene", "description": "Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the ephemeral model, most POLECAT_DONE messages are handled immediately\n(auto-nuke) and archived. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (informational, archive after reading)\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- POLECAT_STARTED older than this cycle ‚Üí archive\n- POLECAT_DONE that was auto-nuked ‚Üí should be archived already\n- MERGED notifications ‚Üí archive after acknowledging\n- HELP/Blocked that was escalated ‚Üí archive\n- SWARM_START that created tracking wisp ‚Üí archive\n\n```bash\n# For each stale message found:\ngt mail archive <message-id>\n```\n\n**Step 3: Verify cleanup wisp hygiene**\n\nIn the ephemeral model, cleanup wisps should be rare (only for dirty polecats):\n```bash\nbd list --wisp --labels=cleanup --status=open\n```\n\n- state:pending ‚Üí Needs investigation in process-cleanups\n- state:merge-requested ‚Üí Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:11Z", "closed_at": "2026-02-28T02:04:11Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-ovw3f", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-ovw3f", "depends_on_id": "bd-wisp-sh1gt", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-p97ag", "title": "Check own context limit", "description": "Check own context usage.\n\nIf context is HIGH (>80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-p97ag", "depends_on_id": "bd-wisp-7nj06", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-p97ag", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-payp", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 11: bd-ee1 merged. Nudged onyx (duplicating merged work). 6 polecats active. All systems healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:04:28Z", "updated_at": "2026-02-28T00:06:04Z", "closed_at": "2026-02-28T00:06:04Z", "close_reason": "patrol cycle complete: Cycle 11: bd-ee1 merged. Nudged onyx (duplicating merged work). 6 polecats active. All systems healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-q6f7q", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 10: Rig idle. No polecats, no pending MRs. Refinery dead (no work queued). Deacon alive. No escalations.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:31:35Z", "updated_at": "2026-02-28T01:36:00Z", "closed_at": "2026-02-28T01:36:00Z", "close_reason": "patrol cycle complete: Cycle 10: Rig idle. No polecats, no pending MRs. Refinery dead (no work queued). Deacon alive. No escalations.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-qfhn", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 3: Rig idle. No polecats, no new work. All systems healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:14:23Z", "updated_at": "2026-02-28T01:15:32Z", "closed_at": "2026-02-28T01:15:32Z", "close_reason": "patrol cycle complete: Cycle 3: Rig idle. No polecats, no new work. All systems healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-qmyb", "title": "Merge: bd-2c0", "description": "branch: polecat/jasper/bd-2c0@mm5lmz0o\ntarget: main\nsource_issue: bd-2c0\nrig: beads\nworker: jasper\nagent_bead: bd-beads-polecat-jasper\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:52:57Z", "created_by": "beads/polecats/jasper", "updated_at": "2026-02-28T01:06:28Z", "closed_at": "2026-02-28T01:06:28Z", "close_reason": "rejected: Duplicate: bd-2c0 fix already merged via onyx (bd-wisp-al09). Jasper branch conflicts with already-merged code.", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-rf81c", "title": "mol-witness-patrol", "description": "Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Ephemeral Polecat Model\n\nPolecats are truly ephemeral - done at MR submission, recyclable immediately:\n\n```\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle:      created ‚Üí queued ‚Üí processed ‚Üí merged (Refinery handles)\n```\n\nOnce a polecat's branch is pushed (cleanup_status=clean), the polecat can be\nnuked immediately. The MR continues independently in the Refinery. If conflicts\narise, Refinery creates a NEW conflict-resolution task for a NEW polecat.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, don't maintain state\n- **Events over state**: POLECAT_DONE mail triggers immediate cleanup\n- **Ephemeral by default**: Clean polecats are nuked immediately, no waiting\n- **Cleanup wisps for exceptions**: Only created when intervention needed\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n\n## Patrol Shape (Linear, Deacon-style)\n\n```\ninbox-check ‚îÄ‚ñ∫ process-cleanups ‚îÄ‚ñ∫ check-refinery ‚îÄ‚ñ∫ survey-workers\n                                                            ‚îÇ\n         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚ñº\n  check-timer-gates ‚îÄ‚ñ∫ check-swarm ‚îÄ‚ñ∫ ping-deacon ‚îÄ‚ñ∫ patrol-cleanup ‚îÄ‚ñ∫ context-check ‚îÄ‚ñ∫ loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T01:47:54Z", "closed_at": "2026-02-28T01:47:54Z", "close_reason": "Cycle 15: Handoff threshold reached, rig idle", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-ryvn4", "title": "Process witness mail", "description": "Check inbox and handle messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive <message-id>\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown**:\n\n*EPHEMERAL MODEL*: Polecats are truly ephemeral - done at MR submission,\nrecyclable immediately. Once the branch is pushed (cleanup_status=clean),\nthe polecat can be nuked. The MR lifecycle continues independently in the\nRefinery. If conflicts arise, Refinery creates a NEW conflict-resolution\ntask for a NEW polecat.\n\nPolecat lifecycle: spawning ‚Üí working ‚Üí mr_submitted ‚Üí nuked\nMR lifecycle: created ‚Üí queued ‚Üí processed ‚Üí merged (handled by Refinery)\n\nThe handler (HandlePolecatDone) will:\n1. Check cleanup_status from agent bead\n2. If \"clean\" (branch pushed): AUTO-NUKE immediately, archive mail\n3. If dirty: Create cleanup wisp for manual intervention\n\n```bash\n# The handler does this automatically:\n# - For clean state: gt polecat nuke <name> ‚Üí archive mail\n# - For dirty state: create wisp ‚Üí process in next step\n```\n\nCleanup wisps are only created when something is wrong (uncommitted changes,\nunpushed commits). Most POLECAT_DONE messages result in immediate nuke.\n\n**MERGED**:\nA branch was merged successfully. This is informational in the ephemeral model\nsince the polecat was already nuked after MR submission.\n\nIf a cleanup wisp exists (dirty state), complete the cleanup:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --wisp --labels=polecat:<name>,state:merge-requested --status=open\n\n# If found, proceed with full polecat nuke:\ngt polecat nuke <name>\n\n# Burn the cleanup wisp\nbd close <wisp-id>\n```\nArchive after cleanup is complete.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"Escalation: <polecat> needs help\" -m \"<details>\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive <message-id>\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive <message-id>\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --wisp --title \"swarm:<swarm_id>\" --description \"Tracking batch: <swarm_id>\" --labels swarm,swarm_id:<swarm_id>,total:<N>,completed:0,start:<timestamp>\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive <message-id>\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-ryvn4", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-s7cnw", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 5: Rig idle. No activity.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:16:47Z", "updated_at": "2026-02-28T01:18:31Z", "closed_at": "2026-02-28T01:18:31Z", "close_reason": "patrol cycle complete: Cycle 5: Rig idle. No activity.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-sh1gt", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:48:01Z", "updated_at": "2026-02-28T02:04:10Z", "closed_at": "2026-02-28T02:04:10Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-g2qh0", "dependencies": [{"issue_id": "bd-wisp-sh1gt", "depends_on_id": "bd-wisp-9cx5q", "type": "blocks", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-sh1gt", "depends_on_id": "bd-wisp-g2qh0", "type": "parent-child", "created_at": "2026-02-27T17:48:01Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-g2qh0"}
{"id": "bd-wisp-t39k", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 4: Rig idle. No activity.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:15:32Z", "updated_at": "2026-02-28T01:16:46Z", "closed_at": "2026-02-28T01:16:46Z", "close_reason": "patrol cycle complete: Cycle 4: Rig idle. No activity.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-t3st", "title": "Test wisp", "status": "open", "priority": 2, "issue_type": "task", "created_at": "2026-02-26T00:08:56Z", "updated_at": "2026-02-28T03:39:03Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-t77h5", "title": "Scan merge queue", "description": "Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list <rig>\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to context-check step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep <branch>\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close <mr-id> --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:47:57Z", "closed_at": "2026-02-28T01:47:57Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-t77h5", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-t77h5", "depends_on_id": "bd-wisp-orq3n", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-t7l78", "title": "Check for more work", "description": "More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/refinery", "created_at": "2026-02-28T01:47:20Z", "updated_at": "2026-02-28T01:48:42Z", "closed_at": "2026-02-28T01:48:42Z", "close_reason": "Closed", "dependencies": [{"issue_id": "bd-wisp-t7l78", "depends_on_id": "bd-wisp-5167w", "type": "parent-child", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}, {"issue_id": "bd-wisp-t7l78", "depends_on_id": "bd-wisp-ftyf9", "type": "blocks", "created_at": "2026-02-27T17:47:20Z", "created_by": "refinery", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-5167w"}
{"id": "bd-wisp-tyzd", "title": "Merge: bd-qy0", "description": "branch: polecat/topaz/bd-qy0@mm5kyivk\ntarget: main\nsource_issue: bd-qy0\nrig: beads\nworker: topaz\nagent_bead: bd-beads-polecat-topaz\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T00:34:55Z", "created_by": "beads/polecats/topaz", "updated_at": "2026-02-28T00:37:05Z", "closed_at": "2026-02-28T00:37:05Z", "close_reason": "merged", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-u9zoc", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "closed", "priority": 2, "issue_type": "task", "created_at": "2026-02-28T01:41:42Z", "updated_at": "2026-02-28T02:04:15Z", "closed_at": "2026-02-28T02:04:15Z", "close_reason": "Orphaned step wisps from closed patrol bd-wisp-rf81c", "dependencies": [{"issue_id": "bd-wisp-u9zoc", "depends_on_id": "bd-wisp-8z7a7", "type": "blocks", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-u9zoc", "depends_on_id": "bd-wisp-rf81c", "type": "parent-child", "created_at": "2026-02-27T17:41:41Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-rf81c"}
{"id": "bd-wisp-ulr1", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:54:01Z", "updated_at": "2026-02-28T00:03:42Z", "closed_at": "2026-02-28T00:03:42Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-uwpi", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 6: Rig idle. No polecats, no new mail. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-27T23:42:05Z", "updated_at": "2026-02-27T23:47:19Z", "closed_at": "2026-02-27T23:47:19Z", "close_reason": "patrol cycle complete: Cycle 6: Rig idle. No polecats, no new mail. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-v04y", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 12: 9 polecats healthy. garnet completed bd-0tn. No stuck workers. Refinery and deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:33:39Z", "updated_at": "2026-02-28T00:35:07Z", "closed_at": "2026-02-28T00:35:07Z", "close_reason": "patrol cycle complete: Cycle 12: 9 polecats healthy. garnet completed bd-0tn. No stuck workers. Refinery and deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-v979b", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 12: Rig idle. No activity.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:37:24Z", "updated_at": "2026-02-28T01:39:09Z", "closed_at": "2026-02-28T01:39:09Z", "close_reason": "patrol cycle complete: Cycle 12: Rig idle. No activity.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-vlc54v", "title": "DOG_DONE: plugin:dolt-backup", "description": "Dolt backup completed successfully. All 3 production databases synced: hq (265M), beads (101M), gastown (145M). See bd-wisp-4tsii5 for details.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "deacon/", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:10:35Z", "created_by": "overseer", "updated_at": "2026-02-27T23:53:11Z", "closed_at": "2026-02-27T23:53:11Z", "close_reason": "Dog/plugin noise", "labels": ["delivery:pending", "from:overseer", "gt:message", "thread:thread-dbf0b977a00e"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-w13866", "title": "mol-refinery-patrol", "description": "Merge queue processor patrol loop.\n\nThe Refinery is the Engineer in the engine room. You process polecat branches, merging them to main one at a time with sequential rebasing.\n\n**The Scotty Test**: Before proceeding past any failure, ask yourself: \"Would Scotty walk past a warp core leak because it existed before his shift?\"\n\n## Merge Flow\n\nThe Refinery receives MERGE_READY mail from Witnesses when polecats complete work:\n\n```\nWitness                    Refinery                      Git\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGE_READY              ‚îÇ                           ‚îÇ\n   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (verify branch)                   ‚îÇ\n   ‚îÇ                          ‚îÇ fetch & rebase            ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (run tests)                       ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ                    (if pass)                         ‚îÇ\n   ‚îÇ                          ‚îÇ merge & push              ‚îÇ\n   ‚îÇ                          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n   ‚îÇ MERGED                   ‚îÇ                           ‚îÇ\n   ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ                           ‚îÇ\n   ‚îÇ                          ‚îÇ                           ‚îÇ\n```\n\nAfter successful merge, Refinery sends MERGED mail back to Witness so it can\ncomplete cleanup (nuke the polecat worktree).", "status": "pinned", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-26T11:29:08Z", "updated_at": "2026-02-27T10:12:04Z", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-wdq2", "title": "mol-refinery-patrol", "description": "Patrol report: Merged 4 branches (bd-kzn, bd-tm2p, bd-ftc, bd-bwk2). Cleaned 2 stale MRs + 1 duplicate. Filed 2 pre-existing test failure bugs (bd-fu1, bd-6ie). Queue empty.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/refinery", "created_at": "2026-02-27T23:38:17Z", "updated_at": "2026-02-28T00:25:49Z", "closed_at": "2026-02-28T00:25:49Z", "close_reason": "patrol cycle complete: Merged 4 branches (bd-kzn, bd-tm2p, bd-ftc, bd-bwk2). Cleaned 2 stale MRs + 1 duplicate. Filed 2 pre-existing test failure bugs (bd-fu1, bd-6ie). Queue empty.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-wi9a", "title": "Merge: bd-kyu", "description": "branch: polecat/obsidian/bd-kyu@mm5lwut9\ntarget: main\nsource_issue: bd-kyu\nrig: beads\nworker: obsidian\nagent_bead: bd-beads-polecat-obsidian\nretry_count: 0\nlast_conflict_sha: null\nconflict_task_id: null", "status": "closed", "priority": 2, "issue_type": "task", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-28T01:02:09Z", "created_by": "beads/polecats/obsidian", "updated_at": "2026-02-28T01:10:42Z", "closed_at": "2026-02-28T01:10:42Z", "close_reason": "rejected: Duplicate: bd-kyu fix already merged via obsidian (bd-wisp-k4r9). This second submission conflicts with the already-merged version.", "labels": ["gt:merge-request"], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-wimlq", "title": "Ping Deacon for health check", "description": "Send WITNESS_PING to Deacon for second-order monitoring.\n\nThe Witness fleet collectively monitors Deacon health - this prevents the\n\"who watches the watchers\" problem. If Deacon dies, Witnesses detect it.\n\n**Step 1: Send ping**\n```bash\ngt mail send deacon/ -s \"WITNESS_PING <rig>\" -m \"Rig: <rig>\nTimestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)\nPatrol: <cycle-number>\"\n```\n\n**Step 2: Check Deacon health**\n```bash\n# Check Deacon agent bead for last_activity\nbd list --type=agent --json | jq '.[] | select(.description | contains(\"deacon\"))'\n```\n\nLook at the `last_activity` timestamp. If stale (>5 minutes since last update):\n- Deacon may be dead or stuck\n\n**Step 3: Escalate if needed**\n```bash\n# If Deacon appears down\ngt mail send mayor/ -s \"ALERT: Deacon appears unresponsive\" -m \"No Deacon activity for >5 minutes.\nLast seen: <timestamp>\nWitness: <rig>/witness\"\n```\n\nNote: Multiple Witnesses may send this alert. Mayor should handle deduplication.", "status": "closed", "priority": 2, "issue_type": "task", "assignee": "beads/witness", "created_at": "2026-02-28T01:48:33Z", "updated_at": "2026-02-28T01:50:32Z", "closed_at": "2026-02-28T01:50:32Z", "close_reason": "Deacon alive, nudged", "dependencies": [{"issue_id": "bd-wisp-wimlq", "depends_on_id": "bd-wisp-4y7xj", "type": "blocks", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}, {"issue_id": "bd-wisp-wimlq", "depends_on_id": "bd-wisp-azbte", "type": "parent-child", "created_at": "2026-02-27T17:48:32Z", "created_by": "witness", "metadata": "{}"}], "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0, "parent": "bd-wisp-azbte"}
{"id": "bd-wisp-wip8", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-27T23:54:42Z", "updated_at": "2026-02-28T00:23:31Z", "closed_at": "2026-02-28T00:23:31Z", "close_reason": "burned: force re-sling", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-x0s2", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:26:09Z", "updated_at": "2026-02-28T00:41:29Z", "closed_at": "2026-02-28T00:41:29Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-xmy8", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 14: Quiet patrol. Quartz active implementing bd-7vk routing fix. Refinery processing amber/bd-7vk MR (tests running). Deacon alive. No incidents.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T01:07:24Z", "updated_at": "2026-02-28T01:08:53Z", "closed_at": "2026-02-28T01:08:53Z", "close_reason": "patrol cycle complete: Cycle 14: Quiet patrol. Quartz active implementing bd-7vk routing fix. Refinery processing amber/bd-7vk MR (tests running). Deacon alive. No incidents.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-yk31", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 1: Nuked 7 completed polecats (jasper, garnet, topaz, opal, quartz, ruby, onyx). 3 active: amber(bd-7vk), obsidian(bd-kyu), quartz(bd-tk8y respawned). Refinery processing merges. Deacon alive.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:38:44Z", "updated_at": "2026-02-28T00:44:52Z", "closed_at": "2026-02-28T00:44:52Z", "close_reason": "patrol cycle complete: Cycle 1: Nuked 7 completed polecats (jasper, garnet, topaz, opal, quartz, ruby, onyx). 3 active: amber(bd-7vk), obsidian(bd-kyu), quartz(bd-tk8y respawned). Refinery processing merges. Deacon alive.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-yoki", "title": "mol-polecat-work", "description": "Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd ready` / `bd close <step>`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `bd ready` to find them - do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |", "status": "closed", "priority": 2, "issue_type": "epic", "created_at": "2026-02-28T00:23:31Z", "updated_at": "2026-02-28T00:26:45Z", "closed_at": "2026-02-28T00:26:45Z", "close_reason": "burned: polecat nuked", "ephemeral": true, "dependency_count": 0, "dependent_count": 1, "comment_count": 0}
{"id": "bd-wisp-yy3f", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 10: 8 polecats healthy and active. Refinery processing merge. Deacon alive. No stuck workers, no timer gates, no swarms. Inbox clean.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:16:13Z", "updated_at": "2026-02-28T00:31:48Z", "closed_at": "2026-02-28T00:31:48Z", "close_reason": "patrol cycle complete: Cycle 10: 8 polecats healthy and active. Refinery processing merge. Deacon alive. No stuck workers, no timer gates, no swarms. Inbox clean.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-z2ni", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 10: Nuked topaz+obsidian (both done, clean). bd-74w1 merged. Onyx respawned with bd-ee1. 6 polecats active, all working. Healthy.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:02:26Z", "updated_at": "2026-02-28T00:04:27Z", "closed_at": "2026-02-28T00:04:27Z", "close_reason": "patrol cycle complete: Cycle 10: Nuked topaz+obsidian (both done, clean). bd-74w1 merged. Onyx respawned with bd-ee1. 6 polecats active, all working. Healthy.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "bd-wisp-zvyl", "title": "mol-witness-patrol", "description": "Patrol report: Cycle 14: 9 polecats healthy. No new mail. Quiet cycle. Approaching handoff threshold.", "status": "closed", "priority": 2, "issue_type": "epic", "assignee": "beads/witness", "created_at": "2026-02-28T00:36:35Z", "updated_at": "2026-02-28T00:37:37Z", "closed_at": "2026-02-28T00:37:37Z", "close_reason": "patrol cycle complete: Cycle 14: 9 polecats healthy. No new mail. Quiet cycle. Approaching handoff threshold.", "ephemeral": true, "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
{"id": "hq-x1fq", "title": "Plugin run: rebuild-gt", "description": "Rebuilt gt: ce7af0ae ‚Üí 182718b6 (3 commits from gastown/crew/george)", "status": "open", "priority": 2, "issue_type": "message", "owner": "steve.yegge@gmail.com", "created_at": "2026-02-27T23:03:48Z", "created_by": "dog", "updated_at": "2026-02-27T23:03:48Z", "labels": ["plugin:rebuild-gt", "result:success", "rig:gastown", "type:plugin-run"], "ephemeral": true, "wisp_type": "patrol", "dependency_count": 0, "dependent_count": 0, "comment_count": 0}
